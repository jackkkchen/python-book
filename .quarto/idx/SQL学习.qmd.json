{"title":"SQL学习","markdown":{"headingText":"SQL学习","containsRefs":false,"markdown":"\n## SQL通用语法\n\nSQL语句可以单行或多行书写 以**分号结尾**\n\nSQL语句可以使用空格/缩进来增强语句的可读性\n\nMySQL数据库的SQL语句**不区分大小写，关键字建议使用大写**\n\n● 注释\n\n1. 单行注释 ：-- 注释内容 或#注释内容（MySQL独有）\n2. 多行注释 ：/* */\n\n## SQL分类\n\n● SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。\n\n###  DDL **数据定义语句** \n\n#### 库操作\n\n● 查询\n\n1)查询所有数据库\n\n```sql\n(SHOW)SHOW DATABASES;\n```\n\n2)查询当前数据库\n\n```sql\n(SELECT)SELECT DATABASE();\n```\n\n● 创建(CREATE)\n\n```sql\nCREATE DATABASE[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集][COLLATE 排序规则];\n```\n\n● 删除(DROP)\n\n```sql\nDROP DATABASES[IF EXISTS] 数据库名;\n```\n\n● 使用(USE)/*切换访问的数据库*/\n\n```sql\nUSE数据库名；\n```\n\nDDL 数据定义语句\n\n#### 表操作\n\n● 查询\n\n1）查询当前数据所有表\n\n```sql\nSHOW TABLES;\n```\n\n2）查询表结构\n\n```sql\nDESC 表名;\n```\n\n3）查询指定表的建表语句\n\n```sql\nSHOW CREATE TABLE 表名;\n```\n\n● 创建(CREATE)\n\n```sql\nCREATE TABLE 表名{\n\n字段1 字段1类型[COMMENT 字段1注释],\n\n字段2 字段2类型[COMMENT 字段2注释],\n\n字段3 字段3类型[COMMENT 字段3注释]\n\n}[COMMENT 表注释];\n```\n\n● 修改(ALTER)\n\n1. 添加字段(ADD)\n\n```sql\nALTER TABLE 表名 ADD 字段名 类型(长度)[comment 注释][约束];\n```\n\n2. 修改数据类型(MODIFY)\n\n```sql\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n```\n\n3. 修改字段名和字段类型(CHANGE)\n\n```sql\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度)[COMMENT 注释] [约束];\n```\n\n4. 删除字段（DROP）\n\n```sql\nALTER TABLE 表名 DROP 字段名;#删除列\n```\n\n5. 修改表名\n\n```sql\nALTER TABLE 表名 RENAME TO 新表名;\n```\n\n●  删除\n\n1. 删除表\n\n```sql\nDROP TABLE [IF EXISTS]表名;\n```\n\n2. 删除指定表，并重新创建该表(该表的**数据会被删除**，以该名表被重新创建)\n\n```sql\nTRUNCATE TABLE 表名;\n```\n\n#### DML 数据操作语句 \n\n##### ● 添加数据（INSERT）\n\n1. 给**指定字段**名添加数据\n\n```sql\nINSERT INTO 表名  (字段名1，字段名2， . . .)VALUES(值1，值2， . . .);\n```\n\n2. 给**全部字段名**添加数据\n\n```sql\nINSERT INTO 表名 VALUES(值1，值2， . . .);\n```\n\n3. 批量添加数据\n\n/*批量插入数据 用逗号隔开*/\n\n```sql\nINSERT INTO 表名(字段名1，字段名2， . . .)VALUES(值1，值2， . . .),(值1，值2， . . .),(值 1，值2， . . .);\n\nINSERT INTO 表名 VALUES (值1，值2， . . .)， (值1，值2， . . . .)， (值1，值2， . . . .);\n```\n\n**注意：**\n\n1）插入数据时，指定的字段顺序需要与值的**顺序是一致**的\n\n2）字符串和日期类型应该包含的在引号中\n\n3）插入的数据大小，应该在字段的规定范围内\n\n##### ● 修改数据（UPDATE）\n\n```sql\nUPDATE 表名 SET 字段名1=值1，字段名2=值2， . . .[WHERE 条件];\n```\n\n##### ● 删除（DELETE）\n\n```sql\nDELETE FROM 表名[WHERE 条件];\n```\n\n#### DQL 数据查询语句\n\n##### 基本查询\n\n1. 查询多个字段\n\n```sql\nSELECT 字段1,字段2，字段3 . . .FROM 表名;\n\nSELECT *FROM 表名(全部字段)#返回查询列表中所有数据\n```\n\n2. 设置别名（AS）\n\n```sql\nSELECT 字段1[AS 别名1],字段2[AS 别名2]. . .FROM表名;#别名要用单引号 AS可以省略\n```\n\n3. 去除重复纪录(DISTINCT)\n\n```sql\nSELECT DISTINCT 字段列表 FROM 表名;#将该列的重复的元素去除（去重）\n```\n\n##### 2.条件查询\n\n1. 语法(WHERE)\n\n```sql\nSELECT 字段列表 FROM WHERE 条件列表; # where相当于java中if语句 后接条件语句 字段列表 =*(所有列)\n```\n\n2. 条件\n\n​      ●  比较运算符\n\n| **比较运算符** | **功能**                                                |\n| -------------- | ------------------------------------------------------- |\n| \\>             | 大于                                                    |\n| \\>=            | 大于等于                                                |\n| <              | 小于                                                    |\n| <=             | 小于等于                                                |\n| =              | 等于                                                    |\n| <>或！ =       | 不等于                                                  |\n| BETWEEN...AND  | 在某个范围之内（含最小、最大值）                        |\n| IN(...)        | 在in之后的列表中的值，多选一                            |\n| LIKE 占位符    | 模糊匹配 ( _ 匹配**单个字符**,   % 匹配**任意个字符 **) |\n| IS NULL        | 是NULL                                                  |\n\n​        ● 逻辑运算符\n\n| **逻辑运算符** | **功能**                   |\n| -------------- | -------------------------- |\n| AND或&&        | 并且(多个条件同时成立)     |\n| OR或\\|\\|       | 或者(多个条件任意一个成立) |\n| NOT或！        | 非，不是                   |\n\n​       ●  聚合函数\n\n1. 介绍\n\n将一列数据作为一个整体\n\n2. 常见聚合函数\n\n| **函数** | **功能** |\n| :------- | -------- |\n| count    | 统计数量 |\n| max      | 最大值   |\n| min      | 最小值   |\n| avg      | 平均值   |\n| sum      | 求和     |\n\n\n\n```sql\nSELECT 聚合函数 from 表名;\n\nSELECT COUNT(*)FROM EMP;\n\nSELECT COUNT(ID)FROM EMP;\n\n#聚合函数传进去的是字段\n```\n\n注意:null值不参与聚合函数的运算\n\n##### 3.分组查询(GROUP BY)\n\n1. 语法\n\n```sql\nSELECT 字段列表 FROM 表名[WHERE 条件]GROUP BY 分组字段名[HAVING 分组后过滤条件];\n\nSELECT gender,count(*)from emp GROUP BY gender;\n\n#查询效果是 根据性别分组 统计男女的数量\n\nSELECT gender,AVG(age)FROM emp GROUP BY gender;\n\n#查询效果是 根据性别分组 统计男女的平均年龄\n\nSELECT address,COUNT(*)FROM emp WHERE age<xxx GROUP BY address;\n\n#查询效果是 根据地址分组 统计年龄小于xxx的人数\n\nSELECT address,COUNT(*) address_count FROM emp WHERE age<xxx GROUP BY address HAVING address_count>X;\n\n#上面一条语句的基础上再次筛选having\n```\n\n\n\n2. HAING 和WHERE区别\n\n执行时机不同:\n\nwhere是**分组之前**进行过滤，不满足where条件不进行分组；而having是 **分组之后**对结果进行过滤\n\n判断条件不同: \n\n**where不能对聚合函数进行判断** 而having可以。\n\n3. 注意\n\n执行顺序:where->聚合函数->having\n\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义(意思是分组字段和查询字段是相同的)\n\n##### 4.排序查询(ORDER BY)\n\n1. 语法\n\n```sql\n#支持多字段排序\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方1,字段2 排序方式2 SELECT * FROM emp ORDER BY age desc;#降序\n\nSELECT * FROM emp ORDER BY age asc;#升序\n\nSELECT * FROM emp ORDER BY age asc,entrydate desc;\n```\n\n2. 排序方式\n\nASC：升序（默认值）\n\nDESC：降序\n\n注意:如果是多字段查询时，当第一个字段值相同时，才会根据第二个字段进行排序\n\n##### 5.分页查询(LIMIT)\n\n1. 语法\n\n```sql\nSELECT 字段列表 FROM LIMIT 起始索引 ,查询记录数;#两个参数\n```\n\n注意\n\n1）起始索引是**从0开始，**起始索引 =（查询页码-1）*每页显示记录数\n\n2）**分页查询是数据库的方言**，不同的数据库有不同的实现， Mysql是LIMIT \n\n3）如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10\n\n\n\n## 函数\n\n### 字符串函数\n\n​       ● 常用函数\n\n| **函数**                 | **功能**                                                     |\n| ------------------------ | ------------------------------------------------------------ |\n| CONCAT(S1,S2,...Sn)      | 字符串拼接,将s1,s2,..sn拼接成一个字符串                      |\n| LOWER(str)               | 将字符串str全部转成小写                                      |\n| UPPER(str)               | 将字符串str全部转成大写                                      |\n| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度    |\n| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度    |\n| TRIM(str)                | 去掉字符串**头部和尾部的空格**                               |\n| SUBSTRING(str,start,len) | 返回从字符串str从start位置起len个长度的字符串SELECT 函数(参数); |\n\n### 2. 数值函数\n\n​       ● 常用函数\n\n| **函数**   | 功能                               |\n| ---------- | ---------------------------------- |\n| CEIL(x)    | 向上取整                           |\n| FLOOR(x)   | 向下取整                           |\n| MOD(x,y)   | 返回x/y的模                        |\n| RAND()     | 返回0~1的随机数                    |\n| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |\n\n### **3.** **日期函数**\n\n​       ●  常用函数\n\n| **函数**                          | **功能**                                            |\n| --------------------------------- | --------------------------------------------------- |\n| CURDATE()                         | 返回当前日期                                        |\n| CURTIME()                         | 返回当前时间                                        |\n| NOW()                             | 返回当前日期和时间                                  |\n| YEAR(date)                        | 返回当前指定date的年份                              |\n| MONTH(date)                       | 返回当前指定date的月份                              |\n| DAY(date)                         | 返回当前指定date的日期                              |\n| DATE_ADD(date,INTERVAL_EXPR type) | 返回一个日期/时间加上一个**时间间隔**expr后的时间值 |\n| DATEDIFF(date1 ，date2)           | 返回起始时间date1和结束时间date2之间的天数          |\n\n 举例：\n\n```sql\nSELECT date_add(now(),INTERVAL 70 YEAR);\n\n#查询员工的入职天数\n\nSELECT name,diff(now(),entrydate) as entrydayscount FROM emp Group By entrydayscount SELECT name,DATEDIFF(NOW(),'2000-11-12 ')FROM emp\n```\n\n\n\n### 4. 流程函数\n\n​       ● 常见函数\n\n| **函数**                                          | 功能                                                         |\n| ------------------------------------------------- | ------------------------------------------------------------ |\n| IF(Value ，t ，f)                                 | 如果value为true，则返回t，否则返回f                          |\n| IFNULL(Value1,Value2)                             | 如果Value1不为空(空=null)，则返回value1，否则返回value2      |\n| CASE WHEN[val1]THEN[res1]...ELSE[default]END      | 如果val1为true，返回res1，否则返回default默认值              |\n| CASE [expr]WHEN[val]THEN[res1]...ELSE[default]END | 如果**expr(表达式)**的值等于val1，返回res1 ，...否则返回default默认值 |\n\n举例：\n\n```sql\nSELECT name,(case workaddress when '北京 'then'一线城市 'when '上海 'then'一线城 市 'else'二线城市 'end) as '工作地址 '\n\nSELECT id,name,(case when math>=85 then '优秀 ' when math>=60 then '及格 'else '不 及格 'end)as '数学 '),\n\n(case when English>=85 then '优秀 ' when English>=60 then '及格 'else '不及格 'end)as '英语 '),\n\n(case when Chinese>=85 then '优秀 ' when Chinese>=60 then '及格 'else '不及格 'end)as '语文 ')\n\nFROM score;\n```\n\n\n\n## 约束\n\n### 概述和分类\n\n1. 概念\n\n约束是**作用表中字段**上的规则，用于限制存储在表中的数据\n\n2. 作用\n\n保证数据库中数据的**正确性、有效性和完整性**\n\n3. 分类                          \n\n   | 约束     | **描述**                                                 | **关键字**  |\n   | -------- | -------------------------------------------------------- | ----------- |\n   | 非空约束 | 限制该字段的数据不能为null                               | NOT NULL    |\n   | 唯一约束 | 保证该字段的所有数据都是**唯一** ，**不重复**的          | UNIQUE      |\n   | 主键约束 | 主键是一行数据的唯一标识，要求**非空且唯一**             | PRIMARY KEY |\n   | 默认约束 | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT     |\n   | 检查约束 | 保证字段值满足某一个条件(逻辑表达式+比较运算符)          | CHECK       |\n   | 外键约束 | 用来让两张表的数据中之间建立连接，保证数据的一致性和完整 | FOREIGN KEY |\n   \n   ****\n\n注意:约束是作用在表中字段上的，可以在**创建表**/**修改表**的时候添加约束\n\n### **2.** **案例展示**\n\n```sql\ncreate table user(\n\nid int primary key auto_increment comment '主键 ',\n\nname varchar(10) not null comment '名字 ',\n\nage int check ( age>0&&age<120 ) comment '年龄 ',  # mysql 版本要在8 .0才支持该语句 \n\nstatus char(1) default '1 'comment '状态 ',\n\ngander char(1) comment'性别 '\n\n)comment '用户表 ';\n```\n\n### **3.** **外键约束**\n\n**3.** **1** **语法**\n\n添加外键:保证数据的完整性和一致性\n\n```sql\n#建表前添加外键\n\nCREATE TABLE 表名{\n\n     字段名 数据类型 ,\n\n     ...\n\n     [CONSTRAINT][外键名称]FOREIGN KEY(外键字段名)REFERENCES 主表（主表列名） };\n\n#建表后进行添加外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表(主表列 名);#表名连接主表\n\nALTER TABLE 表名 ADD CONSTRAINT FK_表名_外键字段名 FOREIGN KEY (外键字段名)REFERENCES 主(父)表(主表列名);\n```\n\n删除外键\n\n```sql\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n```\n\n删除/更新行为(DELETE/UPDATE)\n\n| **行为**     | **说明**                                                     |\n| ------------ | ------------------------------------------------------------ |\n| NO ACTION    | 当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则不允许删除/更 新。 |\n| RESTRICT     | 同上                                                         |\n| CASCADE      | 当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键 在字表中的记录 |\n| SET NULL     | 当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则设置字表中该外 键值为null |\n| SET  DEFAULT | 父表有变更时，字表将外键列设置成一个默认值(Innodb不支持)     |\n\n语法：\n\n```sql\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段)References 主表名(字表字 段名) ON UPDATE CASCADE ON DELETE CASCADE;\n```\n\n\n\n## 多表查询\n\n### 多表关系\n\n概述:\n\n由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本分为三种\n\n\n\n####        ● 一对多(多对一)\n\n案例:部门与员工的关系\n\n关系:一个部门对应多个员工， 一个员工只能对应一个部门\n\n实现:**在多的一方建立外键，指向一的一方的主键**(员工表为多表，部门表就为一表)\n\n####        **● 多对多**\n\n案例:学生和课程的关系\n\n关系:一个雪上可以选修多门课程， 一门课程也可以供多个学生选择\n\n实现:**建立第三张中间表**，中间表至少包含两个外键，分别**关联两方主键**(primary key)\n\n####        **● 一对一**\n\n案例:用户与用户详情的关系\n\n关系:一对一关系，多用于单表拆分，将一张表的**基础字段**放在一张表中， **其他详情字段放在另一张** **表中**，以提升操作效率\n\n实现:在任意的一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\n\n### 2.多表查询\n\n​        ● 概述: 指从多张表中查询数据\n\n笛卡尔积:笛卡尔乘积是指在数学中个，两个集合A集合和B集合的所有组合情况。(**多表查询时，需要消除无效的笛卡尔积（连接条件）** )\n\n```sql\n#多表查询\n\nSELECT * FROM 父表 ,外表;\n```\n\n####         **● 多表查询分类**\n\n​              连接查询\n\n1. 内连接\n\n​       相当于查询A、B**交集**部分数据\n\n2. 外连接\n\n​      •左外连接\n\n​      •右外连接\n\n3. 自连接\n\n​      当前表与自身的连接查询，自连接**必须使用表别名**\n\n4. 联合查询\n\n​       •子查询\n\n### 3.连接查询\n\n#### **3.1** **内连接**\n\n​       ● 隐式内连接\n\n```sql\nSELECT 字段列表 FROM 表1，表2 WHERE 条件 . . .;\n\n#例子 emp员工表 dept部门表\n\nSELECT emp.name,dept.name FROM emp,dept WHERE emp.dept_id=dept.id;\n```\n\n​       ● 显式内连接\n\n```sql\nSELECT 字段列表 FROM 表1,[INNER] JOIN 表2 ON 连接条件;\n\n#例子\n\nSELECT e.name,d.name FROM emp e INNER JOIN dept d ON e.dept_id=d.id;\n```\n\n#### **3.2** **外连接**\n\n​       ● 左外连接(LEFT JOIN)\n\n```sql\nSELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 #字段列表根据需求可进行优化 因为按照sql语句的执行属性可知select是在后面执行\n```\n\n相当于查询表1(左表)的所有数据和包含表1和表2交集部分的数据\n\n​       ●  右外连接(RIGHT JOIN)\n\n```sql\nSELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件\n```\n\n相当于查询表2(右表)的所有数据和包含表1和表2交集部分的数据\n\n#### **3.3** **自连接**\n\n​       ●  语法\n\n```sql\n# 把一张表看做成两张表 通过唯一 的id做为自连接的条件 managerid=id\n\n# 自连接必须给表名取别名！ ！ ！\n\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 . . .;\n\n# 举例：\n\nSELECT a.name,b.name FROM emp a JOIN emp b ON a.managerid=b.id;\n```\n\n \n\n#### **3.4** **联合查询**\n\n​       ● 定义\n\n对于联合查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n\n​       ● 关键词\n\n```sql\n# 作为单独一句 在两个sql语句查询中间\n\nUNION #将查询的结果合并时 ，进行去重\n\nUNION ALL #直接将查询的结果进行合并\n```\n\n注意\n\n1. 对于联合查询多表查询的；列数必须保持一致，字段类型也必须保持一致 \n1. union all 会将全部数据直接合并在一起， union 会对合并之后的数据去重\n\n### 4.子查询\n\n#### **4.1** **概述**\n\n​       **● 概念:**SQL语句中嵌套SELECT语句，成为**嵌套语句**，又称子查询\n\n```sql\nSELECT * FROM t1 WHERE column1=(SELECT column1 FROM t2);\n#子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个\n```\n\n​       ● **查询结果分类**\n\n1. 标量子查询(子表查询结果为单个值)\n2. 列子查询（子查询结果为一列）\n3. 行子查询（子查询结果为一行）\n4. 表子查询（子查询结果为多行多列）\n\n​       ● **根据子查询位置**\n\n1. WHERE之后\n2. FROM之后\n3. SELECT之后\n\n#### **4.2** **查询结果分类**\n\n#####        **● 标量子查询**\n\n1. 定义: 子查询返回的结果是单个值(数字，字符串，日期等)，最简单的形式，这种子查询称为标量子查询\n2. 常用操作符:= 、<>、> 、>=、 < 、<=\n3. 案例展示\n\n```sql\n# emp员工信息表\n\n# dept部门表\n\n# 要求查询具体部门对应的员工信息 前提员工表和部门表是已经建立了连接(foreign key) # 分析 首先得知道具体部门的部门ID 进而查询该部门的员工信息\n\n# 可以两种sql写法\n\nSELECT id FROM dept WHERE name='具体的部门名 ';\n\nSELECT * FROM emp WHERE dept_id =\"上条语句的结果\";\n\n# 所以可以整合成一句 形成嵌套\n\nSELECT * FROM emp WHERE dept_id=(SELECT id FROM dept WHERE name='具体的部门名 ');\n```\n\n#####        **● 列子查询**\n\n1. 子查询返回的结果是一列(可以是多行 )，这种子查询为列子查询\n\n2. 常用操作符:IN、NOT IN、ANY、SOME、ALL\n\n| **操作符** | **描述**                                   |\n| ---------- | ------------------------------------------ |\n| IN         | 在指定的集合范围之内，多选一               |\n| NOT IN     | 不在指定的集合范围之内                     |\n| **ANY**    | 子查询返回列表中，有**任意一个满足**即可   |\n| **SOME**   | 与ANY**等同**，使用SOME的地方都可以使用ANY |\n| **ALL**    | 子查询返回列表的**所有值都必须满足**       |\n\n3. 案例演示\n\n```sql\n#查询比财务部所有人工资都高的员工信息\n\n#将获取信息的问题拆分化 在通过嵌套进行优化 形成一句sql语句\n\n# 获取财务部的部门id\n\nSELECT id FROM dept WHERE name ='财务部';\n\n# 获取财务中所有人的工资\n\nSELECT salary FROM emp WHERE id=(SELECT id FROM dept WHERE name ='财务部');\n\n# 获取比财务部所有员工工资都高的员工信息\n\nSELECT * FROM emp WHERE salary>ALL SELECT salary FROM emp WHERE id=(SELECT id FROM dept WHERE name ='财务部');\n```\n\n#####        ● 行子查询\n\n1 . 子查询返回的结果是一行(可以是多列)，这种子查询为行子查询\n\n2 . 常用操作符:IN、 NOT IN、ANY、 SOME、ALL(同上)\n\n3 . 案例演示\n\n```sql\n# 查询张无忌的薪资及直属领导相同的员工信息\n\nSELECT salary managerid FROM emp WHERE name=\"张无忌 \";\n\nSELECT * FROM emp WHERE (salary,managerid)=(SELECT salary managerid FROM emp WHERE name=\"张无忌 \");\n\n#返回的结果是一行多列 对应的是salary和managerID\n```\n\n#####        ● 表子查询\n\n1. 表子查询返回的结果是多行多列，这种子查询为列表查询\n2. 常用操作符: IN\n3. 案例演示\n\n```sql\n#查询入职日期是 “2006-01-01”之后的员工信息和部门信息\n\nSELECT * FROM emp where entrydate>'2006-01-01';\n\nSELECT e.*,d.* FROM (SELECT * FROM emp where entrydate>'2006-01-01 ') e LEFT JOIN dept d on e.dept_id=d.id;\n```\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"SQL学习.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","theme":"cosmo","cover-image":"img/logo.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}