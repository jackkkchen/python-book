[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MySQL入门学习",
    "section": "",
    "text": "前言\n这是由明数科技归纳整理出的 MySQL 入门教程，专门针对新手小白～"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "intro.html#mysql三层结构",
    "href": "intro.html#mysql三层结构",
    "title": "1  MySQL介绍",
    "section": "1.1 MySQL三层结构",
    "text": "1.1 MySQL三层结构\n\n1.1.1 数据库\n全称是存储数据的仓库，数据时候有组织的进行存储；简称DataBase(DB)\n\n\n1.1.2 数据库管理系统\n全称是操纵和管理数据库的大型软件 ；简称DataBase Management System（DBMS）\n\n\n1.1.3 SQL\n操纵关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 ；简称Structured Query Language（SQL）"
  },
  {
    "objectID": "intro.html#主流的关系型数据库管理系统系统",
    "href": "intro.html#主流的关系型数据库管理系统系统",
    "title": "1  MySQL介绍",
    "section": "1.2 主流的关系型数据库管理系统系统",
    "text": "1.2 主流的关系型数据库管理系统系统\n● Oracle\n● MySQL\n● Microsoft SQL Server"
  },
  {
    "objectID": "SQL学习.html#三-函数",
    "href": "SQL学习.html#三-函数",
    "title": "2  SQL学习",
    "section": "2.3 三、 函数",
    "text": "2.3 三、 函数\n\n2.3.1 1.字符串函数\n​ ● 常用函数\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\nCONCAT(S1,S2,…Sn)\n字符串拼接,将s1,s2,..sn拼接成一个字符串\n\n\nLOWER(str)\n将字符串str全部转成小写\n\n\nUPPER(str)\n将字符串str全部转成大写\n\n\nLPAD(str,n,pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n\n\nRPAD(str,n,pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str,start,len)\n返回从字符串str从start位置起len个长度的字符串SELECT 函数(参数);\n\n\n\n\n\n2.3.2 2. 数值函数\n​ ● 常用函数\n\n\n\n函数\n功能\n\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x,y)\n返回x/y的模\n\n\nRAND()\n返回0~1的随机数\n\n\nROUND(x,y)\n求参数x的四舍五入的值，保留y位小数\n\n\n\n\n\n2.3.3 3. 日期函数\n​ ● 常用函数\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n返回当前指定date的年份\n\n\nMONTH(date)\n返回当前指定date的月份\n\n\nDAY(date)\n返回当前指定date的日期\n\n\nDATE_ADD(date,INTERVAL_EXPR type)\n返回一个日期/时间加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1 ，date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n\n举例：\nSELECT date_add(now(),INTERVAL 70 YEAR);\n\n#查询员工的入职天数\n\nSELECT name,diff(now(),entrydate) as entrydayscount FROM emp Group By entrydayscount SELECT name,DATEDIFF(NOW(),'2000-11-12 ')FROM emp\n\n\n2.3.4 4. 流程函数\n​ ● 常见函数\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\nIF(Value ，t ，f)\n如果value为true，则返回t，否则返回f\n\n\nIFNULL(Value1,Value2)\n如果Value1不为空(空=null)，则返回value1，否则返回value2\n\n\nCASE WHEN[val1]THEN[res1]…ELSE[default]END\n如果val1为true，返回res1，否则返回default默认值\n\n\nCASE [expr]WHEN[val]THEN[res1]…ELSE[default]END\n如果expr(表达式)的值等于val1，返回res1 ，…否则返回default默认值\n\n\n\n举例：\nSELECT name,(case workaddress when '北京 'then'一线城市 'when '上海 'then'一线城 市 'else'二线城市 'end) as '工作地址 '\n\nSELECT id,name,(case when math&gt;=85 then '优秀 ' when math&gt;=60 then '及格 'else '不 及格 'end)as '数学 '),\n\n(case when English&gt;=85 then '优秀 ' when English&gt;=60 then '及格 'else '不及格 'end)as '英语 '),\n\n(case when Chinese&gt;=85 then '优秀 ' when Chinese&gt;=60 then '及格 'else '不及格 'end)as '语文 ')\n\nFROM score;"
  },
  {
    "objectID": "SQL学习.html#四约束",
    "href": "SQL学习.html#四约束",
    "title": "2  SQL学习",
    "section": "2.4 四、约束",
    "text": "2.4 四、约束\n\n2.4.1 1. 概述和分类\n\n概念\n\n约束是作用表中字段上的规则，用于限制存储在表中的数据\n\n作用\n\n保证数据库中数据的正确性、有效性和完整性\n\n分类\n\n\n\n\n\n\n\n\n约束\n描述\n关键字\n\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一 ，不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束\n保证字段值满足某一个条件(逻辑表达式+比较运算符)\nCHECK\n\n\n外键约束\n用来让两张表的数据中之间建立连接，保证数据的一致性和完整\nFOREIGN KEY\n\n\n\n\n\n注意:约束是作用在表中字段上的，可以在创建表/修改表的时候添加约束\n\n\n2.4.2 2. 案例展示\ncreate table user(\n\nid int primary key auto_increment comment '主键 ',\n\nname varchar(10) not null comment '名字 ',\n\nage int check ( age&gt;0&&age&lt;120 ) comment '年龄 ',  # mysql 版本要在8 .0才支持该语句 \n\nstatus char(1) default '1 'comment '状态 ',\n\ngander char(1) comment'性别 '\n\n)comment '用户表 ';\n\n\n2.4.3 3. 外键约束\n3. 1 语法\n添加外键:保证数据的完整性和一致性\n#建表前添加外键\n\nCREATE TABLE 表名{\n\n     字段名 数据类型 ,\n\n     ...\n\n     [CONSTRAINT][外键名称]FOREIGN KEY(外键字段名)REFERENCES 主表（主表列名） };\n\n#建表后进行添加外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表(主表列 名);#表名连接主表\n\nALTER TABLE 表名 ADD CONSTRAINT FK_表名_外键字段名 FOREIGN KEY (外键字段名)REFERENCES 主(父)表(主表列名);\n删除外键\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n删除/更新行为(DELETE/UPDATE)\n\n\n\n\n\n\n\n行为\n说明\n\n\n\n\nNO ACTION\n当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则不允许删除/更 新。\n\n\nRESTRICT\n同上\n\n\nCASCADE\n当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键 在字表中的记录\n\n\nSET NULL\n当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则设置字表中该外 键值为null\n\n\nSET DEFAULT\n父表有变更时，字表将外键列设置成一个默认值(Innodb不支持)\n\n\n\n语法：\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段)References 主表名(字表字 段名) ON UPDATE CASCADE ON DELETE CASCADE;"
  },
  {
    "objectID": "SQL学习.html#五多表查询",
    "href": "SQL学习.html#五多表查询",
    "title": "2  SQL学习",
    "section": "2.5 五、多表查询",
    "text": "2.5 五、多表查询\n\n2.5.1 1.多表关系\n概述:\n由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本分为三种\n\n2.5.1.1 ● 一对多(多对一)\n案例:部门与员工的关系\n关系:一个部门对应多个员工， 一个员工只能对应一个部门\n实现:在多的一方建立外键，指向一的一方的主键(员工表为多表，部门表就为一表)\n\n\n2.5.1.2 ● 多对多\n案例:学生和课程的关系\n关系:一个雪上可以选修多门课程， 一门课程也可以供多个学生选择\n实现:建立第三张中间表，中间表至少包含两个外键，分别关联两方主键(primary key)\n\n\n2.5.1.3 ● 一对一\n案例:用户与用户详情的关系\n关系:一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中， 其他详情字段放在另一张 表中，以提升操作效率\n实现:在任意的一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\n\n\n\n2.5.2 2.多表查询\n​ ● 概述: 指从多张表中查询数据\n笛卡尔积:笛卡尔乘积是指在数学中个，两个集合A集合和B集合的所有组合情况。(多表查询时，需要消除无效的笛卡尔积（连接条件） )\n#多表查询\n\nSELECT * FROM 父表 ,外表;\n\n2.5.2.1 ● 多表查询分类\n​ 连接查询\n\n内连接\n\n​ 相当于查询A、B交集部分数据\n\n外连接\n\n​ •左外连接\n​ •右外连接\n\n自连接\n\n​ 当前表与自身的连接查询，自连接必须使用表别名\n\n联合查询\n\n​ •子查询\n\n\n\n2.5.3 3.连接查询\n\n2.5.3.1 3.1 内连接\n​ ● 隐式内连接\nSELECT 字段列表 FROM 表1，表2 WHERE 条件 . . .;\n\n#例子 emp员工表 dept部门表\n\nSELECT emp.name,dept.name FROM emp,dept WHERE emp.dept_id=dept.id;\n​ ● 显式内连接\nSELECT 字段列表 FROM 表1,[INNER] JOIN 表2 ON 连接条件;\n\n#例子\n\nSELECT e.name,d.name FROM emp e INNER JOIN dept d ON e.dept_id=d.id;\n\n\n2.5.3.2 3.2 外连接\n​ ● 左外连接(LEFT JOIN)\nSELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 #字段列表根据需求可进行优化 因为按照sql语句的执行属性可知select是在后面执行\n相当于查询表1(左表)的所有数据和包含表1和表2交集部分的数据\n​ ● 右外连接(RIGHT JOIN)\nSELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件\n相当于查询表2(右表)的所有数据和包含表1和表2交集部分的数据\n\n\n2.5.3.3 3.3 自连接\n​ ● 语法\n# 把一张表看做成两张表 通过唯一 的id做为自连接的条件 managerid=id\n\n# 自连接必须给表名取别名！ ！ ！\n\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 . . .;\n\n# 举例：\n\nSELECT a.name,b.name FROM emp a JOIN emp b ON a.managerid=b.id;\n\n\n2.5.3.4 3.4 联合查询\n​ ● 定义\n对于联合查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n​ ● 关键词\n# 作为单独一句 在两个sql语句查询中间\n\nUNION #将查询的结果合并时 ，进行去重\n\nUNION ALL #直接将查询的结果进行合并\n注意\n\n对于联合查询多表查询的；列数必须保持一致，字段类型也必须保持一致\nunion all 会将全部数据直接合并在一起， union 会对合并之后的数据去重\n\n\n\n\n2.5.4 4.子查询\n\n2.5.4.1 4.1 概述\n​ ● 概念:SQL语句中嵌套SELECT语句，成为嵌套语句，又称子查询\nSELECT * FROM t1 WHERE column1=(SELECT column1 FROM t2);\n#子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个\n​ ● 查询结果分类\n\n标量子查询(子表查询结果为单个值)\n列子查询（子查询结果为一列）\n行子查询（子查询结果为一行）\n表子查询（子查询结果为多行多列）\n\n​ ● 根据子查询位置\n\nWHERE之后\nFROM之后\nSELECT之后\n\n\n\n2.5.4.2 4.2 查询结果分类\n\n2.5.4.2.1 ● 标量子查询\n\n定义: 子查询返回的结果是单个值(数字，字符串，日期等)，最简单的形式，这种子查询称为标量子查询\n常用操作符:= 、&lt;&gt;、&gt; 、&gt;=、 &lt; 、&lt;=\n案例展示\n\n# emp员工信息表\n\n# dept部门表\n\n# 要求查询具体部门对应的员工信息 前提员工表和部门表是已经建立了连接(foreign key) # 分析 首先得知道具体部门的部门ID 进而查询该部门的员工信息\n\n# 可以两种sql写法\n\nSELECT id FROM dept WHERE name='具体的部门名 ';\n\nSELECT * FROM emp WHERE dept_id =\"上条语句的结果\";\n\n# 所以可以整合成一句 形成嵌套\n\nSELECT * FROM emp WHERE dept_id=(SELECT id FROM dept WHERE name='具体的部门名 ');\n\n\n2.5.4.2.2 ● 列子查询\n\n子查询返回的结果是一列(可以是多行 )，这种子查询为列子查询\n常用操作符:IN、NOT IN、ANY、SOME、ALL\n\n\n\n\n操作符\n描述\n\n\n\n\nIN\n在指定的集合范围之内，多选一\n\n\nNOT IN\n不在指定的集合范围之内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n\n\n案例演示\n\n#查询比财务部所有人工资都高的员工信息\n\n#将获取信息的问题拆分化 在通过嵌套进行优化 形成一句sql语句\n\n# 获取财务部的部门id\n\nSELECT id FROM dept WHERE name ='财务部';\n\n# 获取财务中所有人的工资\n\nSELECT salary FROM emp WHERE id=(SELECT id FROM dept WHERE name ='财务部');\n\n# 获取比财务部所有员工工资都高的员工信息\n\nSELECT * FROM emp WHERE salary&gt;ALL SELECT salary FROM emp WHERE id=(SELECT id FROM dept WHERE name ='财务部');\n\n\n2.5.4.2.3 ● 行子查询\n1 . 子查询返回的结果是一行(可以是多列)，这种子查询为行子查询\n2 . 常用操作符:IN、 NOT IN、ANY、 SOME、ALL(同上)\n3 . 案例演示\n# 查询张无忌的薪资及直属领导相同的员工信息\n\nSELECT salary managerid FROM emp WHERE name=\"张无忌 \";\n\nSELECT * FROM emp WHERE (salary,managerid)=(SELECT salary managerid FROM emp WHERE name=\"张无忌 \");\n\n#返回的结果是一行多列 对应的是salary和managerID\n\n\n2.5.4.2.4 ● 表子查询\n\n表子查询返回的结果是多行多列，这种子查询为列表查询\n常用操作符: IN\n案例演示\n\n#查询入职日期是 “2006-01-01”之后的员工信息和部门信息\n\nSELECT * FROM emp where entrydate&gt;'2006-01-01';\n\nSELECT e.*,d.* FROM (SELECT * FROM emp where entrydate&gt;'2006-01-01 ') e LEFT JOIN dept d on e.dept_id=d.id;"
  },
  {
    "objectID": "SQL学习.html#section",
    "href": "SQL学习.html#section",
    "title": "2  SQL学习",
    "section": "2.1 ",
    "text": "2.1 \n\n2.1.1 SQL分类\n● SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。\n\n2.1.1.1 2.1 DDL 数据定义语句\n\n2.1.1.1.1 ● 库操作\n● 查询\n1)查询所有数据库\n(SHOW)SHOW DATABASES;\n2)查询当前数据库\n(SELECT)SELECT DATABASE();\n● 创建(CREATE)\nCREATE DATABASE[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集][COLLATE 排序规则];\n● 删除(DROP)\nDROP DATABASES[IF EXISTS] 数据库名;\n● 使用(USE)/切换访问的数据库/\nUSE数据库名；\nDDL 数据定义语句\n\n\n2.1.1.1.2 ● 表操作\n● 查询\n1）查询当前数据所有表\nSHOW TABLES;\n2）查询表结构\nDESC 表名;\n3）查询指定表的建表语句\nSHOW CREATE TABLE 表名;\n● 创建(CREATE)\nCREATE TABLE 表名{\n\n字段1 字段1类型[COMMENT 字段1注释],\n\n字段2 字段2类型[COMMENT 字段2注释],\n\n字段3 字段3类型[COMMENT 字段3注释]\n\n}[COMMENT 表注释];\n● 修改(ALTER)\n\n添加字段(ADD)\n\nALTER TABLE 表名 ADD 字段名 类型(长度)[comment 注释][约束];\n\n修改数据类型(MODIFY)\n\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n\n修改字段名和字段类型(CHANGE)\n\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度)[COMMENT 注释] [约束];\n\n删除字段（DROP）\n\nALTER TABLE 表名 DROP 字段名;#删除列\n\n修改表名\n\nALTER TABLE 表名 RENAME TO 新表名;\n● 删除\n\n删除表\n\nDROP TABLE [IF EXISTS]表名;\n\n删除指定表，并重新创建该表(该表的数据会被删除，以该名表被重新创建)\n\nTRUNCATE TABLE 表名;\n\n\n\n2.1.1.2 2.2DML 数据操作语句\n\n2.1.1.2.1 ● 添加数据（INSERT）\n\n给指定字段名添加数据\n\nINSERT INTO 表名  (字段名1，字段名2， . . .)VALUES(值1，值2， . . .);\n\n给全部字段名添加数据\n\nINSERT INTO 表名 VALUES(值1，值2， . . .);\n\n批量添加数据\n\n/批量插入数据 用逗号隔开/\nINSERT INTO 表名(字段名1，字段名2， . . .)VALUES(值1，值2， . . .),(值1，值2， . . .),(值 1，值2， . . .);\n\nINSERT INTO 表名 VALUES (值1，值2， . . .)， (值1，值2， . . . .)， (值1，值2， . . . .);\n注意：\n1）插入数据时，指定的字段顺序需要与值的顺序是一致的\n2）字符串和日期类型应该包含的在引号中\n3）插入的数据大小，应该在字段的规定范围内\n\n\n2.1.1.2.2 ● 修改数据（UPDATE）\nUPDATE 表名 SET 字段名1=值1，字段名2=值2， . . .[WHERE 条件];\n\n\n2.1.1.2.3 ● 删除（DELETE）\nDELETE FROM 表名[WHERE 条件];\n\n\n\n2.1.1.3 DQL 数据查询语句\n\n2.1.1.3.1 基本查询\n\n查询多个字段\n\nSELECT 字段1,字段2，字段3 . . .FROM 表名;\n\nSELECT *FROM 表名(全部字段)#返回查询列表中所有数据\n\n设置别名（AS）\n\nSELECT 字段1[AS 别名1],字段2[AS 别名2]. . .FROM表名;#别名要用单引号 AS可以省略\n\n去除重复纪录(DISTINCT)\n\nSELECT DISTINCT 字段列表 FROM 表名;#将该列的重复的元素去除（去重）\n\n\n2.1.1.3.2 2.条件查询\n\n语法(WHERE)\n\nSELECT 字段列表 FROM WHERE 条件列表; # where相当于java中if语句 后接条件语句 字段列表 =*(所有列)\n\n条件\n\n​ ● 比较运算符\n\n\n\n\n\n\n\n比较运算符\n功能\n\n\n\n\n&gt;\n大于\n\n\n&gt;=\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;=\n小于等于\n\n\n=\n等于\n\n\n&lt;&gt;或！ =\n不等于\n\n\nBETWEEN…AND\n在某个范围之内（含最小、最大值）\n\n\nIN(…)\n在in之后的列表中的值，多选一\n\n\nLIKE 占位符\n模糊匹配 ( _ 匹配单个字符, % 匹配任意个字符 )\n\n\nIS NULL\n是NULL\n\n\n\n​ ● 逻辑运算符\n\n\n\n逻辑运算符\n功能\n\n\n\n\nAND或&&\n并且(多个条件同时成立)\n\n\nOR或||\n或者(多个条件任意一个成立)\n\n\nNOT或！\n非，不是\n\n\n\n​ ● 聚合函数\n\n介绍\n\n将一列数据作为一个整体\n\n常见聚合函数\n\n\n\n\n函数\n功能\n\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n\nSELECT 聚合函数 from 表名;\n\nSELECT COUNT(*)FROM EMP;\n\nSELECT COUNT(ID)FROM EMP;\n\n#聚合函数传进去的是字段\n注意:null值不参与聚合函数的运算\n\n\n2.1.1.3.3 3.分组查询(GROUP BY)\n\n语法\n\nSELECT 字段列表 FROM 表名[WHERE 条件]GROUP BY 分组字段名[HAVING 分组后过滤条件];\n\nSELECT gender,count(*)from emp GROUP BY gender;\n\n#查询效果是 根据性别分组 统计男女的数量\n\nSELECT gender,AVG(age)FROM emp GROUP BY gender;\n\n#查询效果是 根据性别分组 统计男女的平均年龄\n\nSELECT address,COUNT(*)FROM emp WHERE age&lt;xxx GROUP BY address;\n\n#查询效果是 根据地址分组 统计年龄小于xxx的人数\n\nSELECT address,COUNT(*) address_count FROM emp WHERE age&lt;xxx GROUP BY address HAVING address_count&gt;X;\n\n#上面一条语句的基础上再次筛选having\n\nHAING 和WHERE区别\n\n执行时机不同:\nwhere是分组之前进行过滤，不满足where条件不进行分组；而having是 分组之后对结果进行过滤\n判断条件不同:\nwhere不能对聚合函数进行判断 而having可以。\n\n注意\n\n执行顺序:where-&gt;聚合函数-&gt;having\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义(意思是分组字段和查询字段是相同的)\n\n\n2.1.1.3.4 4.排序查询(ORDER BY)\n\n语法\n\n#支持多字段排序\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方1,字段2 排序方式2 SELECT * FROM emp ORDER BY age desc;#降序\n\nSELECT * FROM emp ORDER BY age asc;#升序\n\nSELECT * FROM emp ORDER BY age asc,entrydate desc;\n\n排序方式\n\nASC：升序（默认值）\nDESC：降序\n注意:如果是多字段查询时，当第一个字段值相同时，才会根据第二个字段进行排序\n\n\n2.1.1.3.5 5.分页查询(LIMIT)\n\n语法\n\nSELECT 字段列表 FROM LIMIT 起始索引 ,查询记录数;#两个参数\n注意\n1）起始索引是从0开始，起始索引 =（查询页码-1）*每页显示记录数\n2）分页查询是数据库的方言，不同的数据库有不同的实现， Mysql是LIMIT\n3）如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10"
  },
  {
    "objectID": "SQL学习.html#sql通用语法",
    "href": "SQL学习.html#sql通用语法",
    "title": "2  SQL学习",
    "section": "2.1 SQL通用语法",
    "text": "2.1 SQL通用语法\nSQL语句可以单行或多行书写 以分号结尾\nSQL语句可以使用空格/缩进来增强语句的可读性\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写\n● 注释\n\n单行注释 ：– 注释内容 或#注释内容（MySQL独有）\n多行注释 ：/* */"
  },
  {
    "objectID": "SQL学习.html#sql分类",
    "href": "SQL学习.html#sql分类",
    "title": "2  SQL学习",
    "section": "2.2 SQL分类",
    "text": "2.2 SQL分类\n● SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。\n\n2.2.1 DDL 数据定义语句\n\n2.2.1.1 库操作\n● 查询\n1)查询所有数据库\n(SHOW)SHOW DATABASES;\n2)查询当前数据库\n(SELECT)SELECT DATABASE();\n● 创建(CREATE)\nCREATE DATABASE[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集][COLLATE 排序规则];\n● 删除(DROP)\nDROP DATABASES[IF EXISTS] 数据库名;\n● 使用(USE)/切换访问的数据库/\nUSE数据库名；\nDDL 数据定义语句\n\n\n2.2.1.2 表操作\n● 查询\n1）查询当前数据所有表\nSHOW TABLES;\n2）查询表结构\nDESC 表名;\n3）查询指定表的建表语句\nSHOW CREATE TABLE 表名;\n● 创建(CREATE)\nCREATE TABLE 表名{\n\n字段1 字段1类型[COMMENT 字段1注释],\n\n字段2 字段2类型[COMMENT 字段2注释],\n\n字段3 字段3类型[COMMENT 字段3注释]\n\n}[COMMENT 表注释];\n● 修改(ALTER)\n\n添加字段(ADD)\n\nALTER TABLE 表名 ADD 字段名 类型(长度)[comment 注释][约束];\n\n修改数据类型(MODIFY)\n\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n\n修改字段名和字段类型(CHANGE)\n\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度)[COMMENT 注释] [约束];\n\n删除字段（DROP）\n\nALTER TABLE 表名 DROP 字段名;#删除列\n\n修改表名\n\nALTER TABLE 表名 RENAME TO 新表名;\n● 删除\n\n删除表\n\nDROP TABLE [IF EXISTS]表名;\n\n删除指定表，并重新创建该表(该表的数据会被删除，以该名表被重新创建)\n\nTRUNCATE TABLE 表名;\n\n\n2.2.1.3 DML 数据操作语句\n\n2.2.1.3.1 ● 添加数据（INSERT）\n\n给指定字段名添加数据\n\nINSERT INTO 表名  (字段名1，字段名2， . . .)VALUES(值1，值2， . . .);\n\n给全部字段名添加数据\n\nINSERT INTO 表名 VALUES(值1，值2， . . .);\n\n批量添加数据\n\n/批量插入数据 用逗号隔开/\nINSERT INTO 表名(字段名1，字段名2， . . .)VALUES(值1，值2， . . .),(值1，值2， . . .),(值 1，值2， . . .);\n\nINSERT INTO 表名 VALUES (值1，值2， . . .)， (值1，值2， . . . .)， (值1，值2， . . . .);\n注意：\n1）插入数据时，指定的字段顺序需要与值的顺序是一致的\n2）字符串和日期类型应该包含的在引号中\n3）插入的数据大小，应该在字段的规定范围内\n\n\n2.2.1.3.2 ● 修改数据（UPDATE）\nUPDATE 表名 SET 字段名1=值1，字段名2=值2， . . .[WHERE 条件];\n\n\n2.2.1.3.3 ● 删除（DELETE）\nDELETE FROM 表名[WHERE 条件];\n\n\n\n2.2.1.4 DQL 数据查询语句\n\n2.2.1.4.1 基本查询\n\n查询多个字段\n\nSELECT 字段1,字段2，字段3 . . .FROM 表名;\n\nSELECT *FROM 表名(全部字段)#返回查询列表中所有数据\n\n设置别名（AS）\n\nSELECT 字段1[AS 别名1],字段2[AS 别名2]. . .FROM表名;#别名要用单引号 AS可以省略\n\n去除重复纪录(DISTINCT)\n\nSELECT DISTINCT 字段列表 FROM 表名;#将该列的重复的元素去除（去重）\n\n\n2.2.1.4.2 2.条件查询\n\n语法(WHERE)\n\nSELECT 字段列表 FROM WHERE 条件列表; # where相当于java中if语句 后接条件语句 字段列表 =*(所有列)\n\n条件\n\n​ ● 比较运算符\n\n\n\n\n\n\n\n比较运算符\n功能\n\n\n\n\n&gt;\n大于\n\n\n&gt;=\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;=\n小于等于\n\n\n=\n等于\n\n\n&lt;&gt;或！ =\n不等于\n\n\nBETWEEN…AND\n在某个范围之内（含最小、最大值）\n\n\nIN(…)\n在in之后的列表中的值，多选一\n\n\nLIKE 占位符\n模糊匹配 ( _ 匹配单个字符, % 匹配任意个字符 )\n\n\nIS NULL\n是NULL\n\n\n\n​ ● 逻辑运算符\n\n\n\n逻辑运算符\n功能\n\n\n\n\nAND或&&\n并且(多个条件同时成立)\n\n\nOR或||\n或者(多个条件任意一个成立)\n\n\nNOT或！\n非，不是\n\n\n\n​ ● 聚合函数\n\n介绍\n\n将一列数据作为一个整体\n\n常见聚合函数\n\n\n\n\n函数\n功能\n\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n\nSELECT 聚合函数 from 表名;\n\nSELECT COUNT(*)FROM EMP;\n\nSELECT COUNT(ID)FROM EMP;\n\n#聚合函数传进去的是字段\n注意:null值不参与聚合函数的运算\n\n\n2.2.1.4.3 3.分组查询(GROUP BY)\n\n语法\n\nSELECT 字段列表 FROM 表名[WHERE 条件]GROUP BY 分组字段名[HAVING 分组后过滤条件];\n\nSELECT gender,count(*)from emp GROUP BY gender;\n\n#查询效果是 根据性别分组 统计男女的数量\n\nSELECT gender,AVG(age)FROM emp GROUP BY gender;\n\n#查询效果是 根据性别分组 统计男女的平均年龄\n\nSELECT address,COUNT(*)FROM emp WHERE age&lt;xxx GROUP BY address;\n\n#查询效果是 根据地址分组 统计年龄小于xxx的人数\n\nSELECT address,COUNT(*) address_count FROM emp WHERE age&lt;xxx GROUP BY address HAVING address_count&gt;X;\n\n#上面一条语句的基础上再次筛选having\n\nHAING 和WHERE区别\n\n执行时机不同:\nwhere是分组之前进行过滤，不满足where条件不进行分组；而having是 分组之后对结果进行过滤\n判断条件不同:\nwhere不能对聚合函数进行判断 而having可以。\n\n注意\n\n执行顺序:where-&gt;聚合函数-&gt;having\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义(意思是分组字段和查询字段是相同的)\n\n\n2.2.1.4.4 4.排序查询(ORDER BY)\n\n语法\n\n#支持多字段排序\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方1,字段2 排序方式2 SELECT * FROM emp ORDER BY age desc;#降序\n\nSELECT * FROM emp ORDER BY age asc;#升序\n\nSELECT * FROM emp ORDER BY age asc,entrydate desc;\n\n排序方式\n\nASC：升序（默认值）\nDESC：降序\n注意:如果是多字段查询时，当第一个字段值相同时，才会根据第二个字段进行排序\n\n\n2.2.1.4.5 5.分页查询(LIMIT)\n\n语法\n\nSELECT 字段列表 FROM LIMIT 起始索引 ,查询记录数;#两个参数\n注意\n1）起始索引是从0开始，起始索引 =（查询页码-1）*每页显示记录数\n2）分页查询是数据库的方言，不同的数据库有不同的实现， Mysql是LIMIT\n3）如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10"
  },
  {
    "objectID": "SQL学习.html#函数",
    "href": "SQL学习.html#函数",
    "title": "2  SQL学习",
    "section": "2.3 函数",
    "text": "2.3 函数\n\n2.3.1 字符串函数\n​ ● 常用函数\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\nCONCAT(S1,S2,…Sn)\n字符串拼接,将s1,s2,..sn拼接成一个字符串\n\n\nLOWER(str)\n将字符串str全部转成小写\n\n\nUPPER(str)\n将字符串str全部转成大写\n\n\nLPAD(str,n,pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n\n\nRPAD(str,n,pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str,start,len)\n返回从字符串str从start位置起len个长度的字符串SELECT 函数(参数);\n\n\n\n\n\n2.3.2 2. 数值函数\n​ ● 常用函数\n\n\n\n函数\n功能\n\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x,y)\n返回x/y的模\n\n\nRAND()\n返回0~1的随机数\n\n\nROUND(x,y)\n求参数x的四舍五入的值，保留y位小数\n\n\n\n\n\n2.3.3 3. 日期函数\n​ ● 常用函数\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n返回当前指定date的年份\n\n\nMONTH(date)\n返回当前指定date的月份\n\n\nDAY(date)\n返回当前指定date的日期\n\n\nDATE_ADD(date,INTERVAL_EXPR type)\n返回一个日期/时间加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1 ，date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n\n举例：\nSELECT date_add(now(),INTERVAL 70 YEAR);\n\n#查询员工的入职天数\n\nSELECT name,diff(now(),entrydate) as entrydayscount FROM emp Group By entrydayscount SELECT name,DATEDIFF(NOW(),'2000-11-12 ')FROM emp\n\n\n2.3.4 4. 流程函数\n​ ● 常见函数\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\nIF(Value ，t ，f)\n如果value为true，则返回t，否则返回f\n\n\nIFNULL(Value1,Value2)\n如果Value1不为空(空=null)，则返回value1，否则返回value2\n\n\nCASE WHEN[val1]THEN[res1]…ELSE[default]END\n如果val1为true，返回res1，否则返回default默认值\n\n\nCASE [expr]WHEN[val]THEN[res1]…ELSE[default]END\n如果expr(表达式)的值等于val1，返回res1 ，…否则返回default默认值\n\n\n\n举例：\nSELECT name,(case workaddress when '北京 'then'一线城市 'when '上海 'then'一线城 市 'else'二线城市 'end) as '工作地址 '\n\nSELECT id,name,(case when math&gt;=85 then '优秀 ' when math&gt;=60 then '及格 'else '不 及格 'end)as '数学 '),\n\n(case when English&gt;=85 then '优秀 ' when English&gt;=60 then '及格 'else '不及格 'end)as '英语 '),\n\n(case when Chinese&gt;=85 then '优秀 ' when Chinese&gt;=60 then '及格 'else '不及格 'end)as '语文 ')\n\nFROM score;"
  },
  {
    "objectID": "SQL学习.html#约束",
    "href": "SQL学习.html#约束",
    "title": "2  SQL学习",
    "section": "2.4 约束",
    "text": "2.4 约束\n\n2.4.1 概述和分类\n\n概念\n\n约束是作用表中字段上的规则，用于限制存储在表中的数据\n\n作用\n\n保证数据库中数据的正确性、有效性和完整性\n\n分类\n\n\n\n\n\n\n\n\n约束\n描述\n关键字\n\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一 ，不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束\n保证字段值满足某一个条件(逻辑表达式+比较运算符)\nCHECK\n\n\n外键约束\n用来让两张表的数据中之间建立连接，保证数据的一致性和完整\nFOREIGN KEY\n\n\n\n\n\n注意:约束是作用在表中字段上的，可以在创建表/修改表的时候添加约束\n\n\n2.4.2 2. 案例展示\ncreate table user(\n\nid int primary key auto_increment comment '主键 ',\n\nname varchar(10) not null comment '名字 ',\n\nage int check ( age&gt;0&&age&lt;120 ) comment '年龄 ',  # mysql 版本要在8 .0才支持该语句 \n\nstatus char(1) default '1 'comment '状态 ',\n\ngander char(1) comment'性别 '\n\n)comment '用户表 ';\n\n\n2.4.3 3. 外键约束\n3. 1 语法\n添加外键:保证数据的完整性和一致性\n#建表前添加外键\n\nCREATE TABLE 表名{\n\n     字段名 数据类型 ,\n\n     ...\n\n     [CONSTRAINT][外键名称]FOREIGN KEY(外键字段名)REFERENCES 主表（主表列名） };\n\n#建表后进行添加外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表(主表列 名);#表名连接主表\n\nALTER TABLE 表名 ADD CONSTRAINT FK_表名_外键字段名 FOREIGN KEY (外键字段名)REFERENCES 主(父)表(主表列名);\n删除外键\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n删除/更新行为(DELETE/UPDATE)\n\n\n\n\n\n\n\n行为\n说明\n\n\n\n\nNO ACTION\n当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则不允许删除/更 新。\n\n\nRESTRICT\n同上\n\n\nCASCADE\n当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键 在字表中的记录\n\n\nSET NULL\n当父表中删除/更新对应纪录时，首先检查该记录是否有对应外键，如果有则设置字表中该外 键值为null\n\n\nSET DEFAULT\n父表有变更时，字表将外键列设置成一个默认值(Innodb不支持)\n\n\n\n语法：\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段)References 主表名(字表字 段名) ON UPDATE CASCADE ON DELETE CASCADE;"
  },
  {
    "objectID": "SQL学习.html#多表查询",
    "href": "SQL学习.html#多表查询",
    "title": "2  SQL学习",
    "section": "2.5 多表查询",
    "text": "2.5 多表查询\n\n2.5.1 多表关系\n概述:\n由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本分为三种\n\n2.5.1.1 ● 一对多(多对一)\n案例:部门与员工的关系\n关系:一个部门对应多个员工， 一个员工只能对应一个部门\n实现:在多的一方建立外键，指向一的一方的主键(员工表为多表，部门表就为一表)\n\n\n2.5.1.2 ● 多对多\n案例:学生和课程的关系\n关系:一个雪上可以选修多门课程， 一门课程也可以供多个学生选择\n实现:建立第三张中间表，中间表至少包含两个外键，分别关联两方主键(primary key)\n\n\n2.5.1.3 ● 一对一\n案例:用户与用户详情的关系\n关系:一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中， 其他详情字段放在另一张 表中，以提升操作效率\n实现:在任意的一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\n\n\n\n2.5.2 2.多表查询\n​ ● 概述: 指从多张表中查询数据\n笛卡尔积:笛卡尔乘积是指在数学中个，两个集合A集合和B集合的所有组合情况。(多表查询时，需要消除无效的笛卡尔积（连接条件） )\n#多表查询\n\nSELECT * FROM 父表 ,外表;\n\n2.5.2.1 ● 多表查询分类\n​ 连接查询\n\n内连接\n\n​ 相当于查询A、B交集部分数据\n\n外连接\n\n​ •左外连接\n​ •右外连接\n\n自连接\n\n​ 当前表与自身的连接查询，自连接必须使用表别名\n\n联合查询\n\n​ •子查询\n\n\n\n2.5.3 3.连接查询\n\n2.5.3.1 3.1 内连接\n​ ● 隐式内连接\nSELECT 字段列表 FROM 表1，表2 WHERE 条件 . . .;\n\n#例子 emp员工表 dept部门表\n\nSELECT emp.name,dept.name FROM emp,dept WHERE emp.dept_id=dept.id;\n​ ● 显式内连接\nSELECT 字段列表 FROM 表1,[INNER] JOIN 表2 ON 连接条件;\n\n#例子\n\nSELECT e.name,d.name FROM emp e INNER JOIN dept d ON e.dept_id=d.id;\n\n\n2.5.3.2 3.2 外连接\n​ ● 左外连接(LEFT JOIN)\nSELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 #字段列表根据需求可进行优化 因为按照sql语句的执行属性可知select是在后面执行\n相当于查询表1(左表)的所有数据和包含表1和表2交集部分的数据\n​ ● 右外连接(RIGHT JOIN)\nSELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件\n相当于查询表2(右表)的所有数据和包含表1和表2交集部分的数据\n\n\n2.5.3.3 3.3 自连接\n​ ● 语法\n# 把一张表看做成两张表 通过唯一 的id做为自连接的条件 managerid=id\n\n# 自连接必须给表名取别名！ ！ ！\n\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 . . .;\n\n# 举例：\n\nSELECT a.name,b.name FROM emp a JOIN emp b ON a.managerid=b.id;\n\n\n2.5.3.4 3.4 联合查询\n​ ● 定义\n对于联合查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n​ ● 关键词\n# 作为单独一句 在两个sql语句查询中间\n\nUNION #将查询的结果合并时 ，进行去重\n\nUNION ALL #直接将查询的结果进行合并\n注意\n\n对于联合查询多表查询的；列数必须保持一致，字段类型也必须保持一致\nunion all 会将全部数据直接合并在一起， union 会对合并之后的数据去重\n\n\n\n\n2.5.4 4.子查询\n\n2.5.4.1 4.1 概述\n​ ● 概念:SQL语句中嵌套SELECT语句，成为嵌套语句，又称子查询\nSELECT * FROM t1 WHERE column1=(SELECT column1 FROM t2);\n#子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个\n​ ● 查询结果分类\n\n标量子查询(子表查询结果为单个值)\n列子查询（子查询结果为一列）\n行子查询（子查询结果为一行）\n表子查询（子查询结果为多行多列）\n\n​ ● 根据子查询位置\n\nWHERE之后\nFROM之后\nSELECT之后\n\n\n\n2.5.4.2 4.2 查询结果分类\n\n2.5.4.2.1 ● 标量子查询\n\n定义: 子查询返回的结果是单个值(数字，字符串，日期等)，最简单的形式，这种子查询称为标量子查询\n常用操作符:= 、&lt;&gt;、&gt; 、&gt;=、 &lt; 、&lt;=\n案例展示\n\n# emp员工信息表\n\n# dept部门表\n\n# 要求查询具体部门对应的员工信息 前提员工表和部门表是已经建立了连接(foreign key) # 分析 首先得知道具体部门的部门ID 进而查询该部门的员工信息\n\n# 可以两种sql写法\n\nSELECT id FROM dept WHERE name='具体的部门名 ';\n\nSELECT * FROM emp WHERE dept_id =\"上条语句的结果\";\n\n# 所以可以整合成一句 形成嵌套\n\nSELECT * FROM emp WHERE dept_id=(SELECT id FROM dept WHERE name='具体的部门名 ');\n\n\n2.5.4.2.2 ● 列子查询\n\n子查询返回的结果是一列(可以是多行 )，这种子查询为列子查询\n常用操作符:IN、NOT IN、ANY、SOME、ALL\n\n\n\n\n操作符\n描述\n\n\n\n\nIN\n在指定的集合范围之内，多选一\n\n\nNOT IN\n不在指定的集合范围之内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n\n\n案例演示\n\n#查询比财务部所有人工资都高的员工信息\n\n#将获取信息的问题拆分化 在通过嵌套进行优化 形成一句sql语句\n\n# 获取财务部的部门id\n\nSELECT id FROM dept WHERE name ='财务部';\n\n# 获取财务中所有人的工资\n\nSELECT salary FROM emp WHERE id=(SELECT id FROM dept WHERE name ='财务部');\n\n# 获取比财务部所有员工工资都高的员工信息\n\nSELECT * FROM emp WHERE salary&gt;ALL SELECT salary FROM emp WHERE id=(SELECT id FROM dept WHERE name ='财务部');\n\n\n2.5.4.2.3 ● 行子查询\n1 . 子查询返回的结果是一行(可以是多列)，这种子查询为行子查询\n2 . 常用操作符:IN、 NOT IN、ANY、 SOME、ALL(同上)\n3 . 案例演示\n# 查询张无忌的薪资及直属领导相同的员工信息\n\nSELECT salary managerid FROM emp WHERE name=\"张无忌 \";\n\nSELECT * FROM emp WHERE (salary,managerid)=(SELECT salary managerid FROM emp WHERE name=\"张无忌 \");\n\n#返回的结果是一行多列 对应的是salary和managerID\n\n\n2.5.4.2.4 ● 表子查询\n\n表子查询返回的结果是多行多列，这种子查询为列表查询\n常用操作符: IN\n案例演示\n\n#查询入职日期是 “2006-01-01”之后的员工信息和部门信息\n\nSELECT * FROM emp where entrydate&gt;'2006-01-01';\n\nSELECT e.*,d.* FROM (SELECT * FROM emp where entrydate&gt;'2006-01-01 ') e LEFT JOIN dept d on e.dept_id=d.id;"
  }
]