[
  {
    "objectID": "index.html#文档目录",
    "href": "index.html#文档目录",
    "title": "Python新手文档",
    "section": "文档目录",
    "text": "文档目录\n\nPython简介\n\nPython的特点和应用领域\n安装Python和开发环境\nPython基础知识\n\n\n\n数据类型和变量\n\n运算符和表达式\n条件语句和循环\n函数和模块\n数据处理与分析入门\n\n\n\nPandas 基本操作\n\nPandas库介绍和安装\nPandas处理什么样的数据\n读取和写入\n选取和筛选\n增删和排序\n分组和聚合\n处理时间序列数据\n处理文本数据\n数据可视化\n\n\n\nPandas 实际应用案例\n\n从实际数据集中读取数据\n数据清洗和预处理\nPlotly可视化展示\nDash应用程序展示\n扩展学习资源\n\n\n\n推荐的Pandas学习资源\n\npandas官方文档(自译版)\nPandas对比SQL\nPlotly可视化官方文档\nW3schools for Pandas\n JackB站超级多的视频"
  },
  {
    "objectID": "index.html#结语",
    "href": "index.html#结语",
    "title": "Python新手文档",
    "section": "结语",
    "text": "结语\n通过本文的学习，你将建立起对Python编程语言的基本理解，掌握Pandas库进行数据处理和分析的技能。无论你是想进入数据科学领域、进行数据挖掘，还是对数据处理和分析有兴趣，Python和Pandas都是你的理想选择。开始你的编程之旅吧，让Python和Pandas帮助你实现数据的无限可能！\n\n\n\n\n\n\nNote\n\n\n\n本文档主要针对编程小白，将以简洁易懂的语言和实例进行解释。每个主题都会提供充足的示例代码和实践案例，以便读者能够实际运用所学知识。在学习过程中，不断实践和探索将是提高编程能力的关键，鼓励读者积极动手并勇于尝试。"
  },
  {
    "objectID": "intro.html#主要特点",
    "href": "intro.html#主要特点",
    "title": "Python简介",
    "section": "主要特点",
    "text": "主要特点\nPython是一种高级编程语言，以其简洁、易读、易学和灵活性而受到广泛欢迎。以下是Python的一些主要特点：\n\n简洁易读：Python采用清晰简洁的语法，使得代码易于阅读和理解。它使用缩进来表示代码块，而不是使用大括号，这使得代码更加易读。\n易学性：Python的语法简单明了，相对于其他编程语言来说，学习曲线较低。这使得初学者能够快速入门并开始编写实用的程序。\n跨平台性：Python可以在多个操作系统上运行，包括Windows、macOS和各种Linux发行版。这意味着开发人员可以在不同的平台上编写一次代码，并在不同的环境中运行。\n大量的库和框架：Python拥有庞大且活跃的社区，为各种用途提供了大量的库和框架。这些库和框架使得开发人员能够快速构建各种应用，例如Web应用、科学计算、数据分析和人工智能等。\n可扩展性：Python可以与其他语言（如C/C++和Java）轻松集成，这使得开发人员能够使用现有的代码库和资源，以提高应用程序的性能和功能。"
  },
  {
    "objectID": "intro.html#应用领域",
    "href": "intro.html#应用领域",
    "title": "Python简介",
    "section": "应用领域",
    "text": "应用领域\nPython具有广泛的应用领域，从Web开发到科学计算和人工智能等各种领域都能发挥其优势。它的简洁性和强大的库生态系统使得开发人员能够快速构建各种类型的应用程序。\n\nWeb开发：Python的Web框架（如Django和Flask）使得构建功能强大的Web应用程序变得简单。Python还可以用于服务器端编程、网页爬虫和API开发等。\n数据科学和机器学习：Python在数据科学和机器学习领域非常受欢迎。它提供了许多用于数据处理、数据可视化和机器学习算法的库，如NumPy、Pandas、Matplotlib、Scikit-learn和TensorFlow等。\n科学计算：Python在科学计算领域也得到广泛应用。科学计算库如NumPy和SciPy提供了许多数值计算、优化和统计分析的功能，适用于物理学、数学、生物学等领域。\n自动化和脚本编写：Python的简洁性和易用性使得它成为自动化任务和脚本编写的理想选择。可以使用Python编写脚本来自动执行重复性的任务、处理文件、操作系统和网络等。\n游戏开发：Python也可以用于游戏开发。有一些专门的库和框架，如Pygame，使得使用Python编写2D游戏变得相对容易。"
  },
  {
    "objectID": "周一环境搭建.html#anaconda环境安装强烈推荐",
    "href": "周一环境搭建.html#anaconda环境安装强烈推荐",
    "title": "Python 环境搭建",
    "section": "Anaconda环境安装（强烈推荐）",
    "text": "Anaconda环境安装（强烈推荐）\n强烈推荐小白使用Anaconda平台学习Python。\nAnaconda提供了简化环境配置、跨平台支持、库和工具管理以及丰富的科学计算库等优势，使得小白学习Python更加便捷和高效。它是一个功能强大且易于使用的平台，可以帮助您快速入门Python编程并进行数据处理和分析。\n官方免费提供在线编辑器-jupyterlab 无需手动安装环境，即可直接上手编写代码。"
  },
  {
    "objectID": "周一环境搭建.html#python包-手动安装",
    "href": "周一环境搭建.html#python包-手动安装",
    "title": "Python 环境搭建",
    "section": "Python包 手动安装",
    "text": "Python包 手动安装\n你可以访问Python官网下载并安装适合你操作系统的Python版本。最好选择stable稳定版\n\n\n\n\n\n设置环境变量\n程序和可执行文件可以在许多目录，而这些路径很可能不在操作系统提供可执行文件的搜索路径中\nPATH (路径)存储在环境变量中，这是由操作系统维护的一个命名的字符串,这些变量包含可用的命令行解释器和其他程序的信息\nUnix 或 Windows 中路径变量为 PATH ( UNIX区分大小写，Windows 不区分大小写 )\nMac OS 中，如果安装程序过程中改变了 python 的安装路径，如果想要在其它目录引用 Python，则必须在 PATH 中添加 Python 目录\n\n\n在 Windows 设置环境变量\nWindows 系统中，把 Python 安装目录添加到 PATH 环境变量中流程如下\n\n右键点击 计算机，然后点击 属性\n然后点击”高级系统设置”\n选择 系统变量 窗口下面的 Path ,双击即可！\n然后在 Path 行，添加 python 安装路径即可，即在最后面，添加 ;C:\\Python\n设置成功以后，在 cmd 命令行，输入命令 python，就可以有相关显示\n\n\n\n\n\n\n\n\nNote\n\n\n\nWindows 下的 Python 一般安装在 C:\\Python目录。\n\n\n安装完成后，打开命令行（Windows）或终端（macOS/Linux），输入以下命令，确认Python已成功安装：\npython --version\n输入python并按回车键。你将看到一条欢迎消息，其末尾\n为如下提示符：\n\\&gt;&gt;&gt;\n如果情况确实如此，就可以输入Python命令了。\n请尝试像下面这样做，以核实它是否管用：\n\\&gt;&gt;&gt; print(\"Hello, world!\")\n等你按下回车键后，将出现如下输出：\nHello, world!\n\\&gt;&gt;&gt;\n如果你熟悉其他计算机语言，可能习惯了在每行末尾都加上分号。在Python中无需这样做，因为在Python中，一行就是一行。接下来，我们将学习如何编写和运行Python程序。"
  },
  {
    "objectID": "周一环境搭建.html#visual-stuido-code安装",
    "href": "周一环境搭建.html#visual-stuido-code安装",
    "title": "Python 环境搭建",
    "section": "Visual Stuido Code安装",
    "text": "Visual Stuido Code安装\nVisual Studio Code是一个轻量级但功能强大的源代码编辑器，在你的桌面上运行，可用于Windows、macOS和Linux。它内置了对JavaScript、TypeScript和Node.js的支持，并有一个丰富的生态系统，可用于其他语言和运行系统（如C++、C#、Java、Python、PHP、Go、.NET）的扩展。\n\n\n\n官方有非常丰富的文档提供学习参考，第一步可以从入门视频开始\n\n\n\n\n\n\nNote\n\n\n\n在vscode中，创建新的main.py文件后，可使用快捷键ctl+`打开终端。 输入python main.py运行 python代码"
  },
  {
    "objectID": "周二基础语法.html#如何使用python",
    "href": "周二基础语法.html#如何使用python",
    "title": "1  Python基础语法",
    "section": "如何使用Python",
    "text": "如何使用Python\n\n运行python文件\nPython文件的后缀为 .py\n\n\n\n在代码编辑器中输入python指令\n比如在jupyterlab，在终端或者vscode中输入代码\n如图，Shift + Enter执行代码块\n\n\n\n\n\n\n\nNote\n\n\n\n在终端中，输入python进入python解释器后，即可运行python代码\n\n\n\n\n\n我们可以写一个简单的表达式，在编程中，表达式是一段产生值的代码，例如\n\n\nCode\n2023 + 4090\n\n\n6113\n\n\n另外一种表达式，让我们看看是否 9 大于 1？\n\n\nCode\n9 &gt; 1\n\n\nTrue\n\n\n因为这个逻辑是成立的，所以我们会得到 True，反之则会得到False。这也叫做布尔值，这会在之后的数据类型中介绍。\n那写代码总少不了报错。假如我的是空值呢？\n\n\nCode\n9 &gt; \n\n\nSyntaxError: invalid syntax (1639543893.py, line 1)\n\n\n我们会得到一个语法错误，其中SyntaxError在编程中，意味着语法，就像平常的语言中的语法一样，你不说清楚是什么的话，那是很难理解的。这在编程里也十分讲究。"
  },
  {
    "objectID": "周二基础语法.html#变量赋值",
    "href": "周二基础语法.html#变量赋值",
    "title": "1  Python基础语法",
    "section": "变量赋值",
    "text": "变量赋值\n在Python中，变量用于存储和表示数据。变量赋值是将一个值与一个变量关联起来的过程。通过变量，我们可以在程序中存储和操作数据。\n\n变量的命名规则\n在Python中，变量的命名需要遵循以下规则：\n\n变量名只能包含字母（大小写敏感）、数字和下划线（_）。\n变量名不能以数字开头。\n变量名不能使用Python关键字和保留字，如if、for、while等。\n变量名应具有描述性，能够清晰地表示变量的含义。\n\n\n\n变量的赋值\n在Python中，使用等号（=）进行变量赋值操作。等号 ( = ) 运算符左边是一个变量名,等号 ( = ) 运算符右边是存储在变量中的值\n下面是一个例子，将数字5赋值给变量x：\n\n\nCode\nx = 5\n\n\n\n\n变量的使用\n一旦变量被赋值，我们可以在程序中使用它来表示和操作存储的值。\n下面是一个例子，使用变量x计算其平方并打印结果：\n\n\nCode\nx = 5\nsquare = x * x\nprint(square)\n\n\n25\n\n\n\n\n变量的重新赋值\n在程序中，我们可以多次为同一个变量赋值，新的赋值将覆盖之前的值。\n下面是一个例子，演示变量的重新赋值：\n\n\nCode\nx = 5\nprint(x)  # 输出：5\n\nx = 10\nprint(x)  # 输出：10\n\n\n题型一\n将字符串”Hello, Python!“赋值给变量message，然后打印出变量的值。\n\n\nCode\nmessage = \"Hello, Python!\"\nprint(message)\n\n\nHello, Python!"
  },
  {
    "objectID": "周二基础语法.html#注释",
    "href": "周二基础语法.html#注释",
    "title": "1  Python基础语法",
    "section": "注释",
    "text": "注释\n在Python中，注释用于对代码进行解释和说明，对于其他人（包括自己）来理解代码的作用和意图非常有帮助。注释是在代码中添加的文本，Python解释器会忽略它们。\n\n单行注释\n在Python中，使用#符号开始的文本被视为单行注释。在#后面的所有内容都被视为注释，不会被执行。\n下面是一个例子，演示如何使用单行注释：\n\n\nCode\n# 这是一个单行注释\nprint(\"Hello, World!\")  # 打印输出文本\n\n\nHello, World!\n\n\n上述代码中，第一行是一个注释，用于对代码的目的进行解释。第二行是打印输出语句，不受注释的影响。\n\n\n多行注释\n在Python中，使用三个引号（“““或’’’）包围的文本被视为多行注释。多行注释可以跨越多行，并且可以包含多个段落。\n下面是一个例子，演示如何使用多行注释：\n\n\nCode\n\"\"\"\n这是一个多行注释的示例。\n它可以跨越多行，并且可以包含多个段落。\n\n以下是代码的主要功能：\n- 输入用户的姓名\n- 打印欢迎消息和姓名\n\"\"\"\n\nname = input(\"请输入您的姓名：\")\nprint(\"欢迎，\" + name + \"!\")\n\n\n欢迎，jack!\n\n\n\n\n\n\n\n\nNote\n\n\n\n如果想一次性注释多行的话，鼠标选取后，按ctl+/进行注释"
  },
  {
    "objectID": "周二基础语法.html#行和缩进",
    "href": "周二基础语法.html#行和缩进",
    "title": "1  Python基础语法",
    "section": "行和缩进",
    "text": "行和缩进\n在Python中，行用于分隔不同的代码语句，而缩进用于表示代码块（例如条件语句、循环等）的范围。\n\n行\n每一行都包含一个完整的代码语句或表达式。下面是一个例子：\n\n\nCode\nprint(\"Hello, world!\")\n\n\nHello, world!\n\n\n上述代码中，print(“Hello, world!”)是一行代码，用于输出字符串”Hello, world!“。\n\n\n缩进\n在Python中，缩进通过空格或制表符来实现，用于表示代码块的开始和结束。通常使用4个空格作为标准缩进。\n\n\n\n\n\n\nWarning\n\n\n\n缩进造成的错误，应该名列 Python 错误榜第一\n\n\n下面是一个例子，演示如何使用缩进创建代码块：\n\n\nCode\n if x&gt;0:\n    print(\"x是正数\")\n    print(\"干得漂亮！\")\nelse:\n    print (\"x是负数\")\n    print (\"可惜哇嗷！\") \n\n\nx是正数\n干得漂亮！\n\n\n上述代码中，if语句和else语句是两个代码块，它们的范围由缩进表示。在if代码块中，两个print语句都会在条件满足时执行。在else代码块中，同样有两个print语句。（大家可以自己修改下x范围）\n\n\n\n\n\n\nNote\n\n\n\n养成良好编码习惯： 1. 保持一致的缩进：使用相同数量的空格或制表符进行缩进，并在整个代码中保持一致。这有助于提高代码的可读性； 2. 使用合适的缩进级别：根据代码逻辑嵌套关系，选择适当的缩进级别。通常建议每个缩进级别使用4个空格； 3. 使用注释：在关键地方添加注释，解释代码的目的和功能。注释可以提高代码的可读性和可维护性； 4. 注意行的长度：尽量将每行代码控制在适当的长度范围内，通常推荐不超过80个字符。可以使用换行符（）或括号来换行。\n\n\n\n\n多行语句\n\n使用反斜杠\n使用反斜杠（\\）将一行代码分成多行。下面是一个例子：\n\n\nCode\ntotal = 1 + \\\n        2 * \\\n        3\nprint(total)\n\n\n7\n\n\n上述代码中，total变量的值是1+2+3，通过使用反斜杠在多行中编写，使代码更易读。\n\n\n使用括号\n另一种方式是使用括号（圆括号、方括号、花括号）来隔行编写多行语句。下面是一个例子：\n\n\nCode\ntotal = (1 +\n         2 *\n         3)\nprint(total)\n\n\n7"
  },
  {
    "objectID": "周三数据类型.html#数据类型",
    "href": "周三数据类型.html#数据类型",
    "title": "2  Python数据类型",
    "section": "数据类型",
    "text": "数据类型\n在Python中，有多种内置的数据类型，每种类型都用于存储不同类型的数据。了解和正确使用这些数据类型对于编写有效的Python代码非常重要。\nPython有以下基本数据类型：\n\n整数（int）：如1, 2, 3\n浮点数（float）：如1.5, 3.14\n字符串（str）：如”hello”, ‘world’\n布尔值（bool）：True, False\n\n\n数字类型\n数字类型用于表示数值数据，包括整数（int）和浮点数（float）。\n下面是一个例子，演示如何使用数字类型：\n\n\nCode\n# 整数类型\nnum1 = 10\nprint(num1) \n\n\n10\n\n\n\n\nCode\n# 浮点数类型\nnum2 = 3.14\nprint(num2)  \n\n\n3.14\n\n\n\n\n字符串类型\n字符串类型用于表示文本数据，使用引号（单引号或双引号）括起来。\n下面是一个例子，演示如何使用字符串类型：\n\n\nCode\nname = \"Jack Chen\"\nprint(name)  \n\n\nJack Chen\n\n\n\n\n布尔类型\n布尔类型用于表示真（True）和假（False）的值。\n下面是一个例子，演示如何使用布尔类型：\n\n\nCode\nis_active = True\nprint(is_active)  \n\n\nTrue\n\n\n\n\nCode\nis_student = False\nprint(is_student) \n\n\nFalse"
  },
  {
    "objectID": "周三数据类型.html#运算符",
    "href": "周三数据类型.html#运算符",
    "title": "2  Python数据类型",
    "section": "运算符",
    "text": "运算符\n当提到Python的运算符，可以包括算术运算符、赋值运算符、比较运算符、逻辑运算符和位运算符等。下面是一些常见的运算符示例及其解析：\n\n算术运算符\n比较常见的算术运算符，也就是加减乘除这些。\n\n\n\n运算符\n描述\n举例\n\n\n\n\nx+y\n加\n1+2=3\n\n\nx-y\n减\n6-5=1\n\n\nx*y\n乘\n2*3=6\n\n\nx/y\n除\n2/4=0.5\n\n\nx//y\n整除，取整数部分\n2//4=0\n\n\nx%y\n取余\n15%4=3\n\n\n**\n幂运算\n2**3=8 二的三次方\n\n\n\n\n\nCode\na = 10\nb = 3\n\n# 加法\nresult = a + b * (a // b) \nprint(result)  \n\n\n19\n\n\n\n\n赋值运算符\n在加减乘除的基础上直接进行赋值计算，不需要新的变量\n\n\n\n运算符\n描述\n\n\n\n\n=\n赋值\n\n\n+=\n加等,自增 number += 1 &lt;==&gt; number = number+1\n\n\n*=\n乘等\n\n\n%=\n余等\n\n\n-=\n减等，自检\n\n\n/=\n除等\n\n\n//=\n取整等\n\n\n**=\n幂等\n\n\n\n\n\nCode\na = 10\nb = 3\n\n# 加法赋值\na += b \nprint(a)  \n\n\n13\n\n\n\n\n比较运算符（控制结构判断）\n输出为布尔值\n\n\n\n运算符\n描述\n\n\n\n\n&lt;\n小于\n\n\n&lt;=\n小于等于\n\n\n&gt;\n大于\n\n\n&gt;=\n大于等于\n\n\n==\n等于\n\n\n!=\n不等于\n\n\nis\n判断两个标识符是不是引用自一个对象\n\n\nis not\n判断两个标识符是不是引用自不同对象\n\n\n\n\n\nCode\na = 10\nb = 3\n\n# 相等比较\nresult = a == b\nprint(result)  \n\n\nFalse\n\n\n\n\n逻辑运算符\n逻辑运算符用于在布尔表达式中组合和比较逻辑条件。Python中的逻辑运算符包括以下三种：and（与）、or（或）和not（非）。\n\n\n\n\n\n\n\n\n运算符\n描述\n备注\n\n\n\n\nx and y\nif x is false, then x,else y\nxy都为True,结果为True；否则为False\n\n\nx or y\nif x is false, then y，else x\nxy都为False,结果为False；否则为True\n\n\nnot x\nif x is false,then True，else False\nx为True时，值为False；x为False时，值为True\n\n\n\n\n逻辑 与（and）运算符：\n逻辑与运算符返回两个操作数都为True时的结果为True，否则返回False。\n\n\nCode\nx = True\ny = False\n\n# 与运算\nresult = x and y\nprint(result)\n\n\nFalse\n\n\n这里可能比较难理解，在上面的示例中，x的值为True，y的值为False。当使用逻辑与运算符（and）将x和y进行运算时，由于y为False，所以结果为False。如果x和y都为True，则结果为True。\n\n\n逻辑或（or）运算符\n逻辑或运算符返回两个操作数中至少一个为True时的结果为True，只有当两个操作数都为False时结果才为False。\n\n\nCode\na = True\nb = False\n\nresult = a or b\nprint(result)  \n\n\nTrue\n\n\n\n\n逻辑非（not）运算符\n逻辑非运算符将操作数的值取反，如果操作数为True，则结果为False；如果操作数为False，则结果为True。\n\n\nCode\na = True\n\nresult = not a\nprint(result) \n\n\nFalse"
  },
  {
    "objectID": "周三数据类型.html#数据结构",
    "href": "周三数据类型.html#数据结构",
    "title": "2  Python数据类型",
    "section": "数据结构",
    "text": "数据结构\nPython中有多种常用的数据结构，包括列表（List）、元组（Tuple）和字典（Dictionary）\n\n列表 List\nlist是Python中最常用的数据结构之一，用于存储一组有序的元素。列表中的元素可以是不同类型的对象，可以进行增删改查等操作。\n\n创建列表\n列表可以使用方括号[]来创建，其中每个元素用逗号分隔。例如：\n\n\nCode\n水果 = ['苹果', '菠萝', '榴莲']\nprint(水果)\n\n\n['苹果', '菠萝', '榴莲']\n\n\n\n\n访问列表元素\n列表中的元素可以通过索引访问，索引从0开始。例如，要访问列表中的第一个元素，可以使用fruits[0]。可以使用负数索引从列表末尾开始访问元素。例如，fruits[-1]表示访问最后一个元素。\n\n\nCode\n# python中顺序需要向前递减一位，所以索引 0 代表第一个\nprint(水果[0]) \n\n\n苹果\n\n\n\n\n修改列表元素\n列表中的元素可以通过索引进行修改。可以使用赋值语句将新的值赋给列表中的特定位置。\n\n\nCode\n水果[1] = '香蕉'\nprint(水果)\n\n\n['苹果', '香蕉', '榴莲']\n\n\n\n\n添加和删除元素\n添加元素：可以使用append()方法将元素添加到列表的末尾。\n\n\nCode\n水果.append('我爱香蕉')\nprint(水果)\n\n\n['苹果', '香蕉', '榴莲', '我爱香蕉']\n\n\n删除元素：可以使用remove()方法删除列表中的特定元素。\n\n\nCode\n水果.remove('香蕉')\nprint(水果) \n\n\n['苹果', '榴莲', '我爱香蕉']\n\n\n\n\n\n元组（Tuple）\n元组与列表类似，也是用于存储一组有序的元素。但是，元组一旦创建，其元素不可更改，即元组是不可变的。\n\n\nCode\n# 创建一个元组\nperson = ('John', 25, 'USA')\n\n# 访问元组元素\nprint(person[0])  \n\n\n\nJohn\n\n\n\n\nCode\n# 尝试修改元组元素（会抛出异常）\nperson[1] = 30\n\n\nTypeError: 'tuple' object does not support item assignment\n\n\n在上面的示例中，我们创建了一个包含个人信息的元组。通过索引访问元组中的元素，但是尝试修改元组元素会引发TypeError异常，因为元组是不可变的。\n\n元组的应用场景\n\n用于存储不可变的数据集合，如坐标点、日期等。\n作为字典（Dictionary）的键值，因为字典要求键是不可变的。\n用于函数返回多个值，函数可以返回元组，调用函数时可以解包元组并获得多个返回值。\n\n元组在需要存储不可变数据集合或对数据进行保护时非常有用。由于元组是不可变的，因此在某些情况下比列表更安全和高效。\n\n\n元组解包\n可以将元组的元素解包到多个变量中，从而快速访问元组的各个元素。\n\n\nCode\n# person元组中，有三个数值，所以必须设`x,y,z`\nx, y, z = person\nprint(x) \n\n\nJohn\n\n\n\n\n\n字典（Dictionary）\n字典是Python中一种常用的数据结构，又称 哈希表，它以键-值（key-value）对的形式存储数据。以下是对字典的详细说明：\n\n创建字典\n字典使用花括号{}来创建，每个键-值对之间使用冒号:分隔，不同键-值对之间使用逗号,分隔。例如：\n\n\nCode\nstudent = {'姓名': '帅气的Jack', '年龄': 24, '成绩': 'SSS'}\nstudent\n\n\n{'姓名': '帅气的Jack', '年龄': 24, '成绩': 'SSS'}\n\n\n\n\n访问字典元素\n可以通过键来访问字典中的值。使用键来提取相应的值，使用方括号[]操作符，将键作为索引传递给字典。例如：\n\n\nCode\nprint(student['姓名'])\n\n\n帅气的Jack\n\n\n\n\n修改字典元素\n字典中的值是可以修改的。可以通过指定键来更新字典中的值。例如：\n\n\nCode\n#如果需要指定中文，最好加上引号''\nstudent['成绩'] = '刚好及格'\nprint(student)\n\n\n{'姓名': '帅气的Jack', '年龄': 24, '成绩': '刚好及格'}\n\n\n\n\n关于字典的相关操作\n要确定字典有多少项，可以使用len()函数\n\n\nCode\nprint(len(student))\n\n\n3\n\n\n\n\nCode\ndel student['姓名']  # 删除键是'姓名'的条目\nstudent.clear()      # 清空字典所有条目\ndel student          # 删除字典"
  },
  {
    "objectID": "条件语句和循环语句 .html",
    "href": "条件语句和循环语句 .html",
    "title": "3  条件语句的学习",
    "section": "",
    "text": "在本节课程中，我们将学习条件语句的基本结构、逻辑判断以及如何构建复杂的条件表达式。同时，我们还会练习编写带有条件判断的程序，让你能够根据条件执行不同的代码块。\n\n条件语句的基本结构 条件语句允许我们根据不同的条件来执行不同的代码块。在Python中，条件语句使用if和else关键字构建。基本结构如下：\n\n\nif 条件:\n     #条件为True时执行的代码块\nelse:\n     #条件为False时执行的代码块\n\n\n逻辑判断 条件语句的逻辑判断基于比较运算符，用于比较两个值的相等性、大小关系等。常见的比较运算符包括：\n\n\n相等性判断：==（等于）、!=（不等于）\n大小关系判断：&gt;（大于）、&lt;（小于）、&gt;=（大于等于）、&lt;=（小于等于）\n\n举例：\n\nbalance = 1000\nif balance == 0:\n    print(\"账户余额为零\")\nelse:\n    print(\"账户余额不为零\")\n\n账户余额不为零\n\n\n\n复杂的条件表达式 我们可以使用比较运算符和逻辑运算符构建复杂的条件表达式，以实现更灵活的条件判断。常见的逻辑运算符包括：\n\n\nand（与）：当所有条件都为True时，结果为True\nor（或）：当至少一个条件为True时，结果为True\nnot（非）：取反操作，将True变为False，False变为True\n\n举例：\n\nincome = 50000\nif income &gt;= 50000 and income &lt;= 100000:\n    print(\"年收入在50,000到100,000之间\")\n\n年收入在50,000到100,000之间\n\n\n\n编写带有条件判断的程序 我们经常需要根据不同的条件执行不同的代码块。条件语句为我们提供了这样的能力。让我们通过一个实际的例子来练习。\n\n举例：\n\nnet_income = 5000\nif net_income &gt; 0 and net_income &lt;= 10000:\n    print(\"盈利一般\")\nelif net_income &gt; 10000 and net_income &lt;= 50000:\n    print(\"盈利良好\")\nelif net_income &gt; 50000:\n    print(\"盈利优秀\")\nelse:\n    print(\"亏损\")\n\n盈利一般\n\n\n\nrevenue = float(input(\"请输入公司的营业收入：\"))\n\nif revenue &gt; 1000000:\n    tax = revenue * 0.3\n    print(\"应缴纳的所得税为：\", tax)\nelse:\n    tax = revenue * 0.2\n    print(\"应缴纳的所得税为：\", tax)\n\n\n应缴纳的所得税为： 60000.0\n\n\n课后题：\n1、编写一个程序，接收用户输入的利润金额，并根据以下条件判断输出相应的税率和税款金额：\n如果利润小于等于100,000，税率为10% 如果利润大于100,000且小于等于500,000，税率为20% 如果利润大于500,000，税率为30%\n2、编写一个程序，接收用户输入的两个数值，并判断两个数值中的最大值，并打印出最大值。\n答案：\n课后题1：\n\nprofit = float(input(\"请输入利润金额：\"))\n\nif profit &lt;= 100000:\n    tax_rate = 0.1\nelif profit &lt;= 500000:\n    tax_rate = 0.2\nelse:\n    tax_rate = 0.3\n\ntax_amount = profit * tax_rate\nprint(\"税率：\", tax_rate)\nprint(\"税款金额：\", tax_amount)\n\n\n税率： 0.1\n税款金额： 5000.0\n\n\n课后题2：\n\nnum1 = float(input(\"请输入第一个数值：\"))\nnum2 = float(input(\"请输入第二个数值：\"))\n\nif num1 &gt; num2:\n    max_num = num1\nelse:\n    max_num = num2\n\nprint(\"最大值为：\", max_num)\n\n最大值为： 50.0\n\n\n\n循环语句的学习\n本节课程中，我们将探索循环语句的基本结构、控制条件和循环体的执行过程。同时，我们还会学习如何使用break语句和continue语句控制循环的执行流程。最后，我们将练习编写带有循环结构的程序，如遍历列表和计算累加和。\n\n基本结构 循环语句允许我们重复执行一段代码。Python中有两种常见的循环结构：while循环和for循环。\n\n\nwhile循环的基本结构如下：\n\n\nwhile 条件:\n    # 循环体代码块\n\nfor循环的基本结构如下：\n\nfor 变量 in 可迭代对象:\n    # 循环体代码块\n\n\n控制条件和执行过程 循环的执行依赖于控制条件。在每次循环迭代开始时，会检查控制条件的值。如果条件为True，则执行循环体代码块；否则，跳出循环。\n\n举例：\n\n使用while循环输出1到5的金融数据：\n\n\nprice = 100.0\nwhile price &lt;= 500.0:\n    print(\"股票价格:\", price)\n    price += 100.0\n\n股票价格: 100.0\n股票价格: 200.0\n股票价格: 300.0\n股票价格: 400.0\n股票价格: 500.0\n\n\n使用for循环遍历股票交易日的收盘价：\n\n  prices = [105.0, 102.5, 99.2, 101.8, 104.6]\n  for price in prices:\n      print(\"收盘价:\", price)\n\n\nbreak和continue语句 我们可以使用break语句提前终止循环的执行，跳出循环体。而continue语句则用于跳过当前迭代，继续执行下一次循环。\n\n举例：\n\n使用break语句在满足条件时终止循环：\n\n\nprice = 100.0\nwhile True:\n    print(\"股票价格:\", price)\n    price += 100.0\n    if price &gt; 500.0:\n        break\n\n股票价格: 100.0\n股票价格: 200.0\n股票价格: 300.0\n股票价格: 400.0\n股票价格: 500.0\n\n\n使用continue语句跳过某些迭代：\n\nprices = [105.0, 102.5, 99.2, 101.8, 104.6]\nfor price in prices:\n    if price &lt; 100.0:\n        continue\n    print(\"收盘价:\", price)\n\n收盘价: 105.0\n收盘价: 102.5\n收盘价: 101.8\n收盘价: 104.6\n\n\n\n编写带有循环结构的程序 通过练习编写带有循环结构的程序，我们可以进一步巩固循环语句的应用。\n\n课后题：\n​ 练习1：计算累积收益率 假设有一只股票，连续5个交易日的收盘价分别为[105.0, 102.5, 99.2, 101.8, 104.6]，编写一个程序计算这只股票的累积收益率，并将结果打印出来。\n练习2：遍历股票价格数据 给定上一题的股票价格列表prices，使用for循环遍历列表的元素，并打印出每个价格及其对应的交易日。\n\n#课后题答案1：\nprices = [105.0, 102.5, 99.2, 101.8, 104.6]\ncumulative_return = 1.0\nfor price in prices:\n    cumulative_return *= price / 100.0\nprint(\"累积收益率:\", (cumulative_return - 1.0) * 100, \"%\")\n\n累积收益率: 13.685296591999997 %\n\n\n\n#题目2：\nprices = [105.0, 102.5, 99.2, 101.8, 104.6]\nfor i, price in enumerate(prices, start=1):\n    print(\"第\", i, \"个交易日的价格:\", price)\n\n第 1 个交易日的价格: 105.0\n第 2 个交易日的价格: 102.5\n第 3 个交易日的价格: 99.2\n第 4 个交易日的价格: 101.8\n第 5 个交易日的价格: 104.6\n\n\n\n\n编写具有条件判断和循环结构的程序\n在本节课程中，我们将进一步学习如何编写具有条件判断和循环结构的程序，并解决一些简单的问题。\n\n判断奇数和偶数 编写一个程序，判断一个数是奇数还是偶数，并打印出所有的奇数或偶数。\n\n举例：\n\n判断一个数是否为奇数：\n\n\nnum = int(input(\"请输入一个整数：\"))\n\nif num % 2 == 0:\n    print(num, \"是偶数\")\nelse:\n    print(num, \"是奇数\")\n\n10 是偶数\n\n\n打印出1到10之间的所有偶数：\n\nfor num in range(1, 11):\n    if num % 2 == 0:\n        print(num)\n\n2\n4\n6\n8\n10\n\n\n\n计算斐波那契数列 编写一个程序，计算斐波那契数列中的前n个数字。\n注释：斐波那契数列是什么？\n斐波那契数列是一个数列，其中每个数字都是前两个数字之和。数列的开始通常为0和1，后续的数字由前两个数字相加而得。\n\n数列的前几个数字如下： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …\n可以看到，数列中的第一个数字是0，第二个数字是1，而后续的每个数字都是前两个数字之和。\n斐波那契数列在自然界和数学中都有广泛的应用。例如，斐波那契数列可以用于描述植物的分枝规律、音乐中的节奏模式、金融中的利率计算等。\n举例：\n\n计算斐波那契数列前10个数字：\n\n\nn = 10\na, b = 0, 1\n\nfor _ in range(n):\n    print(a)\n    a, b = b, a + b\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\n\n判断质数 编写一个程序，判断一个数是否为质数（只能被1和它本身整除的数）。\n\n举例：\n\n判断一个数是否为质数：\n\n\nnum = int(input(\"请输入一个整数：\"))\n\nif num &lt; 2:\n    print(num, \"不是质数\")\nelse:\n    is_prime = True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\nif is_prime:\n    print(num, \"是质数\")\nelse:\n    print(num, \"不是质数\")\n\n30 不是质数\n\n\n课后题1： 编写一个程序，要求用户输入一个正整数n，然后计算并打印出斐波那契数列的前n个数字。\n提示：可以使用循环结构和变量来计算斐波那契数列。\n课后题2： 编写一个程序，要求用户输入一个正整数num，判断该数是否为质数，并打印出相应的结果。\n提示：可以使用条件判断和循环结构来判断一个数是否为质数。\n答案：\n课后题1：\n\nn = int(input(\"请输入一个正整数：\"))\n\na, b = 0, 1\nfibonacci_sequence = []\n\nfor _ in range(n):\n    fibonacci_sequence.append(a)\n    a, b = b, a + b\n\nprint(\"斐波那契数列的前\", n, \"个数字为：\", fibonacci_sequence)\n\n斐波那契数列的前 4 个数字为： [0, 1, 1, 2]\n\n\n课后题2：\n\nnum = int(input(\"请输入一个正整数：\"))\n\nif num &lt; 2:\n    print(num, \"不是质数\")\nelse:\n    is_prime = True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\n    if is_prime:\n        print(num, \"是质数\")\n    else:\n        print(num, \"不是质数\")\n\n7 是质数"
  },
  {
    "objectID": "周五函数.html",
    "href": "周五函数.html",
    "title": "4  Python函数",
    "section": "",
    "text": "函数的定义和调用"
  },
  {
    "objectID": "周五函数.html#函数的作用",
    "href": "周五函数.html#函数的作用",
    "title": "4  Python函数",
    "section": "函数的作用",
    "text": "函数的作用\n函数是编程中的重要概念，它可以将一段代码封装为一个可重用的模块。 函数的作用和优势包括：\n\n代码重用：通过将一段经常使用的代码封装在函数中，我们可以在程序的不同地方多次调用该函数，避免了重复编写相同的代码，提高了代码的复用性。这样一来，如果需要修改功能或修复 bug，只需修改函数内部的实现，而不需要在多个地方逐个修改相同的代码。\n模块化：函数允许将程序划分为独立的模块，每个模块负责一个特定的功能。通过将复杂的任务分解为更小、更易管理的函数，可以使代码更易于理解和维护。模块化还有助于团队合作，不同的开发人员可以并行工作于不同的函数，从而提高开发效率。\n提高可读性：函数使代码更易读和理解。通过将一段代码封装在函数中，并给函数起一个有描述性的名称，可以提高代码的可读性。函数的参数和返回值也可以提供关于函数预期行为的重要信息，帮助其他开发人员理解和正确使用函数。\n抽象和封装：函数可以将复杂的实现细节隐藏在函数内部，只暴露必要的接口。这种抽象和封装的方式有助于降低代码的复杂性，提高代码的可维护性。其他部分的代码只需关注函数的输入和输出，而无需了解函数内部的具体实现。\n代码的组织和管理：函数可以将代码分成逻辑上独立的部分，使代码更加结构化和有组织。通过使用函数，可以将不同的功能模块分开，每个函数负责一个特定的任务。这样一来，当需要修改或添加新功能时，可以更容易地定位和修改相关的函数，而不必浏览整个代码文件。"
  },
  {
    "objectID": "周五函数.html#使用函数组织代码的优势",
    "href": "周五函数.html#使用函数组织代码的优势",
    "title": "4  Python函数",
    "section": "使用函数组织代码的优势",
    "text": "使用函数组织代码的优势\n函数是Python中最重要的部分之一，使用函数来组织代码可以使代码具有以下几个优势：\n\n可维护性：函数将代码划分为逻辑上独立的块，使得修改和调试代码更加容易。当需要对某个功能进行修改或修复时，只需关注相关的函数，而不必担心对其他部分代码产生意外影响。这种模块化的组织方式简化了代码的维护工作，提高了代码的可维护性。\n可重用性：通过将通用功能封装在函数中，可以在不同的地方多次调用该函数，实现代码的重用。不必重复编写相同的代码，减少了代码量，并且使得代码更加精简。当需要修改功能时，只需在函数内部进行修改，所有调用该函数的地方都会受到更新的影响。\n可读性：函数具有自我描述性的名称，可以提高代码的可读性。函数的参数和返回值提供了有关函数预期行为的重要信息，使得其他开发人员可以更轻松地理解和使用函数。通过适当划分和组织函数，可以使代码的逻辑更加清晰，易于理解。\n测试性：函数的独立性使得单元测试变得更加容易。通过针对函数编写单元测试，可以更好地验证函数的行为是否符合预期。这有助于及早发现和修复潜在的问题，提高代码的质量和可靠性。\n扩展性：使用函数进行代码组织可以使系统更易于扩展。通过添加新的函数或修改现有函数，可以实现新的功能或改进现有功能。由于函数之间的独立性，扩展一个功能不会对其他部分的代码造成太大的影响，减少了潜在的副作用和错误。\n\n总之，使用函数来组织代码可以提高代码的可维护性、可重用性、可读性和测试性，使得代码更易于扩展和管理。函数为代码提供了一种模块化的方式，使得开发人员能够更有效地开发、调试和维护代码。"
  },
  {
    "objectID": "周五函数.html#函数的定义",
    "href": "周五函数.html#函数的定义",
    "title": "4  Python函数",
    "section": "函数的定义",
    "text": "函数的定义\n函数是提前组织好的、可重复使用的、用来实现特定功能的代码段。input()、print()、str、int()等都是Python的内置函数。\n除了Python内置的函数，用户还可以根据自身的需求，自定义函数。函数的基础定义语法如下：\n\n\nCode\n# 函数的基础定义语法\ndef 函数名(传入参数):\n    函数体\n    return 返回值\n    \n# 调用函数\n函数名(参数)\n\n\n根据上面的基础定义语法，我们可以写出一个简短的示例函数。\n\n\nCode\ndef greet(name):\n    \"\"\"这是一个简单的问候函数\"\"\"\n    print(\"Hello, \" + name + \"!\")\n\n# 调用函数\ngreet(\"Alice\")\ngreet(\"Bob\")\n\n\nHello, Alice!\nHello, Bob!\n\n\n上述代码定义了一个名为greet的函数。在定义函数时，将函数名紧跟在def关键字后面(在上面的代码中，函数名是greet)。在函数名后面的圆括号中，是函数的参数列表，在函数定义时传入的参数，称为形式参数，简称形参(在上例中，函数接受了一个参数name)。参数数函数在执行时，所需要的输入值。最后是一个冒号，表示函数定义的结束。\n函数的定义之后，下一行缩进的代码块是函数体，它包含了函数的实际执行逻辑(在上例中，函数体只有一行代码，用于打印问候消息)。函数体可以包含任意数量的语句和逻辑。\n函数体的第一行可以是可选的字符串，称为文档字符串（docstring），用于描述函数的目的和使用方法。函数的说明文档通常使用多行注释的形式。在函数的说明文档中，我们可以使用使用param对参数进行解释，使用return对返回值进行解释。在上面的案例中，文档字符串提供了关于函数的简单说明。\n调用函数时，我们使用函数名后跟一对括号，括号内包含函数所需的参数值。在调用函数时传入的参数，就是实际参数，即实参。在示例中，我们先后调用了greet函数，并传入不同的参数值：“Alice”和”Bob”。函数被调用后，它会执行函数体中的代码，打印出相应的问候消息。\n这只是一个简单的示例，函数的定义和使用可以更加复杂和灵活，可以有多个参数和复杂的逻辑。函数的定义语法在大多数编程语言中都有类似的概念，尽管具体语法可能有所不同。在定义函数时，有如下注意事事项：\n\n参数、返回值如不需要，可以省略\n函数名必须先定义后使用\n在定义函数语句的前后，规范上要求空2行"
  },
  {
    "objectID": "周五函数.html#函数的命名规则",
    "href": "周五函数.html#函数的命名规则",
    "title": "4  Python函数",
    "section": "函数的命名规则",
    "text": "函数的命名规则\n在Python中，函数的命名需要遵循一些规则和约定，以保持代码的可读性和一致性。以下是Python中函数命名的规则：\n\n函数名只能包含字母、数字和下划线（_）字符。\n函数名可以以字母或下划线开头，但不能以数字开头。\n函数名区分大小写，因此my_function和my_Function是不同的函数名。\n函数名应该具有描述性，能够清晰地表达函数的作用和功能。推荐使用小写字母和下划线的组合，以增加可读性。例如，calculate_average、print_message等。\n如果函数名由多个单词组成，可以使用下划线进行单词间的分隔，这样可以提高函数名的可读性。这种命名方式被称为下划线命名法（snake_case）。例如，calculate_average_score。\n避免使用Python的关键字和保留字作为函数名，以免引起冲突。例如，不要将函数命名为def、print等。\n函数名应该尽量简洁明了，避免过长的命名。选择能准确描述函数功能的简洁名称。"
  },
  {
    "objectID": "周五函数.html#函数的调用方式",
    "href": "周五函数.html#函数的调用方式",
    "title": "4  Python函数",
    "section": "函数的调用方式",
    "text": "函数的调用方式\n\n函数的传入参数\n函数的传入参数的功能是：在函数进行计算的时候，函数将接收外部提供的数据。\n\n函数的传入参数在函数被调用时指定。\n在函数定义中所提供的n个传入参数，称为形式参数(形参)，表示函数声明将要使用n个形式参数。\n在函数调用中所提供的传入参数，称为实际参数(实参)，表示函数执行时真正实用的参数值。\n\n在Python中，函数可以接受不同类型的参数作为输入。这些参数可以用于在函数内部进行计算、执行操作或提供必要的数据。以下是Python中函数传入参数的一些常见用法：\n\n位置参数（Positional Arguments）：这是最常见的参数传递方式，按照参数在函数定义中的顺序进行传递。调用函数时，传递的参数值按照对应位置依次赋给函数定义中的参数，即实参的位置要与形参一一对应。\n\n\n\nCode\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Alice\", \"Hello\")  # 输出：Hello, Alice!\ngreet(\"Bob\", \"Hi\")  # 输出：Hi, Bob!\n\n\nHello, Alice!\nHi, Bob!\n\n\n\n关键字参数（Keyword Arguments）：使用关键字参数可以通过参数名来指定参数的值，而不必按照参数的顺序进行传递，即实参与形参的位置并不一一对应，但在传入参数时，需对使用参数名来进行标注。\n\n\n\nCode\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\ngreet(message=\"Hello\", name=\"Alice\")  # 输出：Hello, Alice!\ngreet(name=\"Bob\", message=\"Hi\")  # 输出：Hi, Bob!\n\n\nHello, Alice!\nHi, Bob!\n\n\n\n默认参数（Default Arguments）：函数定义时，可以为参数指定默认值，当调用函数时没有提供对应参数的值时，将使用默认值。在下面的示例中，将Hello设置为参数message的默认值，因此如果在调用参数时，没有传入message对应的值，message将会使用默认值Hello。\n\n\n\nCode\ndef greet(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Alice\")  # 输出：Hello, Alice!\ngreet(\"Bob\", \"Hi\")  # 输出：Hi, Bob!\n\n\nHello, Alice!\nHi, Bob!\n\n\n\n可变数量参数（Variable-length Arguments）：有时候，我们需要处理可变数量的参数。Python提供了两种方式来处理这种情况：\n\n*args：表示函数接受任意数量的位置参数，这些参数将作为一个元组传递给函数。\n**kwargs：表示函数接受任意数量的关键字参数，这些参数将作为一个字典传递给函数。\n\n\n\n\nCode\n# *args方式\ndef calculate_sum(*args):\n    total = sum(args)\n    print(\"Sum:\", total)\n\ncalculate_sum(1, 2, 3)  # 输出：Sum: 6\ncalculate_sum(10, 20, 30, 40, 50)  # 输出：Sum: 150\n\n\nSum: 6\nSum: 150\n\n\n\n\nCode\n# **kwargs方式\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25, country=\"USA\")\n# 输出：\n# name: Alice\n# age: 25\n# country: USA\n\n\nname: Alice\nage: 25\ncountry: USA\n\n\n\n\n函数的返回值\n函数的返回值，就是程序中函数完成事情后，最后给调用者的结果。在Python中，函数可以通过返回值将计算结果或数据传递给调用方。函数的返回值可以是任意类型的数据，包括数字、字符串、列表、字典等。以下是Python中函数返回值的用法和示例代码：\n\n返回单个值：函数可以使用return语句返回单个值。一旦执行到return语句，函数将立即停止执行，并将指定的值返回给调用方。\n\n\n\nCode\ndef add_numbers(a, b):\n    return a + b\n\nresult = add_numbers(3, 4)\nprint(result)  # 输出：7\n\n\n7\n\n\n\n返回多个值：函数可以使用return语句返回多个值，这些值将被打包为一个元组。调用方可以使用多个变量来接收这些返回值。\n\n\n\nCode\ndef get_name_length(name):\n    length = len(name)\n    uppercase_name = name.upper()\n    return length, uppercase_name\n\nname_length, uppercase_name = get_name_length(\"Alice\")\nprint(name_length)  # 输出：5\nprint(uppercase_name)  # 输出：ALICE\n\n\n5\nALICE\n\n\n\n空返回值：如果函数没有明确的返回语句，或者使用return语句而没有指定返回值，函数将默认返回None。\n\n在Python中，有一个特殊的字面量：None，其类型是：&lt;class 'NoneType'&gt;。如果函数没有使用return语句返回数据，实际上就是返回了None这个字面量。\n\n\n\n\nCode\ndef do_something():\n    print(\"Doing something\")\n\nresult = do_something()\nprint(result)  # 输出：None\n\n\nDoing something\nNone\n\n\n\n提前返回：在函数执行过程中，可以使用return语句提前结束函数的执行，并返回指定的值。这可以在满足某个条件时提前退出函数。\n\n\n\nCode\ndef check_positive(number):\n    if number &gt; 0:\n        return True\n    else:\n        return False\n\nresult = check_positive(5)\nprint(result)  # 输出：True\n\nresult = check_positive(-2)\nprint(result)  # 输出：False\n\n\nTrue\nFalse"
  },
  {
    "objectID": "周五函数.html#匿名函数lambda表达式",
    "href": "周五函数.html#匿名函数lambda表达式",
    "title": "4  Python函数",
    "section": "匿名函数（lambda表达式）",
    "text": "匿名函数（lambda表达式）\n在Python中，可以使用匿名函数（lambda表达式）来创建简单的、没有函数名的函数。匿名函数通常用于需要定义简短、一次性使用的函数。以下是匿名函数的用法和示例代码：\n\n\nCode\n# 匿名函数的语法\nlambda arguments: expression\n\n\n\nlambda关键字表示创建匿名函数。\narguments表示函数的参数列表。\nexpression表示函数的计算逻辑，即函数的返回值。\n\n匿名函数通常与内置函数（如map()、filter()等）一起使用，或者作为函数的参数传递给其他函数。\n下面是几个使用匿名函数的示例：\n\n匿名函数求平方：\n\n\n\nCode\nsquare = lambda x: x**2\nresult = square(5)\nprint(result)  # 输出：25\n\n\n25\n\n\n\n匿名函数求和：\n\n\n\nCode\naddition = lambda a, b: a + b\nresult = addition(3, 4)\nprint(result)  # 输出：7\n\n\n7\n\n\n\n使用内置函数map()和匿名函数对列表中的每个元素进行平方操作：\n\n\n\nCode\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = list(map(lambda x: x**2, numbers))\nprint(squared_numbers)  # 输出：[1, 4, 9, 16, 25]\n\n\n[1, 4, 9, 16, 25]\n\n\n\n使用内置函数filter()和匿名函数筛选出列表中的偶数：\n\n\n\nCode\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # 输出：[2, 4]\n\n\n[2, 4]\n\n\n匿名函数的优势在于其简洁性和灵活性，可以在需要临时定义函数的场景下快速创建函数，避免定义独立的函数名称。然而，由于其只能表示简单的表达式，因此不适合于复杂的逻辑和长代码块的情况。"
  },
  {
    "objectID": "周五函数.html#函数的嵌套和闭包",
    "href": "周五函数.html#函数的嵌套和闭包",
    "title": "4  Python函数",
    "section": "函数的嵌套和闭包",
    "text": "函数的嵌套和闭包\n\n函数的嵌套\n函数的嵌套调用是指在一个函数的定义中调用了另外的函数。在函数A中调用另外一个函数B时，会先把函数B中的任务都执行完毕后才会继续执行函数A的剩余内容。下面是函数嵌套的示例：\n\n\nCode\ndef func2():\n    print(\"我爱Python\")\n\n\ndef func1():\n    print(\"我是新手\")\n    func2()\n    print(\"我要好好学习\")\n\n\nfunc1()\n\n\n我是新手\n我爱Python\n我要好好学习\n\n\n在上面的示例中，函数func1在执行时，调用了函数func2，并且，只有在func2执行完成之后，func1才会继续执行剩余内容。\n\n在函数中使用的变量作用域\n\n变量的作用域指的是变量的作用范围，即变量在哪里可用，在哪里不可用。\n根据变量的作用范围，变量分为局部变量和全局变量。\n\n局部变量\n\n局部变量是指定义在函数体内部的变量，这种变量只在函数体内部生效。\n局部变量的作用：在函数体内部临时保存数据，在函数调用完成以后，局部变量就被销毁了。\n\n全局变量\n\n全局变量就是指在函数体内、外部都能生效的变量。\n\nglobal关键字\n\n使用global关键字，可以在函数内部声明变量为全局变量。\n\n\n函数的闭包\n在Python中，闭包（closure）是指在一个函数内部定义的函数，并且该内部函数可以访问外部函数的变量。闭包可以捕获并保持外部函数的状态，即使外部函数已经执行完毕，内部函数仍然可以使用外部函数的变量。这使得闭包在编程中非常有用，特别是在函数式编程和装饰器模式中。\n闭包的关键是内部函数可以访问外部函数的变量。在Python中，当内部函数引用外部函数的变量时，Python会将该变量包装成一个包含变量值的闭包对象。这个闭包对象可以在内部函数中使用，并且在内部函数被调用时仍然保持着它的值。\n\n\nCode\ndef outer_function(x):\n    def inner_function(y):\n        return x + y\n    return inner_function\n\nclosure = outer_function(10)\nresult = closure(5)\nprint(result)\n\n\n15\n\n\n在上面的例子中，outer_function是外部函数，它接受一个参数x。内部函数inner_function定义在外部函数内部，并引用了外部函数的参数 x。outer_function返回了内部函数inner_function，形成了一个闭包。\n在这个例子中，我们调用outer_function(10)并将返回的内部函数保存在 closure变量中。然后，我们调用closure(5)，这实际上是调用了内部函数inner_function。由于闭包的存在，内部函数仍然可以访问外部函数的变量x，所以结果将是10 + 5 = 15。\n通过闭包，我们可以创建具有记忆功能的函数，可以在多次调用之间保持状态。这使得闭包在实现装饰器、缓存功能等方面非常有用。"
  },
  {
    "objectID": "周五模块.html",
    "href": "周五模块.html",
    "title": "5  Python模块",
    "section": "",
    "text": "Python标准库的模块"
  },
  {
    "objectID": "周五模块.html#模块的概念",
    "href": "周五模块.html#模块的概念",
    "title": "5  Python模块",
    "section": "模块的概念",
    "text": "模块的概念\n在Python中，模块是一个包含函数、类和变量的Python文件。它提供了一种组织和重用代码的方式，使得我们可以将相关的代码组织在一个独立的单元中，并通过导入模块来使用其中的函数、类和变量。\n模块使得代码的组织更加模块化和可维护，可以将相关功能划分到不同的模块中，使得代码更易于理解和扩展。另外，通过使用模块，可以实现代码的复用，不必重复编写相同的代码。\n要使用一个模块，我们需要使用 import 语句将模块导入到当前的Python环境中。导入模块后，我们就可以通过模块名加点操作符来访问模块中定义的函数、类和变量。\n\n\nCode\n# 文件名: mymodule.py\ndef greeting(name):\n    print(\"Hello, \" + name + \"!\")\n\nclass MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def print_value(self):\n        print(\"Value:\", self.value)\n\nPI = 3.14159\n\n\n上面是一个简单的模块示例，在代码中，我们定义了一个模块mymodule。该模块包含一个函数greeting，一个类MyClass，和一个变量PI。\n在定义完成该模块之后，我们就可以在另外一个Python文件中导入并使用该模块。\n\n\nCode\nimport mymodule\n\nmymodule.greeting(\"Alice\")\n\nobj = mymodule.MyClass(10)\nobj.print_value()\n\nprint(\"PI value:\", mymodule.PI)\n\n\n在上面的代码中，我们使用import语句导入了模块mymodule。然后，我们可以使用mymodule模块名加点操作符来访问模块中的函数、类和变量。例如，我们调用了mymodule.greeting(\"Alice\")来调用模块中的greeting函数。\n类似地，我们创建了mymodule.MyClass的对象，并调用了其中的方法print_value()。最后，我们打印了模块中的变量mymodule.PI的值。\n这就是模块的基本概念和用法。通过模块，我们可以更好地组织和复用代码，使得程序更加模块化和可维护。"
  },
  {
    "objectID": "周五模块.html#模块的使用",
    "href": "周五模块.html#模块的使用",
    "title": "5  Python模块",
    "section": "模块的使用",
    "text": "模块的使用\n学习如何使用Python标准库中的模块非常重要，因为标准库提供了大量功能丰富的模块，可以帮助我们完成各种任务。同时，我们自己定义的模块也常常能在工作中提供很大的帮助。\n以下是模块的基本使用方法：\n\n导入模块：要使用标准库模块，首先需要使用 import 语句将模块导入到当前的Python环境中。导入模块的一般语法是 import module_name。例如，要导入标准库中的 math 模块，可以使用 import math。\n\n\n\nCode\nimport math\n\nresult = math.sqrt(25)\nprint(result)  # 输出: 5.0\n\n\n5.0\n\n\n\n使用模块中的函数、类和变量：一旦导入了模块，就可以使用模块中定义的函数、类和变量。使用的语法是 module_name.function_name()、module_name.ClassName() 或 module_name.variable_name。例如，要使用 math 模块中的 sqrt 函数，可以使用 math.sqrt(25)。\n\n\n\nCode\nimport math\n\nresult = math.sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = math.pi * math.pow(radius, 2)\nprint(area)  # 输出: 78.53981633974483\n\n\n5.0\n78.53981633974483\n\n\n\n给模块起别名：有时模块名很长或与其他名称冲突，可以给模块起一个别名以便更方便地使用。使用别名的语法是 import module_name as alias。例如，要将 math 模块起别名为 m，可以使用 import math as m。\n\n\n\nCode\nimport math as m\n\nresult = m.sqrt(25)\nprint(result)  # 输出: 5.0\n\n\n5.0\n\n\n\n导入模块中的特定函数或变量：如果只需要使用模块中的某些特定函数或变量，可以使用 from module_name import item_name 的语法。这样可以直接使用 item_name，而无需使用模块名作为前缀。例如，要导入 math 模块中的 sqrt 函数，可以使用 from math import sqrt，然后直接使用 sqrt(25)。\n\n\n\nCode\nfrom math import sqrt, pi\n\nresult = sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = pi * radius ** 2\nprint(area)  # 输出: 78.53981633974483\n\n\n5.0\n78.53981633974483\n\n\n\n导入模块中的所有内容：如果希望导入模块中的所有函数、类和变量，可以使用 from module_name import * 的语法。这样可以直接使用模块中的所有内容，但可能会与其他已有的函数或变量发生冲突，因此需要谨慎使用。\n\n\n\nCode\nfrom math import *\n\nresult = sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = pi * radius ** 2\nprint(area)  # 输出: 78.53981633974483\n\n\n5.0\n78.53981633974483\n\n\n\n查看模块的帮助文档：Python标准库模块通常有详细的文档说明。可以使用 help(module_name) 函数来查看模块的帮助文档。例如，使用 help(math) 可以查看 math 模块的帮助文档。\n\n\n\nCode\nimport math\n\nhelp(math)\n\n\nHelp on built-in module math:\n\nNAME\n    math\n\nDESCRIPTION\n    This module provides access to the mathematical functions\n    defined by the C standard.\n\nFUNCTIONS\n    acos(x, /)\n        Return the arc cosine (measured in radians) of x.\n        \n        The result is between 0 and pi.\n    \n    acosh(x, /)\n        Return the inverse hyperbolic cosine of x.\n    \n    asin(x, /)\n        Return the arc sine (measured in radians) of x.\n        \n        The result is between -pi/2 and pi/2.\n    \n    asinh(x, /)\n        Return the inverse hyperbolic sine of x.\n    \n    atan(x, /)\n        Return the arc tangent (measured in radians) of x.\n        \n        The result is between -pi/2 and pi/2.\n    \n    atan2(y, x, /)\n        Return the arc tangent (measured in radians) of y/x.\n        \n        Unlike atan(y/x), the signs of both x and y are considered.\n    \n    atanh(x, /)\n        Return the inverse hyperbolic tangent of x.\n    \n    cbrt(x, /)\n        Return the cube root of x.\n    \n    ceil(x, /)\n        Return the ceiling of x as an Integral.\n        \n        This is the smallest integer &gt;= x.\n    \n    comb(n, k, /)\n        Number of ways to choose k items from n items without repetition and without order.\n        \n        Evaluates to n! / (k! * (n - k)!) when k &lt;= n and evaluates\n        to zero when k &gt; n.\n        \n        Also called the binomial coefficient because it is equivalent\n        to the coefficient of k-th term in polynomial expansion of the\n        expression (1 + x)**n.\n        \n        Raises TypeError if either of the arguments are not integers.\n        Raises ValueError if either of the arguments are negative.\n    \n    copysign(x, y, /)\n        Return a float with the magnitude (absolute value) of x but the sign of y.\n        \n        On platforms that support signed zeros, copysign(1.0, -0.0)\n        returns -1.0.\n    \n    cos(x, /)\n        Return the cosine of x (measured in radians).\n    \n    cosh(x, /)\n        Return the hyperbolic cosine of x.\n    \n    degrees(x, /)\n        Convert angle x from radians to degrees.\n    \n    dist(p, q, /)\n        Return the Euclidean distance between two points p and q.\n        \n        The points should be specified as sequences (or iterables) of\n        coordinates.  Both inputs must have the same dimension.\n        \n        Roughly equivalent to:\n            sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))\n    \n    erf(x, /)\n        Error function at x.\n    \n    erfc(x, /)\n        Complementary error function at x.\n    \n    exp(x, /)\n        Return e raised to the power of x.\n    \n    exp2(x, /)\n        Return 2 raised to the power of x.\n    \n    expm1(x, /)\n        Return exp(x)-1.\n        \n        This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\n    \n    fabs(x, /)\n        Return the absolute value of the float x.\n    \n    factorial(n, /)\n        Find n!.\n        \n        Raise a ValueError if x is negative or non-integral.\n    \n    floor(x, /)\n        Return the floor of x as an Integral.\n        \n        This is the largest integer &lt;= x.\n    \n    fmod(x, y, /)\n        Return fmod(x, y), according to platform C.\n        \n        x % y may differ.\n    \n    frexp(x, /)\n        Return the mantissa and exponent of x, as pair (m, e).\n        \n        m is a float and e is an int, such that x = m * 2.**e.\n        If x is 0, m and e are both 0.  Else 0.5 &lt;= abs(m) &lt; 1.0.\n    \n    fsum(seq, /)\n        Return an accurate floating point sum of values in the iterable seq.\n        \n        Assumes IEEE-754 floating point arithmetic.\n    \n    gamma(x, /)\n        Gamma function at x.\n    \n    gcd(*integers)\n        Greatest Common Divisor.\n    \n    hypot(...)\n        hypot(*coordinates) -&gt; value\n        \n        Multidimensional Euclidean distance from the origin to a point.\n        \n        Roughly equivalent to:\n            sqrt(sum(x**2 for x in coordinates))\n        \n        For a two dimensional point (x, y), gives the hypotenuse\n        using the Pythagorean theorem:  sqrt(x*x + y*y).\n        \n        For example, the hypotenuse of a 3/4/5 right triangle is:\n        \n            &gt;&gt;&gt; hypot(3.0, 4.0)\n            5.0\n    \n    isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)\n        Determine whether two floating point numbers are close in value.\n        \n          rel_tol\n            maximum difference for being considered \"close\", relative to the\n            magnitude of the input values\n          abs_tol\n            maximum difference for being considered \"close\", regardless of the\n            magnitude of the input values\n        \n        Return True if a is close in value to b, and False otherwise.\n        \n        For the values to be considered close, the difference between them\n        must be smaller than at least one of the tolerances.\n        \n        -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\n        is, NaN is not close to anything, even itself.  inf and -inf are\n        only close to themselves.\n    \n    isfinite(x, /)\n        Return True if x is neither an infinity nor a NaN, and False otherwise.\n    \n    isinf(x, /)\n        Return True if x is a positive or negative infinity, and False otherwise.\n    \n    isnan(x, /)\n        Return True if x is a NaN (not a number), and False otherwise.\n    \n    isqrt(n, /)\n        Return the integer part of the square root of the input.\n    \n    lcm(*integers)\n        Least Common Multiple.\n    \n    ldexp(x, i, /)\n        Return x * (2**i).\n        \n        This is essentially the inverse of frexp().\n    \n    lgamma(x, /)\n        Natural logarithm of absolute value of Gamma function at x.\n    \n    log(...)\n        log(x, [base=math.e])\n        Return the logarithm of x to the given base.\n        \n        If the base not specified, returns the natural logarithm (base e) of x.\n    \n    log10(x, /)\n        Return the base 10 logarithm of x.\n    \n    log1p(x, /)\n        Return the natural logarithm of 1+x (base e).\n        \n        The result is computed in a way which is accurate for x near zero.\n    \n    log2(x, /)\n        Return the base 2 logarithm of x.\n    \n    modf(x, /)\n        Return the fractional and integer parts of x.\n        \n        Both results carry the sign of x and are floats.\n    \n    nextafter(x, y, /)\n        Return the next floating-point value after x towards y.\n    \n    perm(n, k=None, /)\n        Number of ways to choose k items from n items without repetition and with order.\n        \n        Evaluates to n! / (n - k)! when k &lt;= n and evaluates\n        to zero when k &gt; n.\n        \n        If k is not specified or is None, then k defaults to n\n        and the function returns n!.\n        \n        Raises TypeError if either of the arguments are not integers.\n        Raises ValueError if either of the arguments are negative.\n    \n    pow(x, y, /)\n        Return x**y (x to the power of y).\n    \n    prod(iterable, /, *, start=1)\n        Calculate the product of all the elements in the input iterable.\n        \n        The default start value for the product is 1.\n        \n        When the iterable is empty, return the start value.  This function is\n        intended specifically for use with numeric values and may reject\n        non-numeric types.\n    \n    radians(x, /)\n        Convert angle x from degrees to radians.\n    \n    remainder(x, y, /)\n        Difference between x and the closest integer multiple of y.\n        \n        Return x - n*y where n*y is the closest integer multiple of y.\n        In the case where x is exactly halfway between two multiples of\n        y, the nearest even value of n is used. The result is always exact.\n    \n    sin(x, /)\n        Return the sine of x (measured in radians).\n    \n    sinh(x, /)\n        Return the hyperbolic sine of x.\n    \n    sqrt(x, /)\n        Return the square root of x.\n    \n    tan(x, /)\n        Return the tangent of x (measured in radians).\n    \n    tanh(x, /)\n        Return the hyperbolic tangent of x.\n    \n    trunc(x, /)\n        Truncates the Real x to the nearest Integral toward 0.\n        \n        Uses the __trunc__ magic method.\n    \n    ulp(x, /)\n        Return the value of the least significant bit of the float x.\n\nDATA\n    e = 2.718281828459045\n    inf = inf\n    nan = nan\n    pi = 3.141592653589793\n    tau = 6.283185307179586\n\nFILE\n    (built-in)"
  },
  {
    "objectID": "周五模块.html#常用的内置模块",
    "href": "周五模块.html#常用的内置模块",
    "title": "5  Python模块",
    "section": "常用的内置模块",
    "text": "常用的内置模块\n\nmath模块\n\nmath模块提供了执行数学运算的函数和常量。它包含了许多常见的数学操作，如三角函数、指数函数、对数函数等。\n\n\nCode\nimport math\n\nresult = math.sqrt(25)  # 平方根\nprint(result)  # 输出: 5.0\n\nangle = math.radians(45)  # 将角度转换为弧度\nsine = math.sin(angle)  # 正弦函数\nprint(sine)  # 输出: 0.7071067811865476\n\npi = math.pi  # 圆周率\nprint(pi)  # 输出: 3.141592653589793\n\n\n5.0\n0.7071067811865476\n3.141592653589793\n\n\n\nrandom模块\n\nrandom模块用于生成随机数。它提供了各种随机数生成函数，如生成随机整数、随机选择元素等。\n\n\nCode\nimport random\n\nnumber = random.randint(1, 10)  # 生成一个1到10之间的随机整数\nprint(number)  # 输出: 随机整数\n\nitems = [1, 2, 3, 4, 5]\nrandom_choice = random.choice(items)  # 从列表中随机选择一个元素\nprint(random_choice)  # 输出: 随机选择的元素\n\n\n3\n1"
  },
  {
    "objectID": "周五模块.html#文件和目录操作的模块",
    "href": "周五模块.html#文件和目录操作的模块",
    "title": "5  Python模块",
    "section": "文件和目录操作的模块",
    "text": "文件和目录操作的模块\n\nos模块\n\nos模块提供了许多与操作系统交互的函数。它可以用于执行文件和目录操作、获取系统信息等。\n\n\nCode\nimport os\n\ncurrent_dir = os.getcwd()  # 获取当前工作目录\nprint(current_dir)  # 输出: 当前工作目录的路径\n\nfile_list = os.listdir(current_dir)  # 获取当前目录下的文件列表\nprint(file_list)  # 输出: 当前目录下的文件列表\n\n\n\nshutil模块\n\nshutil模块用于高级的文件和目录操作。它提供了一些方便的函数，如复制文件、移动文件、删除文件等。\n\n\nCode\nimport shutil\n\nsource = 'path/to/source/file.txt'\ndestination = 'path/to/destination/file.txt'\n\nshutil.copy(source, destination)  # 复制文件"
  },
  {
    "objectID": "周五模块.html#时间和日期处理的模块",
    "href": "周五模块.html#时间和日期处理的模块",
    "title": "5  Python模块",
    "section": "时间和日期处理的模块",
    "text": "时间和日期处理的模块\n\ndatetime模块\n\ndatetime模块提供了处理日期和时间的功能。它包含了日期、时间、时间间隔等对象，以及各种日期和时间操作的函数。\n\n\nCode\nimport datetime\n\ncurrent_time = datetime.datetime.now()  # 获取当前时间\nprint(current_time)  # 输出: 当前时间\n\ncurrent_date = datetime.date.today()  # 获取当前日期\nprint(current_date)  # 输出: 当前日期\n\n\n2023-06-29 00:14:50.958106\n2023-06-29\n\n\n\ntime模块\n\ntime模块提供了与时间相关的函数。它可以用于获取当前时间、时间的格式化、休眠等操作。\n\n\nCode\nimport time\n\ncurrent_time = time.localtime()  # 获取当前时间的本地表示\nprint(current_time)  # 输出: 当前本地时间的结构化表示\n\nformatted_time = time.strftime('%Y-%m-%d %H:%M:%S', current_time)  # 格式化时间\nprint(formatted_time)  # 输出: 格式化后的时间字符串\n\n\ntime.struct_time(tm_year=2023, tm_mon=6, tm_mday=29, tm_hour=0, tm_min=15, tm_sec=30, tm_wday=3, tm_yday=180, tm_isdst=0)\n2023-06-29 00:15:30\n\n\n这些模块是Python标准库中的一小部分，它们提供了广泛的功能和工具，可帮助您处理数学运算、随机数生成、文件和目录操作、日期时间处理等各种任务。\n要熟练使用Python，就需要掌握这些模块的使用方法，并能够根据需要，自定义模块。"
  },
  {
    "objectID": "周五模块.html#第三方模块的概念及安装方法",
    "href": "周五模块.html#第三方模块的概念及安装方法",
    "title": "5  Python模块",
    "section": "第三方模块的概念及安装方法",
    "text": "第三方模块的概念及安装方法\n在Python中，第三方模块是由Python社区或其他开发者开发的，用于扩展Python功能和提供额外功能的模块。这些模块通常不包含在Python标准库中，但它们提供了各种用途的功能，例如网络请求、数据分析、图像处理等。\n安装第三方模块可以通过使用包管理工具pip来完成。pip是Python的默认包管理工具，可用于安装、升级和卸载第三方模块。\n以下是安装第三方模块的步骤：\n\n确保已安装pip：\n\n在终端或命令提示符中运行以下指令。检查pip是否已安装：\n\n\nCode\npip --version\n\n\n如果输出了pip的版本信息，则说明pip已安装。如果未找到pip或提示未定义的命令，则需要先安装pip。\n\n使用pip安装模块：要安装第三方模块，可以在终端或命令提示符中运行以下命令：\n\n\n\nCode\npip install module_name\n\n\n例如，要安装常用的第三方模块requests，可以运行：\n\n\nCode\npip install requests\n\n\n其中，module_name是要安装的第三方模块的名称。pip将自动下载并安装该模块及其相关依赖项。\n\n确认安装成功：安装完成后，可以在Python脚本中导入并使用该模块。如果没有报错，则表示安装成功。示例如下：\n\n\n\nCode\nimport requests\n\nresponse = requests.get('https://www.example.com')\nprint(response.status_code)\n\n\n上述代码导入了requests模块，并使用该模块发送HTTP请求。\n需要注意的是，有些第三方模块可能需要特定版本的Python或其他依赖项。在安装之前，建议查阅该模块的官方文档或README文件，以了解安装要求和使用说明。\n另外，还有其他包管理工具可以用于安装第三方模块，例如conda、pipenv等，具体根据您的需求和使用环境选择合适的工具。\n总的来说，第三方模块为Python提供了丰富的扩展功能，我们可以根据特定的项目需求安装第三方模块。"
  },
  {
    "objectID": "周五模块.html#常用的数据分析和科学计算库",
    "href": "周五模块.html#常用的数据分析和科学计算库",
    "title": "5  Python模块",
    "section": "常用的数据分析和科学计算库",
    "text": "常用的数据分析和科学计算库\nNumPy和Pandas是Python数据分析和科学计算中的重要库。NumPy提供了高性能的数值计算和数组操作功能，适用于处理大规模数值数据；而Pandas则专注于数据分析和操作，提供了灵活且高效的数据结构和数据处理工具，使得数据的清洗、转换和分析更加方便。这两个库通常一起使用，使得数据科学工作更加便捷和高效。\n\nNumPy（Numerical Python）\n\n\nNumPy是Python中用于数值计算和科学计算的核心库。\nNumPy提供了一个强大的多维数组对象（ndarray），可以进行高效的数值运算和数组操作。ndarray是一个具有相同类型和大小的元素组成的多维容器，它提供了高速的数值运算和广播功能。\nNumPy的主要特点包括：\n\n多维数组操作：NumPy提供了广泛的数组操作函数，例如索引、切片、形状操作、重塑、拼接等。\n数学函数：NumPy包含了各种数学函数，如三角函数、指数函数、对数函数、统计函数等。\n线性代数运算：NumPy提供了线性代数运算功能，如矩阵乘法、逆矩阵、特征值等。\n随机数生成：NumPy具有随机数生成的功能，可以生成各种概率分布的随机数。\n\n\nNumPy是Python科学计算的基础库，许多其他科学计算和数据分析库都建立在NumPy之上。\n下面是NumPy的简单应用示例：\n\n\nCode\nimport numpy as np\n\n# 创建NumPy数组\narr = np.array([1, 2, 3, 4, 5])\n\n# 数组运算\nprint(arr + 1)  # 加法运算\nprint(arr * 2)  # 乘法运算\nprint(np.mean(arr))  # 平均值\n\n# 多维数组\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2d.shape)  # 输出: (2, 3)\n\n# 线性代数运算\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nprint(np.dot(a, b))  # 矩阵相乘\n\n\n[2 3 4 5 6]\n[ 2  4  6  8 10]\n3.0\n(2, 3)\n[[19 22]\n [43 50]]\n\n\n\nPandas\n\n\nPandas是一个功能强大的数据分析和操作库，构建在NumPy之上。\nPandas提供了两个重要的数据结构：Series和DataFrame。\n\nSeries是一维的标签化数组，类似于带标签的一维数组，可以容纳任意类型的数据。\nDataFrame是二维的表格型数据结构，类似于SQL中的表或Excel中的电子表格，具有行和列的标签，每列可以是不同的数据类型。\n\nPandas的主要功能包括：\n\n数据读取和写入：Pandas可以从各种数据源（如CSV文件、Excel文件、SQL数据库等）读取数据，并可以将数据写入不同的格式。\n数据清洗和预处理：Pandas提供了丰富的功能来处理缺失值、重复数据、异常值等数据清洗任务。\n数据操作和计算：Pandas支持灵活的数据操作和计算，如索引、切片、筛选、聚合、分组等。\n时间序列处理：Pandas提供了强大的时间序列处理功能，支持日期和时间的索引、重采样、滚动窗口计算等。\n数据可视化：Pandas集成了Matplotlib库，可以方便地进行数据可视化。\n\n\nPandas提供了高效的数据处理和分析工具，使得数据科学家和分析师能够更轻松地处理和分析结构化数据。\n\n\nCode\nimport pandas as pd\n\n# 创建Pandas DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n        'Age': [25, 30, 35, 40],\n        'City': ['New York', 'London', 'Paris', 'Tokyo']}\n\ndf = pd.DataFrame(data)\n\n# 数据操作\nprint(df.head())  # 查看前几行数据\nprint(df['Age'].mean())  # 计算年龄的平均值\n\n# 数据筛选\nfiltered_df = df[df['Age'] &gt; 30]  # 筛选年龄大于30的数据\nprint(filtered_df)\n\n# 数据分组和聚合\ngroupby_city = df.groupby('City')\nmean_age_by_city = groupby_city['Age'].mean()\nprint(mean_age_by_city)\n\n# 时间序列处理\ndates = pd.date_range(start='2021-01-01', end='2021-12-31', freq='D')\nprint(dates)\n\n\n      Name  Age      City\n0    Alice   25  New York\n1      Bob   30    London\n2  Charlie   35     Paris\n3    David   40     Tokyo\n32.5\n      Name  Age   City\n2  Charlie   35  Paris\n3    David   40  Tokyo\nCity\nLondon      30.0\nNew York    25.0\nParis       35.0\nTokyo       40.0\nName: Age, dtype: float64\nDatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',\n               '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08',\n               '2021-01-09', '2021-01-10',\n               ...\n               '2021-12-22', '2021-12-23', '2021-12-24', '2021-12-25',\n               '2021-12-26', '2021-12-27', '2021-12-28', '2021-12-29',\n               '2021-12-30', '2021-12-31'],\n              dtype='datetime64[ns]', length=365, freq='D')\n\n\nPandas库将是我们后面学习的重点内容，大家可以预先了解。"
  },
  {
    "objectID": "安装.html",
    "href": "安装.html",
    "title": "6  Pandas安装",
    "section": "",
    "text": "使用Anaconda安装\n对于没有经验的小白来说，直接上手用代码来安装各种包可能有点困难，而Anaconda作为一个发型平台，可以非常轻松的安装除了Pandas之外的各种Python包（IPython、NumPy、 Matplotlib等）\n详细的Anaconda安装步骤可以观看我的B站视频，或者官方文档\n\nconda install pandas\n\n\n\n\n\n\n\n\n使用PyPI中的 pip 安装\n\npip install pandas\n\n\n\n\n\n\n\nTip\n\n\n\n一般来说这是python自带的安装方式，但有时候你的虚拟环境没有或者服务器里的需要更新，可以参考文档\n\n\n\nLinuxMacOSWindows\n\n\n$ python -m ensurepip --upgrade\n\n\n$ python -m ensurepip --upgrade\n\n\nC:&gt; py -m ensurepip --upgrade"
  },
  {
    "objectID": "pandas处理什么样的数据.html#表格数据",
    "href": "pandas处理什么样的数据.html#表格数据",
    "title": "7  pandas处理什么样的数据",
    "section": "表格数据",
    "text": "表格数据\nPandas最常用于处理表格数据，例如CSV文件、Excel文件、数据库查询结果等。你可以使用Pandas读取这些数据，并对其进行各种操作，如过滤、排序、合并、聚合、计算统计指标等。\n当使用Pandas处理表格数据时，你可以使用DataFrame这个主要的数据结构。DataFrame是一个二维的标记数组，类似于电子表格或SQL表。\n\n\nCode\n# 1. 导入pandas包\nimport pandas as pd\n\n# 2. 假设data数据\ndata = {\n  \"calories\": [420, 380, 390],\n  \"duration\": [50, 40, 45]\n}\n\n# 3. 假设df，然后调用pd(pandas包)，将数据转换为DataFrame格式\ndf = pd.DataFrame(data)\n\n# 4. 打印df\ndf\n\n\n\n\n\n\n\n\n\ncalories\nduration\n\n\n\n\n0\n420\n50\n\n\n1\n380\n40\n\n\n2\n390\n45"
  },
  {
    "objectID": "pandas处理什么样的数据.html#时间序列数据",
    "href": "pandas处理什么样的数据.html#时间序列数据",
    "title": "7  pandas处理什么样的数据",
    "section": "时间序列数据",
    "text": "时间序列数据\nPandas提供了强大的时间序列功能，可以处理日期和时间相关的数据。你可以使用Pandas对时间序列数据进行重采样、滚动计算、时间窗口分析、时间序列绘图等操作。\n\n\nCode\nimport pandas as pd\n\ndate = pd.to_datetime(\"13th of June, 2023\")\n\ndate\n\n\nTimestamp('2023-06-13 00:00:00')\n\n\n可以使用DateTimeIndex和TimedeltaIndex来表示时间索引和时间间隔。\n\n\nCode\nimport pandas as pd\n# 创建一个包含日期范围的时间索引\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10', freq='D')\n\n# 创建一个DataFrame，并使用时间索引\ndata = pd.DataFrame({'Value': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]}, index=date_range)\n\n# 查看数据的前几行\ndata.head()\n\n\n\n\n\n\n\n\n\nValue\n\n\n\n\n2023-01-01\n10\n\n\n2023-01-02\n20\n\n\n2023-01-03\n30\n\n\n2023-01-04\n40\n\n\n2023-01-05\n50\n\n\n\n\n\n\n\n选取所需的时间序列数据，并进行计算\n\n\nCode\n# 通过日期索引获取某一天的数据\nday_data = data.loc['2023-01-05']\n\n# 通过日期范围索引获取一段时间内的数据\nrange_data = data.loc['2023-01-03':'2023-01-07']\n\n# 使用日期的年、月、日等属性进行切片\nyear_data = data[data.index.year == 2023]\nmonth_data = data[data.index.month == 1]\nday_data = data[data.index.day == 5]\n\n# 将数据按周进行重采样，计算每周的平均值\nweekly_data = data.resample('W').mean()\n\n# 将数据按月进行重采样，计算每月的总和\nmonthly_data = data.resample('M').sum()"
  },
  {
    "objectID": "pandas处理什么样的数据.html#缺失数据处理",
    "href": "pandas处理什么样的数据.html#缺失数据处理",
    "title": "7  pandas处理什么样的数据",
    "section": "缺失数据处理",
    "text": "缺失数据处理\nPandas提供了灵活的方法来处理缺失数据。你可以使用Pandas来检测和处理缺失值，填充缺失数据，或者根据缺失值进行数据筛选和计算。\n\n\nCode\n# 创建带有缺失数据的DataFrame\ndata = pd.DataFrame({'A': [1, 2, None, 4, 5],\n                     'B': [None, 2, 3, None, 6],\n\n                     'C': [1, 2, 3, 4, 5]})\n\n\n检查并统计缺失值\n\n\nCode\n# 检测每个单元格是否为缺失值\nmissing_values = data.isnull()\n\n# 统计每列的缺失值数量\nmissing_counts = data.isnull().sum()\n\n# 统计整个DataFrame的缺失值数量\ntotal_missing_count = data.isnull().sum().sum()\n\n\n对缺失值进行操作\n\n\nCode\n# 删除包含缺失值的行\ndata_dropna = data.dropna()\n\n# 删除全部为缺失值的列\ndata_dropna_cols = data.dropna(axis=1, how='all')\n\n# 填充缺失值为指定的常数\ndata_fillna = data.fillna(0)\n\n# 使用缺失值前面的值进行前向填充\ndata_ffill = data.fillna(method='ffill')\n\n# 使用缺失值后面的值进行后向填充\ndata_bfill = data.fillna(method='bfill')"
  },
  {
    "objectID": "pandas处理什么样的数据.html#数据清洗和转换",
    "href": "pandas处理什么样的数据.html#数据清洗和转换",
    "title": "7  pandas处理什么样的数据",
    "section": "数据清洗和转换",
    "text": "数据清洗和转换\nPandas可以用于数据清洗和转换的各种操作。你可以使用Pandas对数据进行重塑、合并、分组、变形等，以满足特定的分析需求。\n\n\nCode\n# 创建原始数据\ndata = pd.DataFrame({'Name': ['John', 'Emily', 'Michael', 'Emma'],\n                     'Age': [25, 30, 35, 28],\n                     'Gender': ['M', 'F', 'M', 'F'],\n                     'Salary': ['$5000', '$6000', '$4500', '$7000']})\n\n\n\n数据清洗\n清洗重复或者多余数据\n\n\nCode\n# 去除重复的行\ndata_cleaned = data.drop_duplicates()\n\n# 去除列中的空格\ndata_cleaned['Name'] = data_cleaned['Name'].str.strip()\n\n# 删除缺失值所在的行\ndata_cleaned = data_cleaned.dropna()\n\n\n\n\n数据转换\n将列表转换为系列（Series）\nseries = pd.Series(list)\n\n\nCode\nimport pandas as pd\n\n# 将列表转换为系列\nmy_list = [1, 2, 3, 4, 5]\nseries = pd.Series(my_list)\nseries\n\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n\n\n将系列（Series）转换为数据帧（DataFrame）\ndataframe = series.to_frame()\n\n\nCode\n# 将系列转换为数据帧\nseries = pd.Series([1, 2, 3, 4, 5])\ndataframe = series.to_frame()\ndataframe\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n\n\n\n\n\n将数据帧（DataFrame）转换为列表（list）\nmy_list = df.values.tolist()\n\n\nCode\n# 将数据帧转换为列表\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\nmy_list = df.values.tolist()\nmy_list\n\n\n[[1, 4], [2, 5], [3, 6]]\n\n\n\n\n\n\n\n\nTip\n\n\n\n数据的清洗和转换是pandas最常使用的功能，之后我们会逐步拆解，进行详细说明"
  },
  {
    "objectID": "pandas处理什么样的数据.html#数据可视化",
    "href": "pandas处理什么样的数据.html#数据可视化",
    "title": "7  pandas处理什么样的数据",
    "section": "数据可视化",
    "text": "数据可视化\nPandas集成了Matplotlib库，可以通过简单的接口生成各种统计图表和可视化图形，以便更好地理解和呈现数据。\n\n\nCode\n# 创建数据\ndata = pd.DataFrame({'Month': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],\n                     'Sales': [100, 150, 120, 200, 180, 250],\n                     'Expenses': [80, 90, 100, 85, 95, 110]})\n\n# 折线图\ndata.plot(x='Month', y='Sales', kind='line')\n\n\n&lt;Axes: xlabel='Month'&gt;\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n虽然pandas也可以画图，但是还是静态图形，之后我们会详细说明更加简洁和酷炫的可视化库 Plotly库"
  },
  {
    "objectID": "pandas处理什么样的数据.html#数据建模和分析",
    "href": "pandas处理什么样的数据.html#数据建模和分析",
    "title": "7  pandas处理什么样的数据",
    "section": "数据建模和分析",
    "text": "数据建模和分析\nPandas还支持数据建模和分析的操作。你可以使用Pandas进行数据建模、特征工程、数据预处理等，然后将数据传递给机器学习库（如Scikit-learn）进行模型训练和预测。网上看到不错的数据预测案例"
  },
  {
    "objectID": "导入&导出数据.html",
    "href": "导入&导出数据.html",
    "title": "8  导入&导出数据",
    "section": "",
    "text": "读取本地数据\n获取数据data.csv下载地址，将csv文件下载到本地。\n\n\nCode\n# 导入pandas包\nimport pandas as pd\n\n# 注意csv文件路径\ndf = pd.read_csv('./example_data/data.csv') \n\n# 打印前五个\ndf.head()\n\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n\n\n\n\n\n\n\n读取线上数据\n线上数据地址\n\n\nCode\ndf = pd.read_csv('https://www.w3schools.com/python/pandas/data.csv.txt')\n\n# 打印前五个\ndf.head()\n\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n\n\n\n\n\n\n\nCode\n# 获取案例数据\nimport pandas as pd\ndf = pd.read_csv('https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/titanic.csv') \ndf.head()\n\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n\n\n\n\n\n\n\n\nPandas连接MySQL数据库导入导出数据\n\n步骤1：安装必要的库\n在开始之前，确保已经安装了以下库：\nPandas：用于数据处理和操作。\nSQLAlchemy：用于数据库连接和交互\n可以使用以下命令通过pip安装它们：\npip install pandas sqlalchemy\n\n\n步骤2：链接数据库\n首先，我们需要使用SQLAlchemy来建立与数据库的连接。根据使用的数据库类型（如MySQL、SQLite、PostgreSQL等），使用适当的连接字符串和数据库驱动程序。\n以下是使用SQLite数据库的示例代码：\n\n\nCode\nimport sqlalchemy\n\n# 建立与数据库的连接\nengine = sqlalchemy.create_engine('sqlite:///path/to/database.db')\n\n\n\n\n\n\n\n\nTip\n\n\n\n将path/to/database.db替换为实际的数据库文件路径或连接字符串\n\n\n\n\n步骤3：导入数据\n有几种方法可以使用Pandas从数据库中导入数据。最简单的方法是使用read_sql()函数，该函数接受一个SQL查询语句并将结果读取为DataFrame对象。\n以下是使用read_sql()函数导入数据的示例代码：\n\n\nCode\nimport pandas as pd\n\n# 执行SQL查询并将结果读取为DataFrame\nquery = 'SELECT * FROM table_name'\ndf = pd.read_sql(query, engine)\n\n# 打印DataFrame\nprint(df)\n\n\n\n\n\n\n\n\nTip\n\n\n\n将table_name替换为要查询的实际表名。\n\n\n\n\n步骤4：导出数据\n同样，使用Pandas可以将DataFrame中的数据导出到数据库中。可以使用to_sql()函数将DataFrame写入数据库表。\n以下是使用to_sql()函数导出数据的示例代码\n\n\nCode\n# 将DataFrame写入数据库表\ndf.to_sql('table_name', engine, if_exists='replace', index=False)\n\n\n\n\n\n\n\n\nTip\n\n\n\n将table_name替换为要写入的实际表名。if_exists=’replace’表示如果表已经存在，则替换它。index=False表示不将DataFrame的索引写入数据库。"
  },
  {
    "objectID": "选取数据.html#根据条件筛选行列",
    "href": "选取数据.html#根据条件筛选行列",
    "title": "9  选取数据",
    "section": "根据条件筛选行列",
    "text": "根据条件筛选行列\n假设我想知道十八岁以下的乘客信息\n\n\nCode\ndf[df[\"Age\"] &lt; 18].head()\n\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n7\n8\n0\n3\nPalsson, Master. Gosta Leonard\nmale\n2.0\n3\n1\n349909\n21.0750\nNaN\nS\n\n\n9\n10\n1\n2\nNasser, Mrs. Nicholas (Adele Achem)\nfemale\n14.0\n1\n0\n237736\n30.0708\nNaN\nC\n\n\n10\n11\n1\n3\nSandstrom, Miss. Marguerite Rut\nfemale\n4.0\n1\n1\nPP 9549\n16.7000\nG6\nS\n\n\n14\n15\n0\n3\nVestrom, Miss. Hulda Amanda Adolfina\nfemale\n14.0\n0\n0\n350406\n7.8542\nNaN\nS\n\n\n16\n17\n0\n3\nRice, Master. Eugene\nmale\n2.0\n4\n1\n382652\n29.1250\nNaN\nQ\n\n\n\n\n\n\n\nDataFrames 可以通过多种方式进行过滤，其中最直观的是使用布尔索引"
  },
  {
    "objectID": "添加新列.html#添加新列",
    "href": "添加新列.html#添加新列",
    "title": "10  增删排序(DataFrame)",
    "section": "添加新列",
    "text": "添加新列\n可以看到目前的案例中是四行三列，如果我想添加新的一列“薪资”，有两种方法：\n\n方法一： df[‘列名’] = 值\n\n\nCode\n\ndf['工资'] = [5000, 6000, '', 7000]\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n工资\n\n\n\n\n0\n张三\n25\nM\n5000\n\n\n1\n李四\n30\nF\n6000\n\n\n2\n王五\n35\nM\n\n\n\n3\n赵六\n28\nF\n7000\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n[值]必须对应行数，这里有四个人就必须有四个值，没有则可以为空白' ' 或者 'NA'；[]里面的顺序也会保持一样\n\n\n\n\n方法二：使用assign()\n\n\nCode\n\ndf = df.assign(工资=[5000, 6000, 4500, 7000])\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n工资\n\n\n\n\n0\n张三\n25\nM\n5000\n\n\n1\n李四\n30\nF\n6000\n\n\n2\n王五\n35\nM\n4500\n\n\n3\n赵六\n28\nF\n7000\n\n\n\n\n\n\n\n我们可以在原有表格中添加新列，也可以从其他数据源（如文件、数据库等）中导入数据，并将其作为新列添加到DataFrame中。"
  },
  {
    "objectID": "添加新列.html#添加新行",
    "href": "添加新列.html#添加新行",
    "title": "10  增删排序(DataFrame)",
    "section": "添加新行",
    "text": "添加新行\n\n方法一： 使用append方法\ndf = df.append(new_row, ignore_index=True)\n其中，new_row是一个包含新行数据的字典或Series对象。\n\n\nCode\n# 重新选取数据\ndata = {'姓名': ['张三', '李四', '王五', '赵六'],\n        '年龄': [25, 30, 35, 28],\n        '性别': ['M', 'F', 'M', 'F']}\n\ndf = pd.DataFrame(data)\n\n\n\n\nCode\n#`ignore_index=True`是确保新行的索引与原始DataFrame的索引保持一致。\n\nnew_row = {'姓名': '熊大', '年龄': 35, '性别': 'M'}\n\ndf = df.append(new_row, ignore_index=True)\ndf\n\n\n/var/folders/fx/3rtntmd93wg4hsmfkcgfpq840000gn/T/ipykernel_42888/3717194637.py:5: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(new_row, ignore_index=True)\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵六\n28\nF\n\n\n4\n熊大\n35\nM\n\n\n\n\n\n\n\n\n\n方法二：使用concat()\n先创建一个新的DataFrame，然后将其与原始DataFrame进行合并\n\n\nCode\nnew_row = {'姓名': '熊二', '年龄': 30, '性别': 'M'}\n\nnew_df = pd.DataFrame([new_row])\n\ndf = pd.concat([df, new_df], ignore_index=True)\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵六\n28\nF\n\n\n4\n熊大\n35\nM\n\n\n5\n熊二\n30\nM"
  },
  {
    "objectID": "添加新列.html#删除行列",
    "href": "添加新列.html#删除行列",
    "title": "10  增删排序(DataFrame)",
    "section": "删除行/列",
    "text": "删除行/列\n\n使用drop方法删除列\ndf = df.drop('column_name', axis=1)\n需要提供要删除的列名，然后指定axis=1表示按列进行操作。删除列后，DataFrame会自动调整列的顺序。\n\n\nCode\ndf = df.drop('性别', axis=1)\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵六\n28\n\n\n4\n熊大\n35\n\n\n5\n熊二\n30\n\n\n\n\n\n\n\n\n\n使用drop方法删除行\ndf = df.drop(row_index)\n使用drop方法根据行的索引来删除特定的行\n\n\nCode\n# 删除第五行数据\ndf = df.drop(5)\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵六\n28\n\n\n4\n熊大\n35"
  },
  {
    "objectID": "添加新列.html#重命名列",
    "href": "添加新列.html#重命名列",
    "title": "10  增删排序(DataFrame)",
    "section": "重命名列",
    "text": "重命名列\n\n使用rename方法：\ndf = df.rename(columns={'old_column_name': 'new_column_name'})\n其中，old_column_name是要重命名的旧列名，new_column_name是新的列名。\n\n\nCode\ndf = df.rename(columns={'姓名': '乘客id', '年龄':'乘客年龄'})\ndf\n\n\n\n\n\n\n\n\n\n乘客id\n乘客年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵六\n28\n\n\n4\n熊大\n35"
  },
  {
    "objectID": "添加新列.html#按值排序",
    "href": "添加新列.html#按值排序",
    "title": "10  增删排序(DataFrame)",
    "section": "按值排序",
    "text": "按值排序\n\n使用sort_values方法：\ndf = df.sort_values(by='column_name', ascending=True)\n其中，column_name是你想要按其值进行排序的列名。ascending=True表示按升序排序，若要按降序排序，将ascending设置为False。\n通过sort_values方法，你可以根据特定列的值对DataFrame进行排序。你可以选择按单个列的值排序，也可以按多个列的值排序，只需在by参数中提供相应的列名列表即可。\n\n\nCode\ndf = df.sort_values(by='乘客年龄', ascending=True)\ndf\n\n\n\n\n\n\n\n\n\n乘客id\n乘客年龄\n\n\n\n\n0\n张三\n25\n\n\n3\n赵六\n28\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n4\n熊大\n35"
  },
  {
    "objectID": "Pandas计算重塑合并最终版本.html",
    "href": "Pandas计算重塑合并最终版本.html",
    "title": "11  如何计算汇总统计",
    "section": "",
    "text": "describe()的用法\ndescribe() 是 Pandas 中一个常用的基础操作，用于生成关于 DataFrame 列的统计摘要。\n使用 describe() 方法，你可以获得以下统计信息：\n计数（count）：非缺失值的数量。\n均值（mean）：平均值。\n标准差（std）：标准差衡量数据的离散程度。\n最小值（min）和最大值（max）：数据列的最小和最大值。\n四分位数（25%，50%，75%）：数据的四个百分位数，用于描述数据的分布。\n示例代码：\n\nimport pandas as pd\n\n# 创建DataFrame示例\ndata = {'Name': ['John', 'Emma', 'Alex', 'Sophia', 'James'],\n        'Age': [25, 28, 22, 30, 32],\n        'Height': [175, 162, 180, 158, 170],\n        'Weight': [70, 58, 75, 52, 68]}\ndf = pd.DataFrame(data)\n\n# 查看数值型列的汇总统计\nsummary_stats = df.describe()\nmean_age = df['Age'].mean()\nmedian_height = df['Height'].median()\nmax_weight = df['Weight'].max()\n\nprint(summary_stats)\nprint(\"Mean Age:\", mean_age)\nprint(\"Median Height:\", median_height)\nprint(\"Max Weight:\", max_weight)\n\n             Age      Height     Weight\ncount   5.000000    5.000000   5.000000\nmean   27.400000  169.000000  64.600000\nstd     3.974921    9.055385   9.370165\nmin    22.000000  158.000000  52.000000\n25%    25.000000  162.000000  58.000000\n50%    28.000000  170.000000  68.000000\n75%    30.000000  175.000000  70.000000\nmax    32.000000  180.000000  75.000000\nMean Age: 27.4\nMedian Height: 170.0\nMax Weight: 75\n\n\n常用的计算汇总统计的方法：\n\ndescribe()方法：计算数值型列的基本统计信息，包括计数、均值、标准差、最小值、25%、50%和75%分位数以及最大值。\nmean()方法：计算数值型列的平均值。\nmedian()方法：计算数值型列的中位数。\nmin()方法：计算数值型列的最小值。\nmax()方法：计算数值型列的最大值。\nsum()方法：计算数值型列的总和。\ncount()方法：计算非缺失值的数量。\nstd()方法：计算数值型列的标准差。\nvar()方法：计算数值型列的方差。\n\n通过查看数值型列的汇总统计，可以快速了解数据的整体分布和统计特征，有助于进行数据分析和洞察。\n\n\nsize和count\n在Pandas中，size和count是用于计算分组数据的两个方法，常常与groupby一起使用。它们可以提供关于每个分组的计数信息，但在计算方式和返回结果上有一些区别。\nsize方法：\n\nsize方法用于计算每个分组中的元素数量，包括缺失值。\n返回的结果是一个Series，其索引是分组键，值是每个分组中的元素数量。\nsize方法不考虑缺失值，即使某个分组中存在缺失值，它也会将其计算为有效元素。\n\ncount方法：\n\ncount方法用于计算每个分组中非缺失值的数量。\n返回的结果是一个Series，其索引是分组键，值是每个分组中的非缺失值的数量。\ncount方法排除了缺失值，只计算非缺失值的数量。\n\n示例，演示如何使用size和count方法结合groupby对数据进行计数：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {'Group': ['A', 'A', 'B', 'B', 'B'],\n        'Value': [1, 2, 3, None, 5]}\ndf = pd.DataFrame(data)\n\n# 使用groupby和size计算每个分组的元素数量\nsize_result = df.groupby('Group').size()\n\n# 使用groupby和count计算每个分组的非缺失值数量\ncount_result = df.groupby('Group').count()\n\nprint(\"Size结果:\")\nprint(size_result)\nprint(\"\\nCount结果:\")\nprint(count_result)\n\nSize结果:\nGroup\nA    2\nB    3\ndtype: int64\n\nCount结果:\n       Value\nGroup       \nA          2\nB          2\n\n\n在上述示例中，我们创建了一个DataFrame，并使用Group列进行分组。然后，我们分别使用size和count方法对分组后的数据进行计数。可以看到，size方法返回了每个分组的元素数量，而count方法返回了每个分组的非缺失值数量。在分组B中，有一个缺失值，因此size方法返回3，而count方法返回2。\n这两个方法的使用可以根据具体需求来选择。如果需要考虑缺失值并计算所有元素的数量，可以使用size方法；如果只关心非缺失值的数量，可以使用count方法。\n\n\n如何重塑表格布局\n\nsort的用法\n在Pandas中，sort_values和sort_index是用于对DataFrame或Series进行排序的两个常用方法。\nsort_values方法：\n\nsort_values方法用于按照指定的列或多个列的值对DataFrame或Series进行排序。\n可以通过by参数指定要排序的列或多个列，以列表形式提供。\n可以使用ascending参数来控制排序的升序或降序，默认为True（升序）。\n可以使用inplace参数来指定是否原地修改DataFrame或Series，默认为False，即返回排序后的副本。\n示例：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [3, 2, 1], 'B': [1, 3, 2]})\nsorted_df = df.sort_values(by='A', ascending=True)\n\n\n上述代码将按照’A’列的值对DataFrame df 进行升序排序，并将结果存储在sorted_df中。\n\nsort_index方法：\n\nsort_index方法用于根据索引对DataFrame或Series进行排序。\n可以使用axis参数指定要排序的轴，axis=0表示按行索引排序，axis=1表示按列索引排序。\n可以使用ascending参数来控制排序的升序或降序，默认为True（升序）。\n可以使用inplace参数来指定是否原地修改DataFrame或Series，默认为False，即返回排序后的副本。\n示例：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [3, 2, 1], 'B': [1, 3, 2]}, index=[2, 1, 3])\nsorted_df = df.sort_index(axis=0, ascending=True)\n\n\n上述代码将按照行索引对DataFrame df 进行升序排序，并将结果存储在sorted_df中。\n\n排序操作可以根据具体需求来选择使用sort_values还是sort_index。如果希望根据列的值进行排序，使用sort_values方法；如果希望根据索引进行排序，使用sort_index方法。\n\n在Pandas中，可以使用不同的方法来重新塑造（reshape）表格布局，以满足特定的数据分析和处理需求。以下是一些常用的重塑表格布局的方法：\n\n\npivot()方法\npivot()方法：用于将长格式（long format）的数据转换为宽格式（wide format），根据指定的列创建新的列，并使用列值进行填充。\n示例，展示如何使用pivot()方法将数据从长格式转换为宽格式：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndata = {'Name': ['John', 'John', 'Emma', 'Emma', 'Alex', 'Alex'],\n        'Subject': ['Math', 'Science', 'Math', 'Science', 'Math', 'Science'],\n        'Score': [85, 92, 78, 88, 90, 85]}\ndf = pd.DataFrame(data)\n\n# 使用pivot方法重塑表格布局\npivot_df = df.pivot(index='Name', columns='Subject', values='Score')\npivot_df\n\n\n\n\n\n\n\nSubject\nMath\nScience\n\n\nName\n\n\n\n\n\n\nAlex\n90\n85\n\n\nEmma\n78\n88\n\n\nJohn\n85\n92\n\n\n\n\n\n\n\n\n\nmelt()方法\n在Pandas中，melt()是一个用于将宽格式（wide format）的数据转换为长格式（long format）的方法。它将数据从列中展开成为更长的格式，使得数据更适合进行分析和可视化。\nmelt()方法的语法如下：\nDataFrame.melt(id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None)\n参数说明：\n\nid_vars：可选参数，指定要保留的列名，不进行展开操作。\nvalue_vars：可选参数，指定要进行展开操作的列名。如果未指定，则默认展开所有未指定为id_vars的列。\nvar_name：可选参数，指定展开后的列名的名称。\nvalue_name：可选参数，指定展开后的值的列名的名称，默认为value。\ncol_level：可选参数，用于多层索引列的级别。\n\n下面是一个示例，演示如何使用melt()方法将宽格式的数据转换为长格式：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Math': [90, 80, 70],\n    'Science': [95, 85, 75],\n    'History': [92, 82, 72]\n}\ndf = pd.DataFrame(data)\n\n# 使用melt()方法进行数据转换\nmelted_df = df.melt(id_vars='Name', value_vars=['Math', 'Science', 'History'], var_name='Subject', value_name='Score')\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n转换后的DataFrame:\")\nmelted_df\n\n原始DataFrame:\n      Name  Math  Science  History\n0    Alice    90       95       92\n1      Bob    80       85       82\n2  Charlie    70       75       72\n\n转换后的DataFrame:\n\n\n\n\n\n\n\n\n\nName\nSubject\nScore\n\n\n\n\n0\nAlice\nMath\n90\n\n\n1\nBob\nMath\n80\n\n\n2\nCharlie\nMath\n70\n\n\n3\nAlice\nScience\n95\n\n\n4\nBob\nScience\n85\n\n\n5\nCharlie\nScience\n75\n\n\n6\nAlice\nHistory\n92\n\n\n7\nBob\nHistory\n82\n\n\n8\nCharlie\nHistory\n72\n\n\n\n\n\n\n\n\n\nstack()方法\nstack()方法：\n在Pandas中，stack()是一个用于对DataFrame进行堆叠操作的方法。它将列标签（Column labels）转换为行索引（Row index），将数据从宽格式转换为长格式，从而生成一个更紧凑的DataFrame。\nstack()方法的语法如下：\nDataFrame.stack(level=-1, dropna=True)\n参数说明：\n\nlevel：可选参数，用于多层索引列的级别。默认值为-1，表示堆叠所有列。\ndropna：可选参数，指定是否删除包含缺失值的行，默认为True。\n\n示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob'],\n    'Math': [90, 80],\n    'Science': [95, 85],\n    'History': [92, 82]\n}\ndf = pd.DataFrame(data)\n\n# 使用stack()方法进行堆叠操作\nstacked_df = df.set_index('Name').stack().reset_index()\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n堆叠后的DataFrame:\")\nstacked_df\n\n原始DataFrame:\n    Name  Math  Science  History\n0  Alice    90       95       92\n1    Bob    80       85       82\n\n堆叠后的DataFrame:\n\n\n\n\n\n\n\n\n\nName\nlevel_1\n0\n\n\n\n\n0\nAlice\nMath\n90\n\n\n1\nAlice\nScience\n95\n\n\n2\nAlice\nHistory\n92\n\n\n3\nBob\nMath\n80\n\n\n4\nBob\nScience\n85\n\n\n5\nBob\nHistory\n82\n\n\n\n\n\n\n\n\n\nunstack()方法\n在Pandas中，unstack()是用于将表格中的行索引转换为列索引，将数据从长格式转换为宽格式。\nunstack()方法的语法如下：\nDataFrame.unstack(level=-1, fill_value=None)\n参数说明：\n\nlevel：可选参数，用于指定要展开的层次化索引的级别。默认值为-1，表示展开最内层索引。\nfill_value：可选参数，用于指定填充缺失值的值。\n\n示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob'],\n    'Subject': ['Math', 'Science'],\n    'Score': [90, 80]\n}\ndf = pd.DataFrame(data)\n\n# 将DataFrame进行设置层次化索引\nindexed_df = df.set_index(['Name', 'Subject'])\n\n# 使用unstack()方法进行展开操作\nunstacked_df = indexed_df.unstack()\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n展开后的DataFrame:\")\nunstacked_df\n\n原始DataFrame:\n    Name  Subject  Score\n0  Alice     Math     90\n1    Bob  Science     80\n\n展开后的DataFrame:\n\n\n\n\n\n\n\n\n\nScore\n\n\nSubject\nMath\nScience\n\n\nName\n\n\n\n\n\n\nAlice\n90.0\nNaN\n\n\nBob\nNaN\n80.0\n\n\n\n\n\n\n\n在上述示例中，原始数据包含学生的姓名、科目和分数。通过使用pivot()方法，将姓名作为行索引，科目作为列索引，并将分数填充到相应的单元格中，得到了以学生姓名为行、科目为列的宽格式表格布局。\n\n\n\n如何合并多个表中的数据\n在Pandas中，可以使用不同的方法来合并（merge）多个表中的数据。以下是一些常用的合并数据的方法：\n\nconcat()方法\n在Pandas中，concat()是一个用于沿指定轴（行或列）将多个DataFrame对象进行合并的方法。它可以将多个DataFrame对象按照指定的方式进行连接，并返回一个合并后的DataFrame。以下是关于concat()方法的解释和示例说明：\nconcat()方法的语法如下：\npd.concat(objs, axis=0, join='outer', ignore_index=False)\n参数说明：\n\nobjs：要合并的DataFrame对象列表或字典。\naxis：可选参数，指定合并的轴。默认为0，表示按行合并；1表示按列合并。\njoin：可选参数，指定连接的方式。默认为'outer'，表示按照并集进行连接；'inner'表示按照交集进行连接。\nignore_index：可选参数，指定是否忽略合并后的索引。默认为False，表示保留原始索引。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ndf2 = pd.DataFrame({'A': [7, 8, 9], 'B': [10, 11, 12]})\n\n# 使用concat()方法进行合并操作\nmerged_df = pd.concat([df1, df2])\n\nprint(\"合并后的DataFrame:\")\nmerged_df\n\n合并后的DataFrame:\n\n\n\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\n1\n4\n\n\n1\n2\n5\n\n\n2\n3\n6\n\n\n0\n7\n10\n\n\n1\n8\n11\n\n\n2\n9\n12\n\n\n\n\n\n\n\n\n\nmerge()方法\n在Pandas中，merge()是一个用于合并（或连接）多个DataFrame对象的方法。它基于指定的键（或多个键）将多个DataFrame按照指定的方式进行连接，并返回一个合并后的DataFrame。\nmerge()方法的语法如下：\npd.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True)\n参数说明：\n\nleft：左侧的DataFrame对象。\nright：右侧的DataFrame对象。\nhow：可选参数，指定连接方式。默认为'inner'，表示按照键的交集进行连接；'outer'表示按照键的并集进行连接；'left'表示按照左侧DataFrame的键进行连接；'right'表示按照右侧DataFrame的键进行连接。\non：可选参数，用于指定连接的键。可以是一个列名的字符串，或多个列名组成的列表。\nleft_on：可选参数，用于指定左侧DataFrame连接键的列名或列名列表。\nright_on：可选参数，用于指定右侧DataFrame连接键的列名或列名列表。\nleft_index：可选参数，指定是否使用左侧DataFrame的索引作为连接键。\nright_index：可选参数，指定是否使用右侧DataFrame的索引作为连接键。\nsort：可选参数，指定是否按照连接键进行排序。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6], 'Key': ['K1', 'K2', 'K3']})\ndf2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12], 'Key': ['K2', 'K3', 'K4']})\n\n# 使用merge()方法进行合并操作\nmerged_df = pd.merge(df1, df2, on='Key')\n\nprint(\"合并后的DataFrame:\")\nmerged_df\n\n合并后的DataFrame:\n\n\n\n\n\n\n\n\n\nA\nB\nKey\nC\nD\n\n\n\n\n0\n2\n5\nK2\n7\n10\n\n\n1\n3\n6\nK3\n8\n11\n\n\n\n\n\n\n\n\n\njoin()方法\n在Pandas中，join()是一个用于基于索引或列之间的关系将两个DataFrame对象进行连接的方法。它类似于SQL中的JOIN操作，可以根据指定的连接键将两个DataFrame进行合并，并返回一个合并后的DataFrame。\njoin()方法的语法如下：\nDataFrame.join(other, on=None, how='left', lsuffix='', rsuffix='', sort=False)\n参数说明：\n\nother：要连接的另一个DataFrame对象。\non：可选参数，用于指定连接键。可以是一个列名的字符串，或多个列名组成的列表。如果未指定，则根据索引进行连接。\nhow：可选参数，指定连接方式。默认为'left'，表示按照左侧DataFrame的索引或列进行连接；'right'表示按照右侧DataFrame的索引或列进行连接；'inner'表示按照两个DataFrame共有的索引或列进行连接；'outer'表示按照两个DataFrame的并集进行连接。\nlsuffix：可选参数，用于处理连接时重叠列名的后缀（左侧DataFrame）。\nrsuffix：可选参数，用于处理连接时重叠列名的后缀（右侧DataFrame）。\nsort：可选参数，指定是否按照连接键进行排序。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}, index=['K1', 'K2', 'K3'])\ndf2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12]}, index=['K2', 'K3', 'K4'])\n\n# 使用join()方法进行连接操作\njoined_df = df1.join(df2)\n\nprint(\"连接后的DataFrame:\")\njoined_df\n\n连接后的DataFrame:\n\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nK1\n1\n4\nNaN\nNaN\n\n\nK2\n2\n5\n7.0\n10.0\n\n\nK3\n3\n6\n8.0\n11.0\n\n\n\n\n\n\n\n\n\n补充：T（Transpose）转置\n在Pandas中，T（Transpose）是一个用于转置数据的方法。转置操作会将DataFrame或Series的行和列进行交换，从而生成一个新的转置后的数据结构。以下是关于Pandas中的T转置的一些知识点：\n\nDataFrame的转置： 转置DataFrame时，行索引将会变成转置前的列索引，列索引将会变成转置前的行索引。可以使用T方法来执行转置操作，例如：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ntransposed_df = df.T\n\n上述代码将创建一个DataFrame df，然后使用T方法将其转置，结果将会存储在transposed_df中。\n\nSeries的转置： 转置一个Series对象会生成一个具有单一列的DataFrame，行索引将会保持不变，而列索引将会变为转置前的索引值。可以使用T方法对Series进行转置，例如：\n\n\nimport pandas as pd\n\nseries = pd.Series([1, 2, 3, 4], index=['A', 'B', 'C', 'D'])\ntransposed_series = series.T\n\n上述代码将创建一个Series series，然后使用T方法将其转置，结果将会存储在transposed_series中。\n\n转置对数据结构的影响： 转置操作不会改变原始数据结构，而是生成一个新的转置后的数据结构。原始数据结构保持不变，只是行和列的排列顺序发生了变化。\n转置的应用： 转置操作常用于需要改变数据结构的情况，例如在数据分析和处理过程中，可以使用转置来更改数据的布局以满足特定的分析需求。\n\n需要注意的是，转置操作可能会导致数据结构的变化，因此在进行转置操作之后，索引和列名可能需要进行调整以适应新的结构。"
  },
  {
    "objectID": "time_data.html",
    "href": "time_data.html",
    "title": "12  使用Pandas处理时间序列数据",
    "section": "",
    "text": "1. Pandas中的时间序列数据\nPandas中有6种关于时间序列数据的常见对象，分别是timestamp、datetimeindex、period、periodindex、以时间为元素的series和以时间索引的dataframe。\nPandas时序处理中最常见的两种数据类型为datetime和timedelta。\n\ndatetime\ndatetime即既有日期date，又有时间time的数据，表示一个具体的时间点（时间戳）。\ngraph TD;\ndatetime --&gt; date:2023-06-14;\ndatetime --&gt; time:12:00:00;\ntimedelta\ntimedelta表示两个时间点之差。如2023-01-01和2023-01-02之间的timedelta即为一天。\n\n\n\n2. 文本转换\n一般情况下，从.csv文件中导入的数据后，Dataframe中对应的时间列是字符串的形式，Pandas中提供了to_datetime()函数将字符串转换为datetime对象，并将其设置为Dataframe的索引。在Pandas中，这种类似于标准库中的日期时间对象称为：datetime64、datetime.datetime、pandas.Timestamp。\nimport pandas as pd\n\n# 创建包含字符串时间列数据的dataframe\ndata = {'date': ['20230601', '20230602', '20230603', '20230604']}\ndf = pd.DataFrame(data)\n# 展示dataframe\ndf\n# 输出结果为\n#          date\n# 0  20230601\n# 1  20230602\n# 2  20230603\n# 3  20230604\n# 将字符串时间列转换为datetime64格式的对象\ndf['date'] = pd.to_datetime(df['date'])\n\n# 打印转换后的结果\ndf\n\n# 输出结果为\n#         date\n# 0 2023-06-01\n# 1 2023-06-02\n# 2 2023-06-03\n# 3 2023-06-04\n将字符串数据转换为datetime64对象后，这些时间日期数据就具有了可比性，这样一来，我们就可以用它们来获取时间序列的长度。\n# 计算时间序列的长度\ntime_length = df['date'].max() - df['date'].min()\n\n# 打印时间序列的长度\nprint(\"时间序列的长度：\", time_length)\n\n# 输出结果为\n# 时间序列的长度： 3 days 00:00:00\n另外，我们还可以运用dt属性中的month函数来将月份信息提出出来，并将提取的结果赋值给新列。\n# 提取月份信息并形成新列\ndf['month'] = df['date'].dt.month\n\n# 打印DataFrame\nprint(df)\n\n# 输出结果为\n#         date  month\n# 0 2023-06-01      6\n# 1 2023-06-02      6\n# 2 2023-06-03      6\n# 3 2023-06-04      6\n\n\n2. Pandas中的时间日期索引\n在Pandas中，日期索引是一种特殊的索引类型，用于在时间序列数据中以日期或时间作为索引。日期索引在处理时间序列数据时非常有用，可以轻松地对数据进行切片、重采样和时间范围选择等操作。\nPandas提供了两种主要的日期索引类型：Timestamp和DatetimeIndex。\n\nTimestamp:\nTimestamp是Pandas中表示单个时间点的对象，可以使用pd.Timestamp()函数创建一个Timestamp对象，指定日期和时间。\npd.Timestamp('2023-06-17 10:30:00')\nDatetimeIndex:\nDatetimeIndex是一种由Timestamp对象构成的索引对象。可以使用pd.to_datetime()函数将日期时间字符串转换为DatetimeIndex对象。\npd.to_datetime(['2023-06-17', '2023-06-18', '2023-06-19'])\n\n使用日期索引可以实现以下功能：\n\n切片和选择：\n使用日期索引可以切片和选择时间序列数据。\n# 创建一个示例时间序列数据\ndata = {'日期': pd.date_range(start='2023-01-01', periods=10, freq='D'),\n        '销售量': [100, 150, 120, 200, 180, 160, 190, 210, 230, 250]}\ndf = pd.DataFrame(data)\n\n# 将日期列设置为索引\ndf.set_index('日期', inplace=True)\n\n# 选择特定日期范围的数据\nselected_data = df['2023-01-03':'2023-01-07']\nprint(selected_data)\n\n# 选择特定月份的数据\nselected_month = df['2023-02']\nprint(selected_month)\n\n# 使用布尔条件选择数据\nboolean_selection = df[df['销售量'] &gt; 200]\nprint(boolean_selection)\n重采样：\n重采样是指将时间序列数据从一个频率转换为另一个频率。使用日期索引，使用resample()方法可以对数据进行重采样，如按日、按周或按月重采样数据。\n# 按周重采样并计算平均值\nweekly_resampled = df.resample('W').mean()\nprint(weekly_resampled)\n\n# 按月重采样并计算总和\nmonthly_resampled = df.resample('M').sum()\nprint(monthly_resampled)\n时间范围生成：\nPandas提供了几个函数来生成一系列日期索引，如pd.date_range()和pd.period_range()。指定开始日期、结束日期和频率来生成日期范围，以便在创建时间序列数据时使用。\n# 生成一个包含5个连续日期的时间范围\ndate_range = pd.date_range(start='2023-01-01', periods=5, freq='D')\nprint(date_range)\n\n# 生成一个包含3个月份的时间范围\nmonth_range = pd.date_range(start='2023-01-01', periods=3, freq='M')\nprint(month_range)\n\n# 生成一个包含10个工作日的时间范围\nbusiness_days_range = pd.date_range(start='2023-01-01', periods=10, freq='B')\nprint(business_days_range)\n日期偏移：\nPandas提供了日期偏移功能，可以在日期上进行简单的数学运算。例如，您可以使用+或-操作符在日期索引上进行加减运算，例如df.index + pd.DateOffset(days=1)将日期索引向前偏移一天。\n# 创建一个日期索引\ndate_index = pd.date_range(start='2023-01-01', periods=5, freq='D')\n\n# 将日期索引向前偏移一天\nforward_offset = date_index + pd.DateOffset(days=1)\nprint(forward_offset)\n\n# 将日期索引向后偏移两天\nbackward_offset = date_index - pd.DateOffset(days=2)\nprint(backward_offset)\n\n# 将日期索引向前偏移一个月\nmonth_offset = date_index + pd.DateOffset(months=1)\nprint(month_offset)\n\n日期索引是Pandas中处理时间序列数据的重要工具之一，它提供了方便的方法来处理、分析和可视化时间相关的数据。使用日期索引，您可以更轻松地操作和探索时间序列数据。\n在Pandas中，.dt接口提供了许多常用的属性，用于处理日期和时间类型的Series数据。以下是一些常见的.dt接口属性的示例：\n\n\n\n\n\n\n\n属性\n描述\n\n\n\n\n.year\n返回日期的年份。\n\n\n.month\n返回日期的月份。\n\n\n.day\n返回日期的日。\n\n\n.hour\n返回时间的小时。\n\n\n.minute\n返回时间的分钟。\n\n\n.second\n返回时间的秒。\n\n\n.microsecond\n返回时间的微秒。\n\n\n.nanosecond\n返回时间的纳秒。\n\n\n.weekday\n返回日期对应的星期几（0代表星期一，6代表星期日）。\n\n\n.weekday_name\n返回日期对应的星期几的名称。\n\n\n.weekofyear\n返回日期所在年份的第几周。\n\n\n.quarter\n返回日期所属的季度。\n\n\n.is_month_start\n检查日期是否为月初。\n\n\n.is_month_end\n检查日期是否为月末。\n\n\n.is_quarter_start\n检查日期是否为季度初。\n\n\n.is_quarter_end\n检查日期是否为季度末。\n\n\n.is_year_start\n检查日期是否为年初。\n\n\n.is_year_end\n检查日期是否为年末。\n\n\n.is_leap_year\n检查日期是否为闰年。\n\n\n\n\n\n3. 重采样\n在 Pandas 中，重采样是指将时间序列数据从一个频率转换为另一个频率的过程。重采样可以帮助我们对时间序列数据进行聚合、降采样或升采样，以适应不同的分析需求。Pandas 提供了强大的重采样功能，可以根据日期和时间索引对时间序列数据进行灵活的重采样操作。\n重采样主要有两种类型：降采样（Downsampling）和升采样（Upsampling）。\n\n降采样：降采样是将时间序列数据从高频率转换为低频率。例如，从分钟数据转换为小时数据或从小时数据转换为每日数据。在降采样中，我们需要指定一个时间段，然后对该时间段内的数据进行聚合操作，例如求和、平均值、最大值、最小值等。\n示例代码：\npythonCopy code\ndf.resample('D').sum()  # 将数据按天进行降采样，并计算每天的总和\n升采样：升采样是将时间序列数据从低频率转换为高频率。例如，从每日数据转换为小时数据或从每月数据转换为每日数据。在升采样中，我们通常需要使用插值方法来填充新增的时间点，以估计缺失的数据。\n示例代码：\npythonCopy code\ndf.resample('H').ffill()  # 将数据按小时进行升采样，并使用向前填充方法插值数据\n\n在重采样过程中，我们需要使用 resample() 函数指定重采样的频率，例如 ‘D’ 表示按天重采样，‘H’ 表示按小时重采样。然后，我们可以对重采样对象应用聚合函数（例如 sum()、mean()、max()、min() 等）或插值函数（例如 ffill()、bfill() 等）来处理数据。"
  },
  {
    "objectID": "txt_data.html",
    "href": "txt_data.html",
    "title": "13  使用Pandas处理文本数据",
    "section": "",
    "text": "在Pandas中，文本的主要两个类型是string和object。如果不特殊指定类型为string，文本类型一般为object。\n在通过访问器str实现对文本的操作之前，需要注意：\n\n要确保访问的对象类型是字符串str类型，如果不是，需要使用astype(str)转换类型\n访问器只能对Series数据结构使用，可以多个连接使用。\n\n\n1. 文本格式：大小写变换\n在 Pandas 中，可以使用字符串方法 str.lower() 和 str.upper() 对文本数据进行大小写转换。这些方法可以应用于 Pandas 的 Series或DataFrame列中的文本数据，以将其转换为小写或大写形式。\nimport pandas as pd\n\n# 创建示例数据\ndata = {'text': ['Hello World', 'Welcome to Pandas', 'Text Processing']}\ndf = pd.DataFrame(data)\n\n# 字符全部变成小写\ndf['lowercase'] = df['text'].str.lower()\n\n# 字符全部变成大写\ndf['uppercase'] = df['text'].str.upper()\n\n# 每个单词首字母大写\ndf['titlecase'] = df['text'].str.title()\n\n# 字符串第一个字母大写，其余小写\ndf['capitalize'] = df['text'].str.capitalize()\n\n# 大小写字母转换\ndf['swapcase'] = df['text'].str.swapcase()\n\n# 打印处理后的数据集\nprint(df)\n\n\n2. 文本拆分\n在 Pandas 中，可以使用字符串方法 str.split() 对文本数据进行拆分。该方法可以将字符串按指定的分隔符拆分为多个部分，并返回一个包含拆分结果的 Series或DataFrame列。\n在对文本进行拆分时，可以使用expand参数将拆分出来的内容单独成列，使用n参数指定拆分的位置来控制形成几列。在对文本进行拆分以后，也可以使用get方法提取相关部分单独成列。\n# 使用方法\ns.str.split('x', expand=True, n=1)\n\n# 示例\n# 创建一个包含文本数据的 DataFrame\ndata = {'Text': ['Hello World', 'Python Programming', 'Data Science']}\ndf = pd.DataFrame(data)\n\n# 拆分文本并形成新列\ndf[['Word1', 'Word2']] = df['Text'].str.split(' ', expand=True)\n\nprint(df)\n\n# 输出结果\n#                 Text    Word1        Word2\n# 0        Hello World    Hello        World\n# 1  Python Programming   Python  Programming\n# 2       Data Science      Data      Science\n要进行更复杂的拆分可以借助正则表达式，如：\ns.str.split('\\@|\\.', expand=True, n=1)\n\n\n3. 文本包含\n在 Pandas 中，可以使用字符串方法 str.contains() 来判断文本数据是否包含指定的子串。这个方法返回一个布尔值的 Series或DataFrame列，用于表示每个元素是否包含指定的子串。，一般配合loc查询功能使用可搭配的参数有：\n\npat: 匹配字符串，支持正则表达式\ncase: 是否区分大小写，True表示区别\nflags: 正则库re中的标识，比如re.IGNORECASE\nna: 对缺失值填充\nregex: 是否支持正则，默认True支持\n\n# 使用方法\ns.str.contains(\"\")\n\n# 示例\n# 判断文本是否包含特定子串，并创建新列\ndf['Contains_Python'] = df['Text'].str.contains('Python')\n\nprint(df)\n\n# 输出结果\n#                 Text  Contains_Python\n# 0        Hello World            False\n# 1  Python Programming             True\n# 2       Data Science            False\n\n\n4. 文本格式：计数\n在 Pandas 中，可以使用字符串方法 str.count() 计算文本数据中指定子串的出现次数，同时可以使用字符串方法 str.len() 计量文本的长度。这两个方法可以方便地对文本数据进行计数和测量长度的操作。\n# 使用方法\ns.str.count('') # 字符串种包括指定字母的数量\ns.str.len() # 字符串长度\n\n# 示例\n# 计算指定子串的出现次数，并创建新列\ndf['Count_o'] = df['Text'].str.count('o')\n\n# 计量文本长度，并创建新列\ndf['Text_length'] = df['Text'].str.len()\n\nprint(df)\n\n# 输出结果\n#                 Text  Count_o  Text_length\n# 0        Hello World        2           11\n# 1  Python Programming        2           19\n# 2       Data Science        0           12\n\n\n5. 文本替换\n文本替换通常使用replace方法进行，可选参数如下：\n\npal：为被替代的内容字符串，也可以为正则表达式\nrepl：为新内容字符串，也可以是一个被调用的函数\nregex：用于设置是否支持正则，默认是True\n\n# 使用方法\ns.str.replace(\"s\":\"S\", \"f\":\"F\")\n\n# 示例\n# 将指定子串替换为新值，并创建新列\ndf['New_Text'] = df['Text'].str.replace('o', 'x')\n\nprint(df)\n\n# 输出结果\n#                 Text            New_Text\n# 0        Hello World        Hellx Wxrld\n# 1  Python Programming  Pythxn Prxgramming\n# 2       Data Science       Data Science"
  },
  {
    "objectID": "更好的数据可视化.html",
    "href": "更好的数据可视化.html",
    "title": "14  更好的数据可视化(Plotly)",
    "section": "",
    "text": "pip安装conda安装\n\n\n$ pip install plotly\n\n\n$ conda install -c plotly plotly\n\n\n\nplotly.express是plotly的简化包，只需要1～2行就可以生成可视化图表，大家可以滑动鼠标，获取相对应的数据。官方文档\n\n\nCode\nimport plotly.express as px\nfig = px.bar(x=[\"a\", \"b\", \"c\"], y=[6, 1, 8])\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "for循环.html#为什么需要使用for循环",
    "href": "for循环.html#为什么需要使用for循环",
    "title": "15  for循环自动获取股票数据",
    "section": "为什么需要使用for循环？",
    "text": "为什么需要使用for循环？\nfor循环简化了操作、处理大量数据，自动化了重复任务，并提供灵活的遍历顺序。它是一种强大的编程工具，帮助我们优化效率、减少冗余代码。无论初学者还是经验丰富的开发人员，for循环都是不可或缺的技术，提升代码质量、处理数据轻而易举。"
  },
  {
    "objectID": "for循环.html#案例背景",
    "href": "for循环.html#案例背景",
    "title": "15  for循环自动获取股票数据",
    "section": "案例背景",
    "text": "案例背景\n使用for循环调用股票API Tushare获取日线行情。但是有限制调用页数。尝试使用for循环遍历列表，逐个发送API请求获取每只股票的日线行情数据。"
  },
  {
    "objectID": "for循环.html#操作步骤",
    "href": "for循环.html#操作步骤",
    "title": "15  for循环自动获取股票数据",
    "section": "操作步骤",
    "text": "操作步骤\n\n通过def定义函数\nfor循环遍历整个日线行情\nconcat合并上下表"
  },
  {
    "objectID": "python链接数据库.html#为什么要用sqlalchemy连接数据库",
    "href": "python链接数据库.html#为什么要用sqlalchemy连接数据库",
    "title": "16  Python连接Postgresql数据库",
    "section": "为什么要用SQLAlchemy连接数据库？",
    "text": "为什么要用SQLAlchemy连接数据库？\n在企业中，很多数据都存储在数据库当中，通过SQLAlchemy，可以轻松连接多种数据库，包括MySQL、PostgreSQL、SQLite等，并使用统一的API进行数据库操作。SQLAlchemy提供了高级的对象关系映射（ORM）功能，使数据库操作更加面向对象，简化了数据模型的开发和管理。它提供了查询构建器、事务管理、数据迁移等功能，提高了开发效率。"
  },
  {
    "objectID": "python链接数据库.html#所需环境和拓展包",
    "href": "python链接数据库.html#所需环境和拓展包",
    "title": "16  Python连接Postgresql数据库",
    "section": "所需环境和拓展包",
    "text": "所需环境和拓展包\n\njupyternotebook – 撰写python代码\nPostgreSQL & Pgadmin4 – 数据库及其GUI工具（数据库客户端）\nSQLAlchemy – python拓展包，用来连接数据库"
  },
  {
    "objectID": "python链接数据库.html#操作步骤",
    "href": "python链接数据库.html#操作步骤",
    "title": "16  Python连接Postgresql数据库",
    "section": "操作步骤",
    "text": "操作步骤\n\nDocker安装jupyternotebook & Postgresql数据库\n本地数据库备份&迁移\n安装和使用SqlAlechemy"
  },
  {
    "objectID": "Dash案例.html#为什么要使用dash",
    "href": "Dash案例.html#为什么要使用dash",
    "title": "17  Dash创建股票APP",
    "section": "为什么要使用Dash",
    "text": "为什么要使用Dash\nDash Plotly是一个基于Python的开源框架，用于构建交互式数据可视化和分析应用。\n它的优势在于简洁的语法、强大的可视化功能和灵活的布局选项。通过使用Dash Plotly，您可以轻松创建漂亮、交互式的应用程序，展示和探索数据，无论是用于内部报告、数据分析还是对外展示。它提供了丰富的图表类型、注解和样式设置，以及与其他Python库的无缝集成，如pandas和numpy。Dash Plotly还支持部署到Web服务器上，使得应用程序能够通过浏览器进行访问和共享。\n总的来说，Dash Plotly提供了一种简单而强大的方式来创建数据驱动的应用程序，使得数据可视化和交互变得更加容易和高效。"
  },
  {
    "objectID": "Dash案例.html#案例背景",
    "href": "Dash案例.html#案例背景",
    "title": "17  Dash创建股票APP",
    "section": "案例背景",
    "text": "案例背景\n使用Dash 模仿复现股票走势的交互可视化面板，可以查看股票日线级别的涨跌幅度、股票走势和买入卖出盈亏比。以英伟达股票为案例"
  },
  {
    "objectID": "Dash案例.html#相关链接",
    "href": "Dash案例.html#相关链接",
    "title": "17  Dash创建股票APP",
    "section": "相关链接",
    "text": "相关链接\n免费股票数据API\nGitHub Python调用API\n模仿案例网站"
  },
  {
    "objectID": "Dash案例.html#dash股票案例上集",
    "href": "Dash案例.html#dash股票案例上集",
    "title": "17  Dash创建股票APP",
    "section": "Dash股票案例（上集）",
    "text": "Dash股票案例（上集）\n\nAPI获取&调用\npands数据清洗\n导出csv到本地\nDash-Bootstrap主题\nDash-layout排版\nDash-调整位置和宽度"
  },
  {
    "objectID": "Dash案例.html#dash股票案例下集",
    "href": "Dash案例.html#dash股票案例下集",
    "title": "17  Dash创建股票APP",
    "section": "Dash股票案例（下集）",
    "text": "Dash股票案例（下集）\n\napp功能：涨跌百分比\npadnas数据清洗&过滤\nplotly绘制百分比图\napp功能：股票走势图\nupdate_traces VS update_layout\napp功能：滚动数据\nBootstrap组件使用"
  }
]