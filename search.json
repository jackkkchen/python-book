[
  {
    "objectID": "index.html#文档目录",
    "href": "index.html#文档目录",
    "title": "Python新手文档",
    "section": "文档目录",
    "text": "文档目录\n\nPython简介\n\nPython的特点和应用领域\n安装Python和开发环境\nPython基础知识\n\n\n\n数据类型和变量\n\n运算符和表达式\n条件语句和循环\n函数和模块\n数据处理与分析入门\n\n\n\nPandas 基本操作\n\nPandas库介绍和安装\nPandas处理什么样的数据\n读取和写入\n选取和筛选\n增删和排序\n分组和聚合\n处理时间序列数据\n处理文本数据\n数据可视化\n\n\n\nPandas 实际应用案例\n\n从实际数据集中读取数据\n数据清洗和预处理\nPlotly可视化展示\nDash应用程序展示\n扩展学习资源\n\n\n\n推荐的Pandas学习资源\n\npandas官方文档(自译版)\nPandas对比SQL\nPlotly可视化官方文档\nW3schools for Pandas\n JackB站超级多的视频"
  },
  {
    "objectID": "index.html#结语",
    "href": "index.html#结语",
    "title": "Python新手文档",
    "section": "结语",
    "text": "结语\n通过本文的学习，你将建立起对Python编程语言的基本理解，掌握Pandas库进行数据处理和分析的技能。无论你是想进入数据科学领域、进行数据挖掘，还是对数据处理和分析有兴趣，Python和Pandas都是你的理想选择。开始你的编程之旅吧，让Python和Pandas帮助你实现数据的无限可能！\n\n\n\n\n\n\nNote\n\n\n\n本文档主要针对编程小白，将以简洁易懂的语言和实例进行解释。每个主题都会提供充足的示例代码和实践案例，以便读者能够实际运用所学知识。在学习过程中，不断实践和探索将是提高编程能力的关键，鼓励读者积极动手并勇于尝试。"
  },
  {
    "objectID": "intro.html#主要特点",
    "href": "intro.html#主要特点",
    "title": "Python简介",
    "section": "主要特点",
    "text": "主要特点\nPython是一种高级编程语言，以其简洁、易读、易学和灵活性而受到广泛欢迎。以下是Python的一些主要特点：\n\n简洁易读：Python采用清晰简洁的语法，使得代码易于阅读和理解。它使用缩进来表示代码块，而不是使用大括号，这使得代码更加易读。\n易学性：Python的语法简单明了，相对于其他编程语言来说，学习曲线较低。这使得初学者能够快速入门并开始编写实用的程序。\n跨平台性：Python可以在多个操作系统上运行，包括Windows、macOS和各种Linux发行版。这意味着开发人员可以在不同的平台上编写一次代码，并在不同的环境中运行。\n大量的库和框架：Python拥有庞大且活跃的社区，为各种用途提供了大量的库和框架。这些库和框架使得开发人员能够快速构建各种应用，例如Web应用、科学计算、数据分析和人工智能等。\n可扩展性：Python可以与其他语言（如C/C++和Java）轻松集成，这使得开发人员能够使用现有的代码库和资源，以提高应用程序的性能和功能。"
  },
  {
    "objectID": "intro.html#应用领域",
    "href": "intro.html#应用领域",
    "title": "Python简介",
    "section": "应用领域",
    "text": "应用领域\nPython具有广泛的应用领域，从Web开发到科学计算和人工智能等各种领域都能发挥其优势。它的简洁性和强大的库生态系统使得开发人员能够快速构建各种类型的应用程序。\n\nWeb开发：Python的Web框架（如Django和Flask）使得构建功能强大的Web应用程序变得简单。Python还可以用于服务器端编程、网页爬虫和API开发等。\n数据科学和机器学习：Python在数据科学和机器学习领域非常受欢迎。它提供了许多用于数据处理、数据可视化和机器学习算法的库，如NumPy、Pandas、Matplotlib、Scikit-learn和TensorFlow等。\n科学计算：Python在科学计算领域也得到广泛应用。科学计算库如NumPy和SciPy提供了许多数值计算、优化和统计分析的功能，适用于物理学、数学、生物学等领域。\n自动化和脚本编写：Python的简洁性和易用性使得它成为自动化任务和脚本编写的理想选择。可以使用Python编写脚本来自动执行重复性的任务、处理文件、操作系统和网络等。\n游戏开发：Python也可以用于游戏开发。有一些专门的库和框架，如Pygame，使得使用Python编写2D游戏变得相对容易。"
  },
  {
    "objectID": "周一环境搭建.html#anaconda环境安装强烈推荐",
    "href": "周一环境搭建.html#anaconda环境安装强烈推荐",
    "title": "1  Python环境搭建",
    "section": "Anaconda环境安装（强烈推荐）",
    "text": "Anaconda环境安装（强烈推荐）\n强烈推荐小白使用Anaconda平台学习Python。\nAnaconda提供了简化环境配置、跨平台支持、库和工具管理以及丰富的科学计算库等优势，使得小白学习Python更加便捷和高效。它是一个功能强大且易于使用的平台，可以帮助您快速入门Python编程并进行数据处理和分析。\n官方免费提供在线编辑器-jupyterlab 无需手动安装环境，即可直接上手编写代码。\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAnaconda的安装路径和用户名最好使用英文"
  },
  {
    "objectID": "周一环境搭建.html#plotly",
    "href": "周一环境搭建.html#plotly",
    "title": "1  Python环境搭建",
    "section": "Plotly",
    "text": "Plotly\nPlotly是一种用于创建交互式可视化的开源Python图形库，它提供了丰富的图表类型和功能，可以生成高质量、可交互的图形，用于数据分析和呈现。 Plotly支持的图表类型有很多，包括我们常用的散点图、线图、条形图、面积图、箱线图等等。在使用Plotly的过程中，我们可以通过选择合适的图表类型进行数据可视化。另外，Plotly提供了强大的交互式功能，用户可以通过鼠标交互、缩放、平移等操作来和图标进行交互。同时，我们还可以通过添加悬停提示信息、点击事件和自定义工具栏等交互元素，增强用户体验。 由于Plotly可以和Python中的各种数据分析和科学计算库(如NumPy、Pandas等)无缝集成，因此，在使用Python进行数据可视化工作的进程中，Plotly可以很好地帮助到我们。\n在后面的课程中，我们会详细介绍Plotly的相关内容，现在，让我们一起来看看Plotly可以实现的效果吧。\n\n使用conda安装Plotly\n如果你的电脑上安装了Anaconda，那么我们可以使用conda来安装Plotly。打开终端或者Jupyter文件，输入以下代码\nconda install -c plotly plotly\n这将从Anaconda的默认渠道安装Plotly。\n\n\n使用pip安装Plotly\n如果您的电脑上没有安装Anaconda，您也可以使用pip来安装Plotly。打开终端以后，输入以下代码\npip install plotly\n\n\n验证安装\n安装完成以后，可以使用以下命令来验证是否成功安装了Plotly\npip show plotly\n如果成功安装，这行代码将为我们显示Plotly的版本号。 在安装完成以后，您就可以在Python中使用Plotly来创建交互式可视化图表了。另外，在使用Plotly时，通常还需要安装Pandas或numpy，我们将在后面的章节中带领您安装。\nplotly.express官方介绍可以先本地尝试下官方给的案例～\n\n\n1. Lines on Maps\n\n\n\n\n\n\nWarning\n\n\n\nplotly在本地运行无法显示图片的话，可以尝试直接使用fig.show()，去掉renderer=\"notebook\"\n\n\n\nimport plotly.express as px\ndf = px.data.gapminder().query(\"year == 2007\")\nfig = px.line_geo(df, locations=\"iso_alpha\",\n                  color=\"continent\", # \"continent\" is one of the columns of gapminder\n                  projection=\"orthographic\")\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\n2. Funnel Chart\n\nfrom plotly import graph_objects as go\n\nfig = go.Figure(go.Funnel(\n    y = [\"Website visit\", \"Downloads\", \"Potential customers\", \"Requested price\", \"Finalized\"],\n    x = [39, 27.4, 20.6, 11, 2],\n    textposition = \"inside\",\n    textinfo = \"value+percent initial\",\n    opacity = 0.65, marker = {\"color\": [\"deepskyblue\", \"lightsalmon\", \"tan\", \"teal\", \"silver\"],\n    \"line\": {\"width\": [4, 2, 2, 3, 1, 1], \"color\": [\"wheat\", \"wheat\", \"blue\", \"wheat\", \"wheat\"]}},\n    connector = {\"line\": {\"color\": \"royalblue\", \"dash\": \"dot\", \"width\": 3}})\n    )\n\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\n3. Scatter Plots\n\nimport plotly.express as px\n\ndf = px.data.iris()\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", color='petal_length')\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "周一基础语法.html#如何使用python",
    "href": "周一基础语法.html#如何使用python",
    "title": "2  Python基础语法",
    "section": "如何使用Python",
    "text": "如何使用Python\n\n运行python文件\n\n\n\n\nPython文件的后缀为 .py\n\n\n\n在代码编辑器中输入python指令\n比如在jupyterlab，在终端或者vscode中输入代码\n如图，Shift + Enter执行代码块\n\n\n\n\n\n\n\nNote\n\n\n\n在终端中，输入python进入python解释器后，即可运行python代码\n\n\n\n\n如何运行ipynb文件\n\n从微信中下载每日作业\n使用JupyterLab打开文件\n\n\n\n\n\n我们可以写一个简单的表达式，在编程中，表达式是一段产生值的代码，类似计算机功能，例如\n\n2023 + 4090\n\n6113\n\n\n除了输出值外，还有另外一种表达式，比如查看是否 9 大于 1？\n\n9 &gt; 1\n\nTrue\n\n\n上面这个表达式对9和1的大小进行了判断。因为9 &gt; 1，所以，程序返回了True；反之，如果我们编写1 &gt; 9，则会返回False。在这里，True和False统称为布尔值，在之后的数据类型课程中，我们会详细地对其进行介绍。\n写代码总少不了报错。假如我的是空值呢？\n\n9 &gt; \n\nSyntaxError: invalid syntax (1639543893.py, line 1)\n\n\n我们进行了一个比较运算，但是只填入了一个值。这时 程序就报错了。终端里显示我们的代码出现了一个语法错误，报错提示中的SyntaxError在编程中代表着语法错误。就像自然语言中的语法一样，Python作为一门编程语言，也具有自己的语法。在接下来的日子里，我们会带你详细学习。"
  },
  {
    "objectID": "周一基础语法.html#变量赋值",
    "href": "周一基础语法.html#变量赋值",
    "title": "2  Python基础语法",
    "section": "变量赋值",
    "text": "变量赋值\n在Python中，变量用于存储和表示数据。变量赋值是将一个值与一个变量关联起来的过程。通过变量，我们可以在程序中存储和操作数据。\n\n变量的命名规则\n在Python中，变量的命名需要遵循以下规则：\n\n变量名只能包含字母（大小写敏感）、数字和下划线（_）。\n变量名不能以数字开头。\n变量名不能使用Python关键字和保留字，如if、for、while等。\n变量名应具有描述性，能够清晰地表示变量的含义。\n\n\n\n变量的赋值\n在Python中，使用等号（=）进行变量赋值操作。等号 ( = ) 运算符左边是一个变量名,等号 ( = ) 运算符右边是存储在变量中的值\n\n\n\n\n下面是一个例子，将数字5赋值给变量x：\n\nx = 5\n\n\n\n变量的使用\n一旦变量被赋值，我们可以在程序中使用它来表示和操作存储的值。\n下面是一个例子，使用变量x计算其平方并打印结果：\n\nx = 5\nsquare = x * x\nprint(square)\n\n25\n\n\n\n\n变量的重新赋值\n在程序中，我们可以多次为同一个变量赋值，新的赋值将覆盖之前的值。\n下面是一个例子，演示变量的重新赋值：\n\nx = 5\nprint(x)  # 输出：5\n\nx = 10\nprint(x)  # 输出：10\n\n题型一\n将字符串”Hello, Python!“赋值给变量message，然后打印出变量的值。\n\nmessage = \"Hello, Python!\"\nprint(message)\n\nHello, Python!\n\n\n题型二 将变量的值用于字符串拼接，使用input()函数接收输入值，然后使用f string，将这变量的值拼接到一句话中。最后，通过print()函数将句子打印输出。\nf string的用法是，在字符串中，需要引入变量值的位置写上一对大括号，将要引入的变量名放在打括号中，用法举例：\n\n# 用户输入姓名和年龄\nname = input(\"请输入您的姓名：\")\nage = input(\"请输入您的年龄：\")\n\n# 创建自我介绍的句子并打印输出\nintroduction = f\"我的名字是{name}，今年{age}岁。\"\nprint(introduction)\n\n我的名字是Jack，今年18岁。\n\n\n另外一种字符串的格式化方式\nf string 和 .format是两种不同的格式化字符串的方法\n.format的用法是在字符串中使用大括号占位，然后使用.format给出要填进去的变量，默认按照顺序填入，如果需要乱序或者一个变量使用多次，需要在大括号中给出后面format变量的序号，举例：\n\nname1 = \"apple\"\nname2 = \"orange\"\nprint(\"I hava a {} and {}.\".format(name1,name2))\n\nprint(\"I hava a {}, {} and {}.\".format(name1,name1,name2))\n\nI hava a apple and orange.\nI hava a apple, apple and orange."
  },
  {
    "objectID": "周一基础语法.html#注释",
    "href": "周一基础语法.html#注释",
    "title": "2  Python基础语法",
    "section": "注释",
    "text": "注释\n在Python中，注释用于对代码进行解释和说明，对于其他人（包括自己）来理解代码的作用和意图非常有帮助。注释是在代码中添加的文本，Python解释器会忽略它们。\n\n单行注释\n在Python中，使用#符号开始的文本被视为单行注释。在#后面的所有内容都被视为注释，不会被执行。\n下面是一个例子，演示如何使用单行注释：\n\n# 这是一个单行注释\nprint(\"Hello, World!\")  # 打印输出文本\n\nHello, World!\n\n\n上述代码中，第一行是一个注释，用于对代码的目的进行解释。第二行是打印输出语句，不受注释的影响。\n\n\n多行注释\n在Python中，使用三个引号（双引号或单引号都可以）包围的文本被视为多行注释。多行注释可以跨越多行，并且可以包含多个段落。\n下面是一个例子，演示如何使用多行注释：\n\n\"\"\"\n这是一个多行注释的示例。\n它可以跨越多行，并且可以包含多个段落。\n\n以下是代码的主要功能：\n- 输入用户的姓名\n- 打印欢迎消息和姓名\n\"\"\"\n\nname = input(\"请输入您的姓名：\")\nprint(\"欢迎，\" + name + \"!\")\n\n欢迎，jack!\n\n\n\n\n\n\n\n\nNote\n\n\n\n如果想一次性注释多行的话，鼠标选取后，按ctl+/进行注释"
  },
  {
    "objectID": "周一基础语法.html#行和缩进",
    "href": "周一基础语法.html#行和缩进",
    "title": "2  Python基础语法",
    "section": "行和缩进",
    "text": "行和缩进\n在Python中，行用于分隔不同的代码语句，而缩进用于表示代码块（例如条件语句、循环等）的范围。\n\n行\n每一行都包含一个完整的代码语句或表达式。下面是一个例子：\n\nprint(\"Hello, world!\")\n\nHello, world!\n\n\n上述代码中，print(“Hello, world!”)是一行代码，用于输出字符串”Hello, world!“。\n\n\n缩进\n在Python中，缩进通过空格或制表符来实现，用于表示代码块的开始和结束。通常使用4个空格作为标准缩进。\n\n\n\n\n\n\nWarning\n\n\n\n缩进造成的错误，应该名列 Python 错误榜第一\n\n\n下面是一个例子，演示如何在代码块中使用缩进：\n\n if x&gt;0:\n    print(\"x是正数\")\n    print(\"干得漂亮！\")\nelse:\n    print (\"x是负数\")\n    print (\"可惜哇嗷！\") \n\nx是正数\n干得漂亮！\n\n\n上述代码中，if语句和else语句是两个代码块，它们的范围由缩进表示。在if代码块中，两个print语句都会在条件满足时执行。在else代码块中，同样有两个print语句。（大家可以自己修改下x范围）\n\n\n\n\n\n\nNote\n\n\n\n养成良好编码习惯：\n\n保持一致的缩进：使用相同数量的空格或制表符进行缩进，并在整个代码中保持一致。这有助于提高代码的可读性；\n使用合适的缩进级别：根据代码逻辑嵌套关系，选择适当的缩进级别。通常建议每个缩进级别使用4个空格；\n使用注释：在关键地方添加注释，解释代码的目的和功能。注释可以提高代码的可读性和可维护性；\n注意行的长度：尽量将每行代码控制在适当的长度范围内，通常推荐不超过80个字符。可以使用换行符（）或括号来换行。\n\n\n\n\n\n多行语句\n\n使用反斜杠\n使用反斜杠（\\）将一行代码分成多行。下面是一个例子：\n\ntotal = 1 + \\\n        2 * \\\n        3\nprint(total)\n\n7\n\n\n上述代码中，total变量的值是1+2*3，通过使用反斜杠在多行中编写，使代码更易读。\n\n\n使用括号\n另一种方式是使用括号（圆括号、方括号、花括号）来隔行编写多行语句。下面是一个例子：\n\ntotal = (1 +\n         2 *\n         3)\nprint(total)\n\n7"
  },
  {
    "objectID": "周二数据类型.html#数据类型",
    "href": "周二数据类型.html#数据类型",
    "title": "3  Python数据类型",
    "section": "数据类型",
    "text": "数据类型\n在Python中，有多种内置的数据类型，每种类型都用于存储不同类型的数据。了解和正确使用这些数据类型对于编写有效的Python代码非常重要。\nPython有以下基本数据类型：\n\n整数（int）：如 1, 2, 3\n浮点数（float）：如 1.5, 3.14\n字符串（str）：如 “hello” 或者 ‘world !’\n布尔值（bool）：True, False\n\n\n\n\n\n\n\nNote\n\n\n\n使用 type() 函数来查看数据结构的类型\n\n\n\n数字类型\n数字类型用于表示数值数据，包括整数（int）和浮点数（float）。\n下面是一个例子，演示如何使用数字类型：\n\n# 整数类型（没有小数点的数字）\nnum1 = 10\nprint(num1) \n\n10\n\n\n\ntype(num1)\n\nint\n\n\n\n# 浮点数类型（带小数点的数字）\nnum2 = 3.14\nprint(num2)  \n\n3.14\n\n\n\n\n字符串类型\n字符串类型用于表示文本数据，使用引号（单引号或双引号）括起来。\n下面是一个例子，演示如何使用字符串类型：\n\nintro = \"你好，我叫 Jack !\"\nprint(intro)  \n\n你好，我叫 Jack !\n\n\n\n\n布尔类型\n布尔类型用于表示真（True）和假（False）的值。\n下面是一个例子，演示如何使用布尔类型：\n\nis_active = True\nprint(is_active)  \n\nTrue\n\n\n\nis_student = False\nprint(is_student) \n\nFalse"
  },
  {
    "objectID": "周二数据类型.html#运算符",
    "href": "周二数据类型.html#运算符",
    "title": "3  Python数据类型",
    "section": "运算符",
    "text": "运算符\n当提到Python的运算符，可以包括算术运算符、赋值运算符、比较运算符、逻辑运算符和位运算符等。下面是一些常见的运算符示例及其解析：\n\n算术运算符\n比较常见的算术运算符，也就是加减乘除这些。\n\n\n\n运算符\n描述\n举例\n\n\n\n\nx+y\n加\n1+2=3\n\n\nx-y\n减\n6-5=1\n\n\nx*y\n乘\n2*3=6\n\n\nx/y\n除\n2/4=0.5\n\n\nx//y\n整除，取整数部分\n2//4=0\n\n\nx%y\n取余\n15%4=3\n\n\n**\n幂运算\n2**3=8 二的三次方\n\n\n\n\na = 10\nb = 3\n\n# 加法\nresult = a + b * (a // b) \nprint(result)  \n\n19\n\n\n\n\n赋值运算符\n在加减乘除的基础上直接进行赋值计算，不需要新的变量\n\n\n\n运算符\n描述\n举例\n\n\n\n\n=\n赋值\nx = 5\n\n\n+=\n加等\nx += 3\n\n\n-=\n减等\nx -= 3\n\n\n*=\n乘等\nx *= 3\n\n\n%=\n余等\nx %= 3\n\n\n/=\n除等\nx /= 3\n\n\n//=\n取整等\nx //= 3\n\n\n**=\n幂等\nx **= 3\n\n\n\n\na = 10\nb = 3\n\n# 加法赋值\na += b \nprint(a)  \n\n13\n\n\n\n\n比较运算符（控制结构判断）\n输出为布尔值\n\n\n\n运算符\n描述\n\n\n\n\n&lt;\n小于\n\n\n&lt;=\n小于等于\n\n\n&gt;\n大于\n\n\n&gt;=\n大于等于\n\n\n==\n等于\n\n\n!=\n不等于\n\n\n\n\na = 10\nb = 3\n\n# 相等比较\nresult = a == b\nprint(result)  \n\nFalse\n\n\n\n\n标识运算符\n标识运算符用于比较对象，不是比较它们是否相等，而是比较它们是否实际上是相同的对象，具有相同的内存位置：\n\n\n\n运算符\n描述\n举例\n\n\n\n\nis\n判断两个标识符是不是引用自一个对象\nx is y\n\n\nis not\n判断两个标识符是不是引用自不同对象\nx is not y\n\n\n\n\n\n逻辑运算符\n逻辑运算符用于在布尔表达式中组合和比较逻辑条件。Python中的逻辑运算符包括以下三种：and（与）、or（或）和not（非）。\n\n\n\n\n\n\n\n\n运算符\n描述\n备注\n\n\n\n\nx and y\n如果两个声明都是真的，则返回True\nxy都为True,结果为True；否则为False\n\n\nx or y\n如果其中一个语句为真，则返回真\nxy都为False,结果为False；否则为True\n\n\nnot x\n反转结果，如果结果为真，则返回False\nx为True时，值为False；x为False时，值为True\n\n\n\n\n逻辑 与（and）运算符：\n逻辑与运算符返回两个操作数都为True时的结果为True，否则返回False。\n\nx = True\ny = False\n\n# 与运算\nresult = x and y\nprint(result)\n\nFalse\n\n\n这里可能比较难理解，在上面的示例中，x的值为True，y的值为False。当使用逻辑与运算符（and）将x和y进行运算时，由于y为False，所以结果为False。如果x和y都为True，则结果为True。\n\n\n逻辑或（or）运算符\n逻辑或运算符返回两个操作数中至少一个为True时的结果为True，只有当两个操作数都为False时结果才为False。\n\na = True\nb = False\n\nresult = a or b\nprint(result)  \n\nTrue\n\n\n\n\n逻辑非（not）运算符\n逻辑非运算符将操作数的值取反，如果操作数为True，则结果为False；如果操作数为False，则结果为True。\n\na = True\n\nresult = not a\nprint(result) \n\nFalse"
  },
  {
    "objectID": "周二数据类型.html#数据结构",
    "href": "周二数据类型.html#数据结构",
    "title": "3  Python数据类型",
    "section": "数据结构",
    "text": "数据结构\nPython中有多种常用的数据结构，包括列表（List）、元组（Tuple）和字典（Dictionary）\n\n列表是一个有序且可变的集合。允许重复的值。\n元组是一个有序且不可更改的集合。允许重复的值。\n字典是一个有序的、可变的集合。不允许重复的值。\n\n\n列表(List)\nlist是Python中最常用的数据结构之一，用于存储一组有序的元素。列表中的元素可以是不同类型的对象，可以进行增删改查等操作。\n\n\n创建列表\n列表可以使用方括号[]来创建，其中每个元素用逗号分隔。例如：\n\n水果 = ['苹果', '菠萝', '榴莲']\nprint(水果)\n\n['苹果', '菠萝', '榴莲']\n\n\n\n\n访问列表元素\n列表中的元素可以通过索引访问，索引从0开始。例如，要访问列表中的第一个元素，可以使用fruits[0]。可以使用负数索引从列表末尾开始访问元素。例如，fruits[-1]表示访问最后一个元素。\n\n# python中顺序需要向前递减一位，所以索引 0 代表第一个， -1 代表最后一个\nprint(水果[0]) \nprint(水果[-1])\n\n苹果\n榴莲\n\n\n\n\n修改列表元素\n列表中的元素可以通过索引进行修改。可以使用赋值语句将新的值赋给列表中的特定位置。\n\n# 修改列表中第二个\n水果[1] = '香蕉'\nprint(水果)\n\n['苹果', '香蕉', '榴莲']\n\n\n\n\n添加和删除元素\n添加元素：可以使用append()方法将元素添加到列表的末尾。\n\n水果.append('我爱香蕉')\nprint(水果)\n\n['苹果', '香蕉', '榴莲', '我爱香蕉']\n\n\n删除元素：可以使用remove()方法删除列表中的特定元素。\n\n水果.remove('香蕉')\nprint(水果) \n\n['苹果', '榴莲', '我爱香蕉']\n\n\n\n\n对列表进行排序\n列表的排序是指将列表中的元素按照一定的顺序进行排列。Python 提供了多种方法来对列表进行排序，其中最常用的是使用 sort() 方法。下面是一个实际案例和答案解析。\n\n\n\n\n\n\nNote\n\n\n\nsort()函数可以对列表进行就地排序，即直接修改原始列表的顺序。使用 sorted() 函数对列表进行临时排序，不改变原始列表的顺序。\n\n\n\n# 按数字对列表进行升序排序：\nlist_asc = [100, 50, 65, 82, 23]\nlist_asc.sort()\nprint(list_asc)\n\n[23, 50, 65, 82, 100]\n\n\n\n# 降序排序\nlist_des = [100, 50, 65, 82, 23]\nlist_des.sort(reverse=True)\nprint(\"降序排序后的列表：\", list_des)\n\n降序排序后的列表： [100, 82, 65, 50, 23]\n\n\n\n\n\n元组(Tuple)\n元组与列表类似，也是用于存储一组有序的元素。但是，元组一旦创建，其元素不可更改，即元组是不可变的。\n\n\n# 创建一个元组\nperson = ('Jack', 25, 'China')\n\n# 访问元组元素\nprint(person[0])  \n\nJack\n\n\n\n# 尝试修改元组元素（会抛出异常）\nperson[1] = 30\n\nTypeError: 'tuple' object does not support item assignment\n\n\n在上面的示例中，我们创建了一个包含个人信息的元组。通过索引访问元组中的元素，但是尝试修改元组元素会引发TypeError异常，因为元组是不可变的。\n\n元组的应用场景\n\n用于存储不可变的数据集合，如坐标点、日期等。\n作为字典（Dictionary）的键值，因为字典要求键是不可变的。\n用于函数返回多个值，函数可以返回元组，调用函数时可以解包元组并获得多个返回值。\n\n元组在需要存储不可变数据集合或对数据进行保护时非常有用。由于元组是不可变的，因此在某些情况下比列表更安全和高效。\n\n\n元组解包\n可以将元组的元素解包到多个变量中，从而快速访问元组的各个元素。\n\n# 上述的person元组中，有三个数值，所以必须设`x,y,z`\nx, y, z = person\nprint(x) \n\nJack\n\n\n\n\n\n\n\n\n\n字典(Dictionary)\n字典是Python中一种常用的数据结构，又称 哈希表，它以键-值（key-value）对的形式存储数据。以下是对字典的详细说明：\n\n\n创建字典\n字典使用花括号{}来创建，每个键-值对之间使用冒号:分隔，不同键-值对之间使用逗号,分隔。例如：\n\nstudent = {'姓名': '帅气的Jack', '年龄': 24, '成绩': 'A+'}\nstudent\n\n{'姓名': '帅气的Jack', '年龄': 24, '成绩': 'A+'}\n\n\n\n\n访问字典元素\n可以通过键来访问字典中的值。使用键来提取相应的值，使用方括号[]操作符，将键作为索引传递给字典。例如：\n\nprint(student['姓名'])\n\n帅气的Jack\n\n\n\n\n修改字典元素\n字典中的值是可以修改的。可以通过指定键来更新字典中的值。例如：\n\n#要修改元素，无论中英文都要加上引号''\nstudent['成绩'] = '刚好及格'\nprint(student)\n\n{'姓名': '帅气的Jack', '年龄': 24, '成绩': '刚好及格'}\n\n\n\n\n\n\n\n\nNote\n\n\n\n设置变量的时候，不要使用类似list, tuple等，如果出现'list' object is not callable，使用del list删除变量\n\n\n\ndict1 = {'key': ['value', 'value2'], 'key2': 'value2'}\ndict2 = {'key': ('physics', 'chemistry', 1997, 2000), 'key2': 'value2'}\n\n\n\n关于字典的相关操作\n要确定字典有多少项，可以使用len()函数\n\nprint(len(student))\n\n3\n\n\n\ndel student['姓名']  # 删除键是'姓名'的条目\nstudent.clear()      # 清空字典所有条目\ndel student          # 删除字典\ndel list            # 删除变量\n\n字典Dict中键和值是一 一对应的，键是唯一的，如果重复最后的一个键【值】对会替换前面的。若一个键中需要存放多个值，可以考虑使用元组Tuple和列表List\n\n\n\n数据结构间的相互转换\n\n列表转换元组\n\n使用 list() 函数将元组转换为列表。\n使用 tuple() 函数将列表转换为元组。\n\n\n# 元组转列表\nmy_tuple = (1, 2, 3, 4, 5)\nmy_list = list(my_tuple)\nprint(my_list)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 列表转元组\nmy_list = [1, 2, 3, 4, 5]\nmy_tuple = tuple(my_list)\nprint(my_tuple)\n\n(1, 2, 3, 4, 5)\n\n\n\n\n字典转换列表&元组\n字典无法直接转换为列表或者元组\nkeys() 方法返回一个包含字典中所有键的可迭代对象。\nitems() 方法获取字典的键值对\n\n# keys() 是一个字典(Dictionary)对象的方法，用于返回字典中所有的键\n\nmy_dict = {\"name\": \"John\", \"age\": 25, \"city\": \"New York\"}\nmy_list = list(my_dict.keys())\nprint(my_list)\n\nprint(type(my_list))\n\n['name', 'age', 'city']\n&lt;class 'list'&gt;\n\n\n\n# 使用 items() 方法获取字典的键值对，然后使用 tuple() 函数将键值对转换为元组。\n\nmy_dict = {\"name\": \"John\", \"age\": 25, \"city\": \"New York\"}\nmy_tuple = tuple(my_dict.items())\nprint(my_tuple)\n\nprint(type(my_tuple))\n\n(('name', 'John'), ('age', 25), ('city', 'New York'))\n&lt;class 'tuple'&gt;"
  },
  {
    "objectID": "周三条件语句和循环语句.html",
    "href": "周三条件语句和循环语句.html",
    "title": "4  条件语句的学习",
    "section": "",
    "text": "在本节课程中，我们将学习条件语句的基本结构、逻辑判断以及如何构建复杂的条件表达式。同时，我们还会练习编写带有条件判断的程序，让你能够根据条件执行不同的代码块。\n\n条件语句的基本结构 条件语句允许我们根据不同的条件来执行不同的代码块。在Python中，条件语句使用if和else关键字构建。基本结构如下：\n\n\nif 条件:\n     #条件为True时执行的代码块\nelse:\n     #条件为False时执行的代码块\n\n\n逻辑判断 条件语句的逻辑判断基于比较运算符，用于比较两个值的相等性、大小关系等。常见的比较运算符包括：\n\n\n相等性判断：==（等于）、!=（不等于）\n大小关系判断：&gt;（大于）、&lt;（小于）、&gt;=（大于等于）、&lt;=（小于等于）\n\n举例：\n\nbalance = 1000\nif balance == 0:\n    print(\"账户余额为零\")\nelse:\n    print(\"账户余额不为零\")\n\n账户余额不为零\n\n\n\n复杂的条件表达式 我们可以使用比较运算符和逻辑运算符构建复杂的条件表达式，以实现更灵活的条件判断。常见的逻辑运算符包括：\n\n\nand（与）：当所有条件都为True时，结果为True\nor（或）：当至少一个条件为True时，结果为True\nnot（非）：取反操作，将True变为False，False变为True\n\n举例：\n\nincome = 50000\nif income &gt;= 50000 and income &lt;= 100000:\n    print(\"年收入在50,000到100,000之间\")\n\n年收入在50,000到100,000之间\n\n\n\n编写带有多个条件判断的程序 我们经常需要根据不同的条件执行不同的代码块。\nelif 是 Python 中的一个关键字，它是 if 语句的一部分，用于在多个条件语句中选择一个执行。elif 是 else if 的缩写，可以在 if 语句的末尾添加一个或多个 elif 语句，用于测试多个条件，如果前面的条件不成立，则测试下一个条件，直到找到一个成立的条件为止。\n\nelif 语句的语法如下：\n\nif 条件1:\n    # 如果条件1成立，则执行这里的代码\nelif 条件2:\n    # 如果条件1不成立，但条件2成立，则执行这里的代码\nelif 条件3:\n    # 如果条件1和条件2都不成立，但条件3成立，则执行这里的代码\nelse:\n    # 如果前面的所有条件都不成立，则执行这里的代码\n\n让我们通过举例来理解它的用法：\n\nnet_income = 5000\nif net_income &gt; 0 and net_income &lt;= 10000:\n    print(\"盈利一般\")\nelif net_income &gt; 10000 and net_income &lt;= 50000:\n    print(\"盈利良好\")\nelif net_income &gt; 50000:\n    print(\"盈利优秀\")\nelse:\n    print(\"亏损\")\n\n盈利一般\n\n\n\nrevenue = float(input(\"请输入公司的营业收入：\"))\n\nif revenue &gt; 1000000:\n    tax = revenue * 0.3\n    print(\"应缴纳的所得税为：\", tax)\nelse:\n    tax = revenue * 0.2\n    print(\"应缴纳的所得税为：\", tax)\n\n\n应缴纳的所得税为： 100000.0\n\n\n\n循环语句的学习\n\n基本结构 循环语句允许我们重复执行一段代码。Python中有两种常见的循环结构：while循环和for循环。\n\nPython 的 for 循环和 while 循环，它们的相同点在于都能循环做一件重复的事情，不同点在于 for 循环会在可迭代的序列被穷尽的时候停止，while则是在条件不成立的时候停止。\n因此 把 for 循环所做的事情概括成一句话就是: 于…其中的每一个元素，做…事情；\n把while 的作用概括成一句话就是: 只要…条件成立，就一直做…。\n\nwhile循环的基本结构如下：\n\n\nwhile 条件:\n    # 循环体代码块\n\n\n\n\nimage.png\n\n\n这里看一个简单的例子：\n\nwhile 1 &lt; 3:\n print('1 is smaller than 3')\n\n这里提醒一下，要及时按下停止运行代码。 因为在 while 后面的表达式是永远成立的，所以 print 会一直进行下去直至你的cpu 过热。这种条件永远为 True 的循环，我们称之为死循环 (Infnite Loop) 。\n但如果 while 循环不能像 for 循环那样，在集合被穷尽之后停下来，我们又怎么样才能控制 while 循环呢? 其中一种方式就是: 在循环过程中制造某种可以使循环停下来的条件，例如:\n\ncount = 0\nwhile True:\n print('Repeat this line !')\n count = count + 1\n if count == 5:\n   break\n\nRepeat this line !\nRepeat this line !\nRepeat this line !\nRepeat this line !\nRepeat this line !\n\n\n在上面这段代码中，有两个重要的地方，首先是我们给一个叫 count 的变量赋值为 0，其目的是计数。我们希望在循环次数为 5 的时候停下来。接下来的是 break同样作为关键词写在 if 下面的作用就是告诉程序在上面条件成立的时候停下来，仅此而已。这样就可以避免了死循环。\nfor循环的基本结构如下：\n\nfor 变量 in 可迭代对象:\n    # 循环体代码块\n\n\n\n\nimage.png\n\n\nfor 是关键词，而后面紧接着的是一个可以容纳“每一个元素”的变量名称，至于变量起什么名字自己定，但切记不要和关键词重名。\n在关键词 in 后面所对应的一定是具有“可迭代的”(iterable) 或者说是像列表那样的集合形态的对象，即可以连续地提供其中的每一个元素的对象。\n\nfor num in range(1,11): \n print(str(num) + ' + 1 =',num + 1)\n\n1 + 1 = 2\n2 + 1 = 3\n3 + 1 = 4\n4 + 1 = 5\n5 + 1 = 6\n6 + 1 = 7\n7 + 1 = 8\n8 + 1 = 9\n9 + 1 = 10\n10 + 1 = 11\n\n\n以上是一个简单的例子，内置函数range的意思是依次。我们只需要在 range 函数后面的括号中填上数字，就可以得到一个具有连续1到10的整数序列，利用for循环让他们相加。\n\n控制条件和执行过程 循环的执行依赖于控制条件。在每次循环迭代开始时，会检查控制条件的值。如果条件为True，则执行循环体代码块；否则，跳出循环。\n\n举例：\n\n使用while循环输出1到5的金融数据：\n\n\nprice = 100.0\nwhile price &lt;= 500.0:\n    print(\"股票价格:\", price)\n    price += 100.0\n\n股票价格: 100.0\n股票价格: 200.0\n股票价格: 300.0\n股票价格: 400.0\n股票价格: 500.0\n\n\n使用for循环遍历股票交易日的收盘价：\n\n  prices = [105.0, 102.5, 99.2, 101.8, 104.6]\n  for price in prices:\n      print(\"收盘价:\", price)\n\n\nbreak和continue语句 前面提到，我们可以使用break语句提前终止循环的执行，跳出循环体。而continue语句则用于跳过当前迭代，继续执行下一次循环。\n\n举例：\n\n使用break语句在满足条件时终止循环：\n\n\nprice = 100.0\nwhile True:\n    print(\"股票价格:\", price)\n    price += 100.0\n    if price &gt; 500.0:\n        break\n\n股票价格: 100.0\n股票价格: 200.0\n股票价格: 300.0\n股票价格: 400.0\n股票价格: 500.0\n\n\n使用continue语句跳过某些迭代：\n\nprices = [105.0, 102.5, 99.2, 101.8, 104.6]\nfor price in prices:\n    if price &lt; 100.0:\n        continue\n    print(\"收盘价:\", price)\n\n收盘价: 105.0\n收盘价: 102.5\n收盘价: 101.8\n收盘价: 104.6\n\n\n\n\n编写具有条件判断和循环结构的程序\n在本节课程中，我们将进一步学习如何编写具有条件判断和循环结构的程序，并解决一些简单的问题。\n\n判断奇数和偶数 编写一个程序，判断一个数是奇数还是偶数，并打印出所有的奇数或偶数。\n\n举例：\n\n判断一个数是否为奇数：\n\n\nnum = int(input(\"请输入一个整数：\"))\n\nif num % 2 == 0:\n    print(num, \"是偶数\")\nelse:\n    print(num, \"是奇数\")\n\n10 是偶数\n\n\n打印出1到10之间的所有偶数：\n\nfor num in range(1, 11):\n    if num % 2 == 0:\n        print(num)\n\n2\n4\n6\n8\n10\n\n\n\n计算斐波那契数列 编写一个程序，计算斐波那契数列中的前n个数字。\n注释：斐波那契数列是什么？\n斐波那契数列是一个数列，其中每个数字都是前两个数字之和。数列的开始通常为0和1，后续的数字由前两个数字相加而得。\n\n数列的前几个数字如下： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …\n可以看到，数列中的第一个数字是0，第二个数字是1，而后续的每个数字都是前两个数字之和。\n斐波那契数列在自然界和数学中都有广泛的应用。例如，斐波那契数列可以用于描述植物的分枝规律、音乐中的节奏模式、金融中的利率计算等。\n举例：\n\n计算斐波那契数列前10个数字：\n\n\nn = 10\na, b = 0, 1\n\nfor _ in range(n):\n    print(a)\n    a, b = b, a + b\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\n\n判断质数 编写一个程序，判断一个数是否为质数（只能被1和它本身整除的数）。\n\n举例：\n\n判断一个数是否为质数：\n\n\nnum = int(input(\"请输入一个整数：\"))\n\nif num &lt; 2:\n    print(num, \"不是质数\")\nelse:\n    is_prime = True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\nif is_prime:\n    print(num, \"是质数\")\nelse:\n    print(num, \"不是质数\")\n\n30 不是质数"
  },
  {
    "objectID": "周四函数.html",
    "href": "周四函数.html",
    "title": "5  Python函数",
    "section": "",
    "text": "函数的定义和调用"
  },
  {
    "objectID": "周四函数.html#函数的作用",
    "href": "周四函数.html#函数的作用",
    "title": "5  Python函数",
    "section": "函数的作用",
    "text": "函数的作用\n函数是编程中的重要概念，它可以将一段代码封装为一个可重用的模块。 函数的作用和优势包括：\n\n代码重用：通过将一段经常使用的代码封装在函数中，我们可以在程序的不同地方多次调用该函数，避免了重复编写相同的代码，提高了代码的复用性。这样一来，如果需要修改功能或修复 bug，只需修改函数内部的实现，而不需要在多个地方逐个修改相同的代码。\n模块化：函数允许将程序划分为独立的模块，每个模块负责一个特定的功能。通过将复杂的任务分解为更小、更易管理的函数，可以使代码更易于理解和维护。模块化还有助于团队合作，不同的开发人员可以并行工作于不同的函数，从而提高开发效率。\n提高可读性：函数使代码更易读和理解。通过将一段代码封装在函数中，并给函数起一个有描述性的名称，可以提高代码的可读性。函数的参数和返回值也可以提供关于函数预期行为的重要信息，帮助其他开发人员理解和正确使用函数。\n抽象和封装：函数可以将复杂的实现细节隐藏在函数内部，只暴露必要的接口。这种抽象和封装的方式有助于降低代码的复杂性，提高代码的可维护性。其他部分的代码只需关注函数的输入和输出，而无需了解函数内部的具体实现。\n代码的组织和管理：函数可以将代码分成逻辑上独立的部分，使代码更加结构化和有组织。通过使用函数，可以将不同的功能模块分开，每个函数负责一个特定的任务。这样一来，当需要修改或添加新功能时，可以更容易地定位和修改相关的函数，而不必浏览整个代码文件。"
  },
  {
    "objectID": "周四函数.html#使用函数组织代码的优势",
    "href": "周四函数.html#使用函数组织代码的优势",
    "title": "5  Python函数",
    "section": "使用函数组织代码的优势",
    "text": "使用函数组织代码的优势\n函数是Python中最重要的部分之一，使用函数来组织代码可以使代码具有以下几个优势：\n\n可维护性：函数将代码划分为逻辑上独立的块，使得修改和调试代码更加容易。当需要对某个功能进行修改或修复时，只需关注相关的函数，而不必担心对其他部分代码产生意外影响。这种模块化的组织方式简化了代码的维护工作，提高了代码的可维护性。\n可重用性：通过将通用功能封装在函数中，可以在不同的地方多次调用该函数，实现代码的重用。不必重复编写相同的代码，减少了代码量，并且使得代码更加精简。当需要修改功能时，只需在函数内部进行修改，所有调用该函数的地方都会受到更新的影响。\n可读性：函数具有自我描述性的名称，可以提高代码的可读性。函数的参数和返回值提供了有关函数预期行为的重要信息，使得其他开发人员可以更轻松地理解和使用函数。通过适当划分和组织函数，可以使代码的逻辑更加清晰，易于理解。\n测试性：函数的独立性使得单元测试变得更加容易。通过针对函数编写单元测试，可以更好地验证函数的行为是否符合预期。这有助于及早发现和修复潜在的问题，提高代码的质量和可靠性。\n扩展性：使用函数进行代码组织可以使系统更易于扩展。通过添加新的函数或修改现有函数，可以实现新的功能或改进现有功能。由于函数之间的独立性，扩展一个功能不会对其他部分的代码造成太大的影响，减少了潜在的副作用和错误。\n\n总之，使用函数来组织代码可以提高代码的可维护性、可重用性、可读性和测试性，使得代码更易于扩展和管理。函数为代码提供了一种模块化的方式，使得开发人员能够更有效地开发、调试和维护代码。"
  },
  {
    "objectID": "周四函数.html#函数的定义",
    "href": "周四函数.html#函数的定义",
    "title": "5  Python函数",
    "section": "函数的定义",
    "text": "函数的定义\n函数是提前组织好的、可重复使用的、用来实现特定功能的代码段。input()、print()、str、int()等都是Python的内置函数。\n除了Python内置的函数，用户还可以根据自身的需求，自定义函数。函数的基础定义语法如下：\n\n# 函数的基础定义语法\ndef 函数名(传入参数):\n    函数体\n    return 返回值\n    \n# 调用函数\n函数名(参数)\n\n\n\n\n\n在定义函数时，有如下注意事事项：\n\n参数、返回值如不需要，可以省略\n函数名必须先定义后使用\n在定义函数语句的前后，规范上要求空2行"
  },
  {
    "objectID": "周四函数.html#函数的命名规则",
    "href": "周四函数.html#函数的命名规则",
    "title": "5  Python函数",
    "section": "函数的命名规则",
    "text": "函数的命名规则\n在Python中，函数的命名需要遵循一些规则和约定，以保持代码的可读性和一致性。以下是Python中函数命名的规则：\n\n函数名只能包含字母、数字和下划线（_）字符。\n函数名可以以字母或下划线开头，但不能以数字开头。\n函数名区分大小写，因此my_function和my_Function是不同的函数名。\n函数名应该具有描述性，能够清晰地表达函数的作用和功能。推荐使用小写字母和下划线的组合，以增加可读性。例如，calculate_average、print_message等。\n如果函数名由多个单词组成，可以使用下划线进行单词间的分隔，这样可以提高函数名的可读性。这种命名方式被称为下划线命名法（snake_case）。例如，calculate_average_score。\n避免使用Python的关键字和保留字作为函数名，以免引起冲突。例如，不要将函数命名为def、print等。\n函数名应该尽量简洁明了，避免过长的命名。选择能准确描述函数功能的简洁名称。"
  },
  {
    "objectID": "周四函数.html#函数的调用方式",
    "href": "周四函数.html#函数的调用方式",
    "title": "5  Python函数",
    "section": "函数的调用方式",
    "text": "函数的调用方式\n\n函数的传入参数\n函数的传入参数的功能是：在函数进行计算的时候，函数将接收外部提供的数据。\n\n函数的传入参数在函数被调用时指定。\n在函数定义中所提供的n个传入参数，称为形式参数(形参)，表示函数声明将要使用n个形式参数。\n在函数调用中所提供的传入参数，称为实际参数(实参)，表示函数执行时真正实用的参数值。\n\n在Python中，函数可以接受不同类型的参数作为输入。这些参数可以用于在函数内部进行计算、执行操作或提供必要的数据。以下是Python中函数传入参数的一些常见用法：\n\n位置参数（Positional Arguments）：这是最常见的参数传递方式，按照参数在函数定义中的顺序进行传递。调用函数时，传递的参数值按照对应位置依次赋给函数定义中的参数，即实参的位置要与形参一一对应。\n\n\n# 位置参数\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\n\ngreet(\"World\", \"Hello\")\ngreet(\"Python\", \"Hi\")\n\nHello, World!\nHi, Python!\n\n\n在上面的例子中，我们编辑了一个问候函数，仿照其格式，你也可以试试编辑一个自己的函数，用来对这个世界打招呼。\n\n关键字参数（Keyword Arguments）：使用关键字参数可以通过参数名来指定参数的值，而不必按照参数的顺序进行传递，即实参与形参的位置并不一一对应，但在传入参数时，需对使用参数名来进行标注。\n\n\n# 关键字参数\ndef greet2(name, message):\n    print(f\"{message}, {name}!\")\n\n\ngreet2(message=\"Hello\", name=\"World\")\ngreet2(name=\"Python\", message=\"Hi\")\n\nHello, World!\nHi, Python!\n\n\n灵活运用关键字参数可以让我们很容易地向函数传递数据，尝试编写一个函数，打乱向他传入参数的顺序，再使用关键字参数来调整。\n\n默认参数（Default Arguments）：函数定义时，可以为参数指定默认值，当调用函数时没有提供对应参数的值时，将使用默认值。在下面的示例中，将Hello设置为参数message的默认值，因此如果在调用参数时，没有传入message对应的值，message将会使用默认值Hello。\n\n\n# 默认参数\ndef greet3(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\n\ngreet3(\"World\")\ngreet3(\"Python\", \"Hi\")\n\nHello, World!\nHi, Python!\n\n\n\n可变数量参数（Variable-length Arguments）：有时候，我们需要处理可变数量的参数。Python提供了两种方式来处理这种情况：\n\n\n*args：表示函数接受任意数量的位置参数，这些参数将作为一个元组传递给函数。\n\n\n\n\n\n\n**kwargs：表示函数接受任意数量的关键字参数，这些参数将作为一个字典传递给函数。\n\n\n\n\n\n\n\n函数的返回值\n函数的返回值，就是程序中函数完成事情后，最后给调用者的结果。在Python中，函数可以通过返回值将计算结果或数据传递给调用方。函数的返回值可以是任意类型的数据，包括数字、字符串、列表、字典等。以下是Python中函数返回值的用法和示例代码：\n\n返回单个值：函数可以使用return语句返回单个值。一旦执行到return语句，函数将立即停止执行，并将指定的值返回给调用方。\n\n\ndef add_num(a, b):\n    return a + b\n\n\nresult = add_num(3, 4)\nprint(result)\n\n\n返回多个值：函数可以使用return语句返回多个值，这些值将被打包为一个元组。调用方可以使用多个变量来接收这些返回值。\n\n\n\n\n\n\n空返回值：如果函数没有明确的返回语句，或者使用return语句而没有指定返回值，函数将默认返回None。\n\n在Python中，有一个特殊的字面量：None，其类型是：&lt;class 'NoneType'&gt;。如果函数没有使用return语句返回数据，实际上就是返回了None这个字面量。\n\n\n\n\n\n\n\n提前返回：在函数执行过程中，可以使用return语句提前结束函数的执行，并返回指定的值。这可以在满足某个条件时提前退出函数。"
  },
  {
    "objectID": "周四函数.html#匿名函数lambda表达式",
    "href": "周四函数.html#匿名函数lambda表达式",
    "title": "5  Python函数",
    "section": "匿名函数（lambda表达式）",
    "text": "匿名函数（lambda表达式）\n在Python中，可以使用匿名函数（lambda表达式）来创建简单的、没有函数名的函数。匿名函数通常用于需要定义简短、一次性使用的函数。以下是匿名函数的用法和示例代码：\n\n# 匿名函数的语法\nlambda arguments: expression\n\n\nlambda关键字表示创建匿名函数。\narguments表示函数的参数列表。\nexpression表示函数的计算逻辑，即函数的返回值。\n\n匿名函数通常与内置函数（如map()、filter()等）一起使用，或者作为函数的参数传递给其他函数。\n下面是几个使用匿名函数的示例：\n\n匿名函数求平方：\n\n\nsquare = lambda x: x**2\nresult = square(5)\nprint(result)  # 输出：25\n\n25\n\n\n\n匿名函数求和：\n\n\naddition = lambda a, b: a + b\nresult = addition(3, 4)\nprint(result)  # 输出：7\n\n7\n\n\n\n使用内置函数map()和匿名函数对列表中的每个元素进行平方操作：\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = list(map(lambda x: x**2, numbers))\nprint(squared_numbers)  # 输出：[1, 4, 9, 16, 25]\n\n[1, 4, 9, 16, 25]\n\n\n\n使用内置函数filter()和匿名函数筛选出列表中的偶数：\n\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # 输出：[2, 4]\n\n[2, 4]\n\n\n匿名函数的优势在于其简洁性和灵活性，可以在需要临时定义函数的场景下快速创建函数，避免定义独立的函数名称。然而，由于其只能表示简单的表达式，因此不适合于复杂的逻辑和长代码块的情况。"
  },
  {
    "objectID": "周四函数.html#函数的嵌套和闭包",
    "href": "周四函数.html#函数的嵌套和闭包",
    "title": "5  Python函数",
    "section": "函数的嵌套和闭包",
    "text": "函数的嵌套和闭包\n\n函数的嵌套\n函数的嵌套调用是指在一个函数的定义中调用了另外的函数。在函数A中调用另外一个函数B时，会先把函数B中的任务都执行完毕后才会继续执行函数A的剩余内容。下面是函数嵌套的示例：\n\ndef func2():\n    print(\"我爱Python\")\n\n\ndef func1():\n    print(\"我是新手\")\n    func2()\n    print(\"我要好好学习\")\n\n\nfunc1()\n\n我是新手\n我爱Python\n我要好好学习\n\n\n在上面的示例中，函数func1在执行时，调用了函数func2，并且，只有在func2执行完成之后，func1才会继续执行剩余内容。\n\n在函数中使用的变量作用域\n\n变量的作用域指的是变量的作用范围，即变量在哪里可用，在哪里不可用。\n根据变量的作用范围，变量分为局部变量和全局变量。\n\n局部变量\n\n局部变量是指定义在函数体内部的变量，这种变量只在函数体内部生效。\n局部变量的作用：在函数体内部临时保存数据，在函数调用完成以后，局部变量就被销毁了。\n\n全局变量\n\n全局变量就是指在函数体内、外部都能生效的变量。\n\nglobal关键字\n\n使用global关键字，可以在函数内部声明变量为全局变量。\n\n\n函数的闭包\n在Python中，闭包（closure）是指在一个函数内部定义的函数，并且该内部函数可以访问外部函数的变量。闭包可以捕获并保持外部函数的状态，即使外部函数已经执行完毕，内部函数仍然可以使用外部函数的变量。这使得闭包在编程中非常有用，特别是在函数式编程和装饰器模式中。\n闭包的关键是内部函数可以访问外部函数的变量。在Python中，当内部函数引用外部函数的变量时，Python会将该变量包装成一个包含变量值的闭包对象。这个闭包对象可以在内部函数中使用，并且在内部函数被调用时仍然保持着它的值。\n\ndef outer_function(x):\n    def inner_function(y):\n        return x + y\n    return inner_function\n\nclosure = outer_function(10)\nresult = closure(5)\nprint(result)\n\n15\n\n\n在上面的例子中，outer_function是外部函数，它接受一个参数x。内部函数inner_function定义在外部函数内部，并引用了外部函数的参数 x。outer_function返回了内部函数inner_function，形成了一个闭包。\n在这个例子中，我们调用outer_function(10)并将返回的内部函数保存在 closure变量中。然后，我们调用closure(5)，这实际上是调用了内部函数inner_function。由于闭包的存在，内部函数仍然可以访问外部函数的变量x，所以结果将是10 + 5 = 15。\n通过闭包，我们可以创建具有记忆功能的函数，可以在多次调用之间保持状态。这使得闭包在实现装饰器、缓存功能等方面非常有用。"
  },
  {
    "objectID": "周四模块.html",
    "href": "周四模块.html",
    "title": "6  Python模块",
    "section": "",
    "text": "Python标准库的模块"
  },
  {
    "objectID": "周四模块.html#模块的概念",
    "href": "周四模块.html#模块的概念",
    "title": "6  Python模块",
    "section": "模块的概念",
    "text": "模块的概念\n在Python中，模块是一个包含函数、类和变量的Python文件。它提供了一种组织和重用代码的方式，使得我们可以将相关的代码组织在一个独立的单元中，并通过导入模块来使用其中的函数、类和变量。\n模块使得代码的组织更加模块化和可维护，可以将相关功能划分到不同的模块中，使得代码更易于理解和扩展。另外，通过使用模块，可以实现代码的复用，不必重复编写相同的代码。\n要使用一个模块，我们需要使用 import 语句将模块导入到当前的Python环境中。导入模块后，我们就可以通过模块名加点操作符来访问模块中定义的函数、类和变量。\n\n\n\n\n这就是模块的基本概念和用法。通过模块，我们可以更好地组织和复用代码，使得程序更加模块化和可维护。"
  },
  {
    "objectID": "周四模块.html#模块的使用",
    "href": "周四模块.html#模块的使用",
    "title": "6  Python模块",
    "section": "模块的使用",
    "text": "模块的使用\n学习如何使用Python标准库中的模块非常重要，因为标准库提供了大量功能丰富的模块，可以帮助我们完成各种任务。同时，我们自己定义的模块也常常能在工作中提供很大的帮助。\n以下是模块的基本使用方法：\n\n导入模块：要使用标准库模块，首先需要使用 import 语句将模块导入到当前的Python环境中。导入模块的一般语法是 import module_name。例如，要导入标准库中的 math 模块，可以使用 import math。\n\n\nimport math\n\nresult = math.sqrt(25)\nprint(result)  # 输出: 5.0\n\n5.0\n\n\n\n使用模块中的函数、类和变量：一旦导入了模块，就可以使用模块中定义的函数、类和变量。使用的语法是 module_name.function_name()、module_name.ClassName() 或 module_name.variable_name。例如，要使用 math 模块中的 sqrt 函数，可以使用 math.sqrt(25)。\n\n\nimport math\n\nresult = math.sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = math.pi * math.pow(radius, 2)\nprint(area)  # 输出: 78.53981633974483\n\n5.0\n78.53981633974483\n\n\n\n给模块起别名：有时模块名很长或与其他名称冲突，可以给模块起一个别名以便更方便地使用。使用别名的语法是 import module_name as alias。例如，要将 math 模块起别名为 m，可以使用 import math as m。\n\n\nimport math as m\n\nresult = m.sqrt(25)\nprint(result)  # 输出: 5.0\n\n5.0\n\n\n\n导入模块中的特定函数或变量：如果只需要使用模块中的某些特定函数或变量，可以使用 from module_name import item_name 的语法。这样可以直接使用 item_name，而无需使用模块名作为前缀。例如，要导入 math 模块中的 sqrt 函数，可以使用 from math import sqrt，然后直接使用 sqrt(25)。\n\n\nfrom math import sqrt, pi\n\nresult = sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = pi * radius ** 2\nprint(area)  # 输出: 78.53981633974483\n\n5.0\n78.53981633974483\n\n\n\n导入模块中的所有内容：如果希望导入模块中的所有函数、类和变量，可以使用 from module_name import * 的语法。这样可以直接使用模块中的所有内容，但可能会与其他已有的函数或变量发生冲突，因此需要谨慎使用。\n\n\nfrom math import *\n\nresult = sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = pi * radius ** 2\nprint(area)  # 输出: 78.53981633974483\n\n5.0\n78.53981633974483\n\n\n\n查看模块的帮助文档：Python标准库模块通常有详细的文档说明。可以使用 help(module_name) 函数来查看模块的帮助文档。例如，使用 help(math) 可以查看 math 模块的帮助文档。\n\n\nimport math\n\nhelp(math)"
  },
  {
    "objectID": "周四模块.html#常用的内置模块",
    "href": "周四模块.html#常用的内置模块",
    "title": "6  Python模块",
    "section": "常用的内置模块",
    "text": "常用的内置模块\n\nmath模块\n\nmath模块提供了执行数学运算的函数和常量。它包含了许多常见的数学操作，如三角函数、指数函数、对数函数等。\n\nimport math\n\nresult = math.sqrt(25)  # 平方根\nprint(result)  # 输出: 5.0\n\nangle = math.radians(45)  # 将角度转换为弧度\nsine = math.sin(angle)  # 正弦函数\nprint(sine)  # 输出: 0.7071067811865476\n\npi = math.pi  # 圆周率\nprint(pi)  # 输出: 3.141592653589793\n\n5.0\n0.7071067811865476\n3.141592653589793\n\n\n\nrandom模块\n\nrandom模块用于生成随机数。它提供了各种随机数生成函数，如生成随机整数、随机选择元素等。\n\nimport random\n\nnumber = random.randint(1, 10)  # 生成一个1到10之间的随机整数\nprint(number)  # 输出: 随机整数\n\nitems = [1, 2, 3, 4, 5]\nrandom_choice = random.choice(items)  # 从列表中随机选择一个元素\nprint(random_choice)  # 输出: 随机选择的元素\n\n3\n1"
  },
  {
    "objectID": "周四模块.html#文件和目录操作的模块",
    "href": "周四模块.html#文件和目录操作的模块",
    "title": "6  Python模块",
    "section": "文件和目录操作的模块",
    "text": "文件和目录操作的模块\n\nos模块\n\nos模块提供了许多与操作系统交互的函数。它可以用于执行文件和目录操作、获取系统信息等。\n\nimport os\n\ncurrent_dir = os.getcwd()  # 获取当前工作目录\nprint(current_dir)  # 输出: 当前工作目录的路径\n\nfile_list = os.listdir(current_dir)  # 获取当前目录下的文件列表\nprint(file_list)  # 输出: 当前目录下的文件列表\n\n\nshutil模块\n\nshutil模块用于高级的文件和目录操作。它提供了一些方便的函数，如复制文件、移动文件、删除文件等。\n\nimport shutil\n\nsource = 'path/to/source/file.txt'\ndestination = 'path/to/destination/file.txt'\n\nshutil.copy(source, destination)  # 复制文件"
  },
  {
    "objectID": "周四模块.html#时间和日期处理的模块",
    "href": "周四模块.html#时间和日期处理的模块",
    "title": "6  Python模块",
    "section": "时间和日期处理的模块",
    "text": "时间和日期处理的模块\n\ndatetime模块\n\ndatetime模块提供了处理日期和时间的功能。它包含了日期、时间、时间间隔等对象，以及各种日期和时间操作的函数。\n\nimport datetime\n\ncurrent_time = datetime.datetime.now()  # 获取当前时间\nprint(current_time)  # 输出: 当前时间\n\ncurrent_date = datetime.date.today()  # 获取当前日期\nprint(current_date)  # 输出: 当前日期\n\n2023-06-29 00:14:50.958106\n2023-06-29\n\n\n\ntime模块\n\ntime模块提供了与时间相关的函数。它可以用于获取当前时间、时间的格式化、休眠等操作。\n\nimport time\n\ncurrent_time = time.localtime()  # 获取当前时间的本地表示\nprint(current_time)  # 输出: 当前本地时间的结构化表示\n\nformatted_time = time.strftime('%Y-%m-%d %H:%M:%S', current_time)  # 格式化时间\nprint(formatted_time)  # 输出: 格式化后的时间字符串\n\ntime.struct_time(tm_year=2023, tm_mon=6, tm_mday=29, tm_hour=0, tm_min=15, tm_sec=30, tm_wday=3, tm_yday=180, tm_isdst=0)\n2023-06-29 00:15:30\n\n\n这些模块是Python标准库中的一小部分，它们提供了广泛的功能和工具，可帮助您处理数学运算、随机数生成、文件和目录操作、日期时间处理等各种任务。\n要熟练使用Python，就需要掌握这些模块的使用方法，并能够根据需要，自定义模块。"
  },
  {
    "objectID": "周四模块.html#第三方模块的概念及安装方法",
    "href": "周四模块.html#第三方模块的概念及安装方法",
    "title": "6  Python模块",
    "section": "第三方模块的概念及安装方法",
    "text": "第三方模块的概念及安装方法\n在Python中，第三方模块是由Python社区或其他开发者开发的，用于扩展Python功能和提供额外功能的模块。这些模块通常不包含在Python标准库中，但它们提供了各种用途的功能，例如网络请求、数据分析、图像处理等。\n安装第三方模块可以通过使用包管理工具pip来完成。pip是Python的默认包管理工具，可用于安装、升级和卸载第三方模块。\n以下是安装第三方模块的步骤：\n\n确保已安装pip：\n\n在终端或命令提示符中运行以下指令。检查pip是否已安装：\n\npip --version\n\n如果输出了pip的版本信息，则说明pip已安装。如果未找到pip或提示未定义的命令，则需要先安装pip。\n\n使用pip安装模块：要安装第三方模块，可以在终端或命令提示符中运行以下命令：\n\n\npip install module_name\n\n例如，要安装常用的第三方模块requests，可以运行：\n\npip install requests\n\n其中，module_name是要安装的第三方模块的名称。pip将自动下载并安装该模块及其相关依赖项。\n\n确认安装成功：安装完成后，可以在Python脚本中导入并使用该模块。如果没有报错，则表示安装成功。示例如下：\n\n\nimport requests\n\nresponse = requests.get('https://www.example.com')\nprint(response.status_code)\n\n上述代码导入了requests模块，并使用该模块发送HTTP请求。\n需要注意的是，有些第三方模块可能需要特定版本的Python或其他依赖项。在安装之前，建议查阅该模块的官方文档或README文件，以了解安装要求和使用说明。\n另外，还有其他包管理工具可以用于安装第三方模块，例如conda、pipenv等，具体根据您的需求和使用环境选择合适的工具。\n总的来说，第三方模块为Python提供了丰富的扩展功能，我们可以根据特定的项目需求安装第三方模块。"
  },
  {
    "objectID": "周四模块.html#常用的数据分析和科学计算库",
    "href": "周四模块.html#常用的数据分析和科学计算库",
    "title": "6  Python模块",
    "section": "常用的数据分析和科学计算库",
    "text": "常用的数据分析和科学计算库\nNumPy和Pandas是Python数据分析和科学计算中的重要库。NumPy提供了高性能的数值计算和数组操作功能，适用于处理大规模数值数据；而Pandas则专注于数据分析和操作，提供了灵活且高效的数据结构和数据处理工具，使得数据的清洗、转换和分析更加方便。这两个库通常一起使用，使得数据科学工作更加便捷和高效。\n\nNumPy（Numerical Python）\n\n\nNumPy是Python中用于数值计算和科学计算的核心库。\nNumPy提供了一个强大的多维数组对象（ndarray），可以进行高效的数值运算和数组操作。ndarray是一个具有相同类型和大小的元素组成的多维容器，它提供了高速的数值运算和广播功能。\nNumPy的主要特点包括：\n\n多维数组操作：NumPy提供了广泛的数组操作函数，例如索引、切片、形状操作、重塑、拼接等。\n数学函数：NumPy包含了各种数学函数，如三角函数、指数函数、对数函数、统计函数等。\n线性代数运算：NumPy提供了线性代数运算功能，如矩阵乘法、逆矩阵、特征值等。\n随机数生成：NumPy具有随机数生成的功能，可以生成各种概率分布的随机数。\n\n\nNumPy是Python科学计算的基础库，许多其他科学计算和数据分析库都建立在NumPy之上。\n下面是NumPy的简单应用示例：\n\nimport numpy as np\n\n# 创建NumPy数组\narr = np.array([1, 2, 3, 4, 5])\n\n# 数组运算\nprint(arr + 1)  # 加法运算\nprint(arr * 2)  # 乘法运算\nprint(np.mean(arr))  # 平均值\n\n# 多维数组\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2d.shape)  # 输出: (2, 3)\n\n# 线性代数运算\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nprint(np.dot(a, b))  # 矩阵相乘\n\n[2 3 4 5 6]\n[ 2  4  6  8 10]\n3.0\n(2, 3)\n[[19 22]\n [43 50]]\n\n\n\nPandas\n\n\nPandas是一个功能强大的数据分析和操作库，构建在NumPy之上。\nPandas提供了两个重要的数据结构：Series和DataFrame。\n\nSeries是一维的标签化数组，类似于带标签的一维数组，可以容纳任意类型的数据。\nDataFrame是二维的表格型数据结构，类似于SQL中的表或Excel中的电子表格，具有行和列的标签，每列可以是不同的数据类型。\n\nPandas的主要功能包括：\n\n数据读取和写入：Pandas可以从各种数据源（如CSV文件、Excel文件、SQL数据库等）读取数据，并可以将数据写入不同的格式。\n数据清洗和预处理：Pandas提供了丰富的功能来处理缺失值、重复数据、异常值等数据清洗任务。\n数据操作和计算：Pandas支持灵活的数据操作和计算，如索引、切片、筛选、聚合、分组等。\n时间序列处理：Pandas提供了强大的时间序列处理功能，支持日期和时间的索引、重采样、滚动窗口计算等。\n数据可视化：Pandas集成了Matplotlib库，可以方便地进行数据可视化。\n\n\nPandas提供了高效的数据处理和分析工具，使得数据科学家和分析师能够更轻松地处理和分析结构化数据。\n\nimport pandas as pd\n\n# 创建Pandas DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n        'Age': [25, 30, 35, 40],\n        'City': ['New York', 'London', 'Paris', 'Tokyo']}\n\ndf = pd.DataFrame(data)\n\n# 数据操作\nprint(df.head())  # 查看前几行数据\nprint(df['Age'].mean())  # 计算年龄的平均值\n\n# 数据筛选\nfiltered_df = df[df['Age'] &gt; 30]  # 筛选年龄大于30的数据\nprint(filtered_df)\n\n# 数据分组和聚合\ngroupby_city = df.groupby('City')\nmean_age_by_city = groupby_city['Age'].mean()\nprint(mean_age_by_city)\n\n# 时间序列处理\ndates = pd.date_range(start='2021-01-01', end='2021-12-31', freq='D')\nprint(dates)\n\n      Name  Age      City\n0    Alice   25  New York\n1      Bob   30    London\n2  Charlie   35     Paris\n3    David   40     Tokyo\n32.5\n      Name  Age   City\n2  Charlie   35  Paris\n3    David   40  Tokyo\nCity\nLondon      30.0\nNew York    25.0\nParis       35.0\nTokyo       40.0\nName: Age, dtype: float64\nDatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',\n               '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08',\n               '2021-01-09', '2021-01-10',\n               ...\n               '2021-12-22', '2021-12-23', '2021-12-24', '2021-12-25',\n               '2021-12-26', '2021-12-27', '2021-12-28', '2021-12-29',\n               '2021-12-30', '2021-12-31'],\n              dtype='datetime64[ns]', length=365, freq='D')\n\n\nPandas库将是我们后面学习的重点内容，大家可以预先了解。"
  },
  {
    "objectID": "NumPy教程.html#numpy的安装和导入",
    "href": "NumPy教程.html#numpy的安装和导入",
    "title": "7  NumPy简介与基本操作",
    "section": "NumPy的安装和导入*",
    "text": "NumPy的安装和导入*\n安装 NumPy ：\nconda install numpy 或者 pip install numpy\n导入 NumPy ：\n\nimport numpy as np\n\n使用 NumPy 缩短导入的名称np，可以提高代码的可读性。"
  },
  {
    "objectID": "NumPy教程.html#numpy中的核心对象ndarray",
    "href": "NumPy教程.html#numpy中的核心对象ndarray",
    "title": "7  NumPy简介与基本操作",
    "section": "NumPy中的核心对象：ndarray*",
    "text": "NumPy中的核心对象：ndarray*\nndarray是NumPy中最重要的对象，它是N 维数组的简写，可以是一维数组、二维数组或更高维度的数组。\n\nprint(\"这是一个一维数组:\")\nnp.array((1, 2, 3))\n\n这是一个一维数组:\n\n\narray([1, 2, 3])\n\n\n\nprint(\"这是一个2x3的二维数组:\")\nnp.array([(1, 2, 3),(4, 5, 6)])\n\n这是一个2x3的二维数组:\n\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n相对于一维数组，二维数组多了一个维度，示例代码中的二维数组包含两个子数组（也称为行）：[1,2,3]和[4,5,6]，一个子数组代表一个行向量。\nndarray中的元素可以是任意数据类型，包括整数、浮点数、复数等。数据类型由dtype（data type）对象来描述。"
  },
  {
    "objectID": "NumPy教程.html#创建numpy数组",
    "href": "NumPy教程.html#创建numpy数组",
    "title": "7  NumPy简介与基本操作",
    "section": "创建NumPy数组*",
    "text": "创建NumPy数组*\n要创建 NumPy 数组，可以使用函数np.array()将序列转换为数组。\n\n\n\n\n\n\nNote\n\n\n\n对象只能是一个，例如((),(),...)，不能是多个序列：(),(),...。\n\n\n\nimport numpy as np\na = np.array(((1, 2, 3),(4, 5, 6)))\na\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n创建一个元素都为0的数组（默认元素类型为float64，简写为float_，可以通过dtype进行设置）：\n\nnp.zeros((2, 2))\n\narray([[0., 0.],\n       [0., 0.]])\n\n\n创建一个元素全为1的3x3矩阵，数值类型为整型：\n\nnp.ones((3, 3), dtype=np.int_)\n\narray([[1, 1, 1],\n       [1, 1, 1],\n       [1, 1, 1]])\n\n\n创建一个3x3单位矩阵（主对角线元素为1）：\n\nnp.eye(3, 3, dtype=np.int_)\n\narray([[1, 0, 0],\n       [0, 1, 0],\n       [0, 0, 1]])\n\n\n创建一个空数组，元素的初始内容会随机生成，可以设置dtype参数：\n\nnp.empty((2, 3), dtype=np.float_)\n\narray([[0., 0., 0.],\n       [0., 0., 0.]])\n\n\n创建一个等差数列型的一维数组：\nnp.arange()第一个参数start代表起始值，默认从0开始，第二个参数stop代表结束值，但结束值不包含在数组中。第三个参数step为步长，即相邻元素的差值。\n\nprint(\"创建一个值域从0-9,步长为2的数组:\")\nnp.arange(0, 10, 2)\n\n创建一个值域从0-9,步长为2的数组:\n\n\narray([0, 2, 4, 6, 8])\n\n\n\nprint(\"只含一个参数时,默认初始索引为0,步长为1:\")\nnp.arange(4)\n\n只含一个参数时,默认初始索引为0,步长为1:\n\n\narray([0, 1, 2, 3])\n\n\n\nprint(\"创建一个包含6个元素,值域从0到10的整型数组:\") \nnp.linspace(0, 10, num=6, dtype=np.int_) \n\n创建一个包含6个元素,值域从0到10的整型数组:\n\n\narray([ 0,  2,  4,  6,  8, 10])\n\n\n创建随机数组：\n\nprint(\"2x2的随机数组:\")\nnp.random.random((2, 2))\n\n2x2的随机数组:\n\n\narray([[0.43242609, 0.78096819],\n       [0.94460826, 0.38091863]])\n\n\n创建随机整型数组：\n\nnp.random.randint(5, size=(2, 3))\n\narray([[0, 0, 2],\n       [3, 1, 4]])\n\n\n基于已有的数组复制得到新数组：\n\na = np.arange(4)\nc = a.copy()\nc\n\narray([0, 1, 2, 3])"
  },
  {
    "objectID": "NumPy教程.html#numpy支持的数据类型",
    "href": "NumPy教程.html#numpy支持的数据类型",
    "title": "7  NumPy简介与基本操作",
    "section": "NumPy支持的数据类型",
    "text": "NumPy支持的数据类型\n\n布尔类型（bool）：表示True或False的布尔值，设置dtype = np.bool_即可。\n整数类型（int）：包括有符号和无符号的整数，如int_、int8、int16、int32、int64、uint8、uint16、uint32、uint64等，u意为unsigned，无符号，表示只能为正数。\n浮点数类型（float）：表示浮点数，包括float16、float32、float64(float_)等。\n复数类型（complex）：表示复数，包括complex64、complex128(complex_)等。\n字符串类型（string）：表示固定长度的字符串，如S10表示长度为10的字符串。\nUnicode类型（unicode）：表示固定长度的Unicode字符串，如U10表示长度为10的Unicode字符串。\n日期和时间类型（datetime）：表示日期和时间，包括datetime64、timedelta64等。"
  },
  {
    "objectID": "NumPy教程.html#数组的形状维度和大小",
    "href": "NumPy教程.html#数组的形状维度和大小",
    "title": "7  NumPy简介与基本操作",
    "section": "数组的形状、维度和大小*",
    "text": "数组的形状、维度和大小*\n在 NumPy 中，维度称为轴。以下面这个二维数组为例，它的第一个轴的长度为2（行），第二个轴长度为3（列）。\n\na = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(f\"以此数组为例:\\n{a}\")\n\nprint(f\"数组的维度是:{a.ndim}\")\n\nprint(f\"数组的形状是:{a.shape}\")\n\nprint(f\"数组一共包含{a.size}个元素\")\n\n以此数组为例:\n[[1 2 3]\n [4 5 6]]\n数组的维度是:2\n数组的形状是:(2, 3)\n数组一共包含6个元素"
  },
  {
    "objectID": "NumPy教程.html#数组的形状操作",
    "href": "NumPy教程.html#数组的形状操作",
    "title": "7  NumPy简介与基本操作",
    "section": "数组的形状操作*",
    "text": "数组的形状操作*\n\n\n\n\n\n\nNote\n\n\n\n重塑数组的形状或添加新轴不会改变元素，只会改变数组的形状。\n\n\n\na = np.arange(6)\nprint(f\"原数组:{a}\")\n\nprint(f\"重塑形状:\\n{a.reshape(2, 3)}\")\n\n原数组:[0 1 2 3 4 5]\n重塑形状:\n[[0 1 2]\n [3 4 5]]\n\n\n\nrow_vector = a[np.newaxis, :]\nprint(f\"添加新轴,从一维转为二维:\\n{row_vector}\")\n\nprint(f\"相当于在维度索引位置0处添加轴:\\n{np.expand_dims(a, axis=0)}\")\n\ncol_vector = a[:, np.newaxis]\nprint(f\"添加新轴,转换为列向量:\\n{col_vector}\")\n\nprint(f\"相当于在维度索引位置1处添加轴:\\n{np.expand_dims(a, axis=1)}\")\n\n添加新轴,从一维转为二维:\n[[0 1 2 3 4 5]]\n相当于在索引位置0处添加轴:\n[[0 1 2 3 4 5]]\n添加新轴,转换为列向量:\n[[0]\n [1]\n [2]\n [3]\n [4]\n [5]]\n相当于在索引位置1处添加轴:\n[[0]\n [1]\n [2]\n [3]\n [4]\n [5]]\n\n\n转置矩阵：\n\narr = np.arange(1, 7).reshape(2, 3)\nprint(f\"原矩阵:\\n{arr}\")\n\nprint(f\"转置后:\\n{arr.transpose()}\")\n\nprint(f\"也可以用.T:\\n{arr.T}\")\n\n原矩阵:\n[[1 2 3]\n [4 5 6]]\n转置后:\n[[1 4]\n [2 5]\n [3 6]]\n也可以用.T:\n[[1 4]\n [2 5]\n [3 6]]"
  },
  {
    "objectID": "NumPy教程.html#数组的索引和切片",
    "href": "NumPy教程.html#数组的索引和切片",
    "title": "7  NumPy简介与基本操作",
    "section": "数组的索引和切片*",
    "text": "数组的索引和切片*\n\n索引默认从0开始，第一个元素索引为0，第二个元素索引为1，依此类推。\n前闭后开规则，默认含首不含尾。\n-n指反方向第n个数。\n修改切片元素时原数组的元素也会相应改变。\n\n\narr = np.arange(10)\nprint('以此数组为例:', arr)\n\nslice_one = arr[:5] # 提取单个元素去掉冒号即可:arr[4]\nprint('索引从0到4的切片:', slice_one)\n\nslice_two = arr[4:7]\nprint('索引从4到6的切片:', slice_two)\n\nslice_three = arr[0:10:3]  # 前两个数可省略：arr[::3] \nprint('索引从0到9且步长为3的切片', slice_three)\n\nslice_four = arr[:-5]\nprint('索引从0到4的切片:', slice_four)\n\nslice_four[0] = 99\nprint('修改切片元素后原数组随之改变:', arr)\n\n以此数组为例: [0 1 2 3 4 5 6 7 8 9]\n索引从0到4的切片: [0 1 2 3 4]\n索引从4到6的切片: [4 5 6]\n索引从0到9且步长为3的切片 [0 3 6 9]\n索引从0到4的切片: [0 1 2 3 4]\n修改切片元素后原数组随之改变: [99  1  2  3  4  5  6  7  8  9]\n\n\n\narr = np.arange(1, 10).reshape(3, 3)\nprint(f\"二维数组:\\n{arr}\")\n\nprint(f\"行索引从1开始(第2行),列索引取到2(第3列但不包含):\\n{arr[1:, :2]}\")\n\n二维数组:\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n行索引从1开始(第2行),列索引取到2(第3列但不包含):\n[[4 5]\n [7 8]]\n\n\n以下面的三维数组为例，该数组三个维度的轴长分别为2, 3, 4，意味着:\n第一个维度包含两个二维子数组，第二个维度包含三个一维子数组，第三个维度包含四个整数。（依次去掉最外层中括号来看）\n\narr = np.random.randint(1, 10, size=(2, 3, 4))\n\nprint(f\"三维数组:\\n{arr}\")\n\nfor i in (0, 1):\n    print(f\"第一维度索引{i}指代的元素:\\n{arr[i, :, :]}\")\n\n三维数组:\n[[[5 9 1 2]\n  [3 8 4 8]\n  [7 4 1 7]]\n\n [[2 8 5 4]\n  [7 6 1 8]\n  [2 4 5 1]]]\n第一维度索引0指代的元素:\n[[5 9 1 2]\n [3 8 4 8]\n [7 4 1 7]]\n第一维度索引1指代的元素:\n[[2 8 5 4]\n [7 6 1 8]\n [2 4 5 1]]\n\n\n\nfor i in (0, 1, 2):\n    print(f\"第二维度索引{i}指代的元素():\\n{arr[:, i, :]}\")\n\n第二维度索引0指代的元素():\n[[5 9 1 2]\n [2 8 5 4]]\n第二维度索引1指代的元素():\n[[3 8 4 8]\n [7 6 1 8]]\n第二维度索引2指代的元素():\n[[7 4 1 7]\n [2 4 5 1]]\n\n\n\nfor i in (0, 1, 2, 3):\n    print(f\"第三维度索引{i}指代的元素:\\n{arr[:, :, i]}\")\n\n第三维度索引0指代的元素:\n[[5 3 7]\n [2 7 2]]\n第三维度索引1指代的元素:\n[[9 8 4]\n [8 6 4]]\n第三维度索引2指代的元素:\n[[1 4 1]\n [5 1 5]]\n第三维度索引3指代的元素:\n[[2 8 7]\n [4 8 1]]\n\n\n\n\n\n\n高维数组的切片可用省略号：\n\nprint(f\"第一维度从第二个元素开始:\\n{arr[1:, ...]}\")  # 等价于 arr[1:, :, :]\n\nprint(f\"第一维度第一个子数组中第一列:\\n{arr[0, ..., :1]}\")  # 等价于 arr[0, :, :1]\n\n第一维度从第二个元素开始:\n[[ 4  5  6  7]\n [ 8  9 10 11]]\n第一维度第一个子数组中第一列:\n[0]\n\n\n用逻辑条件来筛选满足条件的元素，筛选后的数组会被展平为一维数组：\n\narr = np.arange(12).reshape((3, 4))\nprint(f\"以此数组为例:\\n{arr}\")\n\nprint(f\"大于6的元素:{arr[arr &gt; 6]}\")\n\nprint(f\"返回布尔值:\\n{arr &gt; 6}\")\n\n以此数组为例:\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n大于6的元素:[ 7  8  9 10 11]\n返回布尔值:\n[[False False False False]\n [False False False  True]\n [ True  True  True  True]]\n\n\n返回满足条件的元素索引：\n\narr = np.random.randint(4, size=(3, 3))\nprint(f\"以此二维数组为例:\\n{arr}\")\n\nprint(f\"非零元素的索引(分维度):\\n{np.nonzero(arr)}\")\n\nprint(f\"元素小于均值的索引:\\n{np.nonzero(arr &lt; np.mean(arr))}\")\n\n以此二维数组为例:\n[[3 2 0]\n [0 1 2]\n [2 0 0]]\n非零元素的索引(分维度):\n(array([0, 0, 1, 1, 2], dtype=int64), array([0, 1, 1, 2, 0], dtype=int64))\n元素小于均值的索引:\n(array([0, 1, 1, 2, 2], dtype=int64), array([2, 0, 1, 1, 2], dtype=int64))\n\n\n以坐标形式返回元素索引：\n\nind = np.nonzero(arr &lt; 6)\n\nlist_of_coordinates = list(zip(ind[0], ind[1]))\nfor coord in list_of_coordinates:\n    print(coord)\n\n(0, 0)\n(0, 1)\n(0, 2)\n(1, 0)\n(1, 1)\n(1, 2)\n(2, 0)\n(2, 1)\n(2, 2)\n\n\n\n\n\n\n\n\nNote\n\n\n\n遇到不认识的函数或模块时，例如上述示例代码的zip()可以使用help(zip())查询函数或模块的信息以及示例代码。\n如果想要了解某个特定模块的函数，例如numpy的array函数，可以使用numpy.info(numpy.array)，也可以使用缩写np.info(np.array)"
  },
  {
    "objectID": "NumPy教程.html#数组的基本运算",
    "href": "NumPy教程.html#数组的基本运算",
    "title": "7  NumPy简介与基本操作",
    "section": "数组的基本运算*",
    "text": "数组的基本运算*\n数组上的算术运算符按元素应用。\n\na = np.array([(20,30),(40,50)])\nb = np.arange(2,6).reshape(2,2)\n\nprint(f\"数组a:\\n{a}\")\nprint(f\"数组b:\\n{b}\")\n\nprint(f\"加法运算:\\n{np.add(a, b)}\")\n# 等价于a + b\n\nprint(f\"减法运算:\\n{np.subtract(a, b)}\")\n# 等价于a - b\n\nprint(f\"乘法运算:\\n{np.multiply(a, b)}\")\n# 等价于a * b\n\nprint(f\"除法运算:\\n{np.divide(a, b)}\")\n# 等价于a / b\n\nprint(f\"平方运算:\\n{np.square(b)}\")\n# 等价于b**2\n\n数组a:\n[[20 30]\n [40 50]]\n数组b:\n[[2 3]\n [4 5]]\n加法运算:\n[[22 33]\n [44 55]]\n减法运算:\n[[18 27]\n [36 45]]\n乘法运算:\n[[ 40  90]\n [160 250]]\n除法运算:\n[[10. 10.]\n [10. 10.]]\n平方运算:\n[[ 4  9]\n [16 25]]\n\n\n矩阵（二维数组）乘积运算用@或.dot()：\n\n\n\n\n\n\nNote\n\n\n\n计算矩阵A和B的乘积时，新矩阵第i行第j列的元素为矩阵A第i行元素和矩阵B第j列元素的乘积和，所以需要A矩阵的列数和矩阵B的行数相同。\n\n\n\nA = np.array([(1, 2),(3, 4)])\nB = np.array([(3, 2, 1),(1, 1, 1)])\n\nprint(f\"数组A:\\n{A}\")\nprint(f\"数组B:\\n{B}\")\n\nprint(f\"矩阵的乘积:\\n{A@B}\")\n# 等价于A.dot(B)\n\n数组A:\n[[1 2]\n [3 4]]\n数组B:\n[[3 2 1]\n [1 1 1]]\n矩阵的乘积:\n[[ 5  4  3]\n [13 10  7]]\n\n\n聚合函数的运算（可以指定轴）：\n\narr = np.array([(1, 2), (3, 4)])\nprint(f\"对数组进行聚合函数的运算:\\n{arr}\")\n\nprint(\"数组元素求和:\", arr.sum())\n\nprint(\"数组元素每列求和:\", arr.sum(axis=0))  # 行求和:axis = 1\n\nprint(\"数组元素最小值:\", arr.min())\n\nprint(\"数组元素每列最小值:\", arr.min(axis=0)) \n\n对数组进行聚合函数的运算:\n[[1 2]\n [3 4]]\n数组元素求和: 10\n数组元素每列求和: [4 6]\n数组元素最小值: 1\n数组元素每列最小值: [1 2]"
  },
  {
    "objectID": "NumPy教程.html#数组的排序反转和去重",
    "href": "NumPy教程.html#数组的排序反转和去重",
    "title": "7  NumPy简介与基本操作",
    "section": "数组的排序、反转和去重*",
    "text": "数组的排序、反转和去重*\n对元素进行排序/反转，以一维、二维数组为例：\n\nx = np.array([7, 2, 5, 3, 6, 4, 9, 1, 8])\nprint(f\"一维数组:{x}\")\n\nprint(f\"排序:{np.sort(x)}\")\n\n\nprint(f\"反转:{np.flip(x)}\")\n\n\nprint(f\"利用切片方式反转,步长为-1:{x[::-1]}\")\n\n一维数组:[7 2 5 3 6 4 9 1 8]\n排序:[1 2 3 4 5 6 7 8 9]\n反转:[8 1 9 4 6 3 5 2 7]\n利用切片方式反转,步长为-1:[8 1 9 4 6 3 5 2 7]\n\n\n\ny = np.array([[7, 2, 5], [3, 6, 4], [9, 1, 8]])\nprint(f\"二维数组:\\n{y}\")\n\nprint(f\"排序:\\n{np.sort(y)}\")\n\nprint(f\"反转:\\n{np.flip(y)}\")\n\nprint(f\"仅反转子数组顺序:\\n{np.flip(y, axis=0)}\")\n\ny[:,1] = np.flip(y[:,1])\nprint(f\"仅反转第二列:\\n{y}\")\n\n二维数组:\n[[7 2 5]\n [3 6 4]\n [9 1 8]]\n排序:\n[[2 5 7]\n [3 4 6]\n [1 8 9]]\n反转:\n[[8 1 9]\n [4 6 3]\n [5 2 7]]\n仅反转子数组顺序:\n[[9 1 8]\n [3 6 4]\n [7 2 5]]\n仅反转第二列:\n[[7 1 5]\n [3 6 4]\n [9 2 8]]\n\n\n去重复值：\n\narr = np.array([1, 2, 2, 5, 7, 7, 8, 9, 9, 12, 14])\nprint(f\"原数组:{arr}\")\n\nprint(f\"去重后:{np.unique(arr)}\")\n\nunique_arr, indices_list = np.unique(arr, return_index=True)\nprint(f\"去重数组的索引:{indices_list}\")\n\n原数组:[ 1  2  2  5  7  7  8  9  9 12 14]\n去重后:[ 1  2  5  7  8  9 12 14]\n去重数组的索引:[ 0  1  3  4  6  7  9 10]"
  },
  {
    "objectID": "NumPy教程.html#数组的展平拼接堆叠拆分",
    "href": "NumPy教程.html#数组的展平拼接堆叠拆分",
    "title": "7  NumPy简介与基本操作",
    "section": "数组的展平、拼接、堆叠、拆分*",
    "text": "数组的展平、拼接、堆叠、拆分*\n展平数组可用flatten()或ravel()。\n\n\n\n\n\n\nNote\n\n\n\n使用flatten时，对展平数组的更改不会影响原数组，使用ravel时，数组的更改会影响原数组。\n\n\n\narr = np.arange(6).reshape(2, 3)\nprint(f\"展平前:\\n{arr}\")\n\narr_one = arr.flatten()\nprint(f\"使用flatten展平后:\\n{arr_one}\")\n\narr_one[0] = 99\nprint(f\"修改元素:\\n{arr_one}\")\n\nprint(f\"原数组不变:\\n{arr}\")\n\n展平前:\n[[0 1 2]\n [3 4 5]]\n使用flatten展平后:\n[0 1 2 3 4 5]\n修改元素:\n[99  1  2  3  4  5]\n原数组不变:\n[[0 1 2]\n [3 4 5]]\n\n\n\narr_two = arr.ravel()\nprint(f\"使用ravel展平后:\\n{arr_two}\")\n\narr_two[0] = 99\nprint(f\"修改元素:\\n{arr_two}\")\n\nprint(f\"原数组改变:\\n{arr}\")\n\n使用ravel展平后:\n[0 1 2 3 4 5]\n修改元素:\n[99  1  2  3  4  5]\n原数组改变:\n[[99  1  2]\n [ 3  4  5]]\n\n\n拼接和堆叠数组：\n\n\n\n\n\n\nNote\n\n\n\n垂直堆叠和拼接需要列数相同，水平堆叠需要行数相同。\n\n\n\na = np.array([(1, 2),(3, 4)])\nb = np.ones((3, 2), dtype=np.int_)\nc = np.zeros((1, 2), dtype=np.int_)\n\nprint(f\"数组a:\\n{a}\")\nprint(f\"数组b:\\n{b}\")\nprint(f\"数组c:\\n{c}\")\n\nprint(f\"拼接三个数组:\\n{np.concatenate((a, b, c))}\")\n\nprint(f\"等价于垂直堆叠三个数组:\\n{np.vstack((a, b, c))}\")\n\nprint(f\"水平堆叠数组a和数组a:\\n{np.hstack((a, a))}\")\n\n数组a:\n[[1 2]\n [3 4]]\n数组b:\n[[1 1]\n [1 1]\n [1 1]]\n数组c:\n[[0 0]]\n拼接三个数组:\n[[1 2]\n [3 4]\n [1 1]\n [1 1]\n [1 1]\n [0 0]]\n等价于垂直堆叠三个数组:\n[[1 2]\n [3 4]\n [1 1]\n [1 1]\n [1 1]\n [0 0]]\n水平堆叠数组a和数组a:\n[[1 2 1 2]\n [3 4 3 4]]\n\n\n拆分数组：\n\narr = np.arange(1, 21).reshape(2, 10)\nprint(f\"以此数组为例:\\n{arr}\")\n\nprint(f\"拆分为2个形状相同的数组(相当于从第5列开始拆分):\\n{np.hsplit(arr, 2)}\")\n\nprint(f\"从第3列,第7列之后开始拆分:\\n{np.hsplit(arr, (3, 7))}\")\n\n以此数组为例:\n[[ 1  2  3  4  5  6  7  8  9 10]\n [11 12 13 14 15 16 17 18 19 20]]\n拆分为2个形状相同的数组(相当于从第5列开始拆分):\n[array([[ 1,  2,  3,  4,  5],\n       [11, 12, 13, 14, 15]]), array([[ 6,  7,  8,  9, 10],\n       [16, 17, 18, 19, 20]])]\n从第3列,第7列之后开始拆分:\n[array([[ 1,  2,  3],\n       [11, 12, 13]]), array([[ 4,  5,  6,  7],\n       [14, 15, 16, 17]]), array([[ 8,  9, 10],\n       [18, 19, 20]])]"
  },
  {
    "objectID": "NumPy教程.html#数学公式",
    "href": "NumPy教程.html#数学公式",
    "title": "7  NumPy简介与基本操作",
    "section": "数学公式",
    "text": "数学公式\n数组的运算可以帮助实现数学公式的运算，以均方误差公式为例：\n\\[MeanSquareError=\\frac{1}{n}\\sum_{i=1}^{n}{(Prediction_i-Y_i)^2}\\] 将Prediction和Y看作一维数组进行运算即可：\nerror = (1/n)*np.sum(np.square(prediction-y))\n\nprediction = np.array([2, 2, 2])\ny = np.array([1, 2, 3])\n\nprint(\"观测值:\", y)\nprint(\"预测值:\", prediction)\nprint(\"预测值和观测值之差:\", prediction-y)\n\nerror = (1/3)*np.sum(np.square(prediction-y))\nprint(\"均方误差:\", error)\n\n观测值: [1 2 3]\n预测值: [2 2 2]\n预测值和观测值之差: [ 1  0 -1]\n均方误差: 0.6666666666666666"
  },
  {
    "objectID": "NumPy教程.html#数组对象的读取和保存",
    "href": "NumPy教程.html#数组对象的读取和保存",
    "title": "7  NumPy简介与基本操作",
    "section": "数组对象的读取和保存",
    "text": "数组对象的读取和保存\n将数组对象存为filename.npy并读取：\n\narr = np.array([1,2,3])\nnp.save(\"arr\", arr)\nnp.load('arr.npy')\n\narray([1, 2, 3])\n\n\n也可以保存为文本并读取：\n\nnp.savetxt('arr.csv', arr)\nnp.loadtxt('arr.csv')\n\narray([1., 2., 3.])"
  },
  {
    "objectID": "安装.html",
    "href": "安装.html",
    "title": "8  Pandas安装",
    "section": "",
    "text": "使用Anaconda安装\n对于没有经验的小白来说，直接上手用代码来安装各种包可能有点困难，而Anaconda作为一个发行平台，可以非常轻松的安装除了Pandas之外的各种Python包（IPython、NumPy、 Matplotlib等）\n可以直接在jupyter代码块中安装\n\n# 在jupyter代码块中使用\nconda install pandas\n\n\n\n\n\n使用PyPI中的 pip 安装\n\n# 在命令行（终端）中使用\npip install pandas\n\n\n使用pip show pandas检验是否安装成功\n\n\n\n\n\n\nTip\n\n\n\n一般来说这是python自带的安装方式，但有时候你的虚拟环境没有或者服务器里的需要更新，可以参考文档\n\n\n\n安装pip的步骤\n\n首先，确保您已经安装了Python。Pip是Python的包管理工具，它通常随着Python的安装一起提供。\n打开终端（命令提示符）。\n输入以下命令来检查是否已安装pip：\n\n\n# 命令行中输入\npip --version\n\n# 在jupyter中输入 \n%pip --version\n\n如果已经安装了pip，您将看到版本号信息。否则，将显示错误信息或没有任何输出。\n如果未安装pip，可以使用以下方法进行安装：\n对于Windows操作系统：\n\n访问该链接\n右键点击页面上的”Raw”按钮，选择”另存为”，将文件保存在您的计算机上。\n打开命令提示符，导航到保存get-pip.py文件的目录。\n运行以下命令来安装pip：\n\n\npython get-pip.py\n\n\nLinux&MacOSWindows\n\n\n打开终端，运行以下命令来安装pip\n$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\npython get-pip.py\n\n\n使用Python自带的ensurepip模块来安装或升级pip。\nC:&gt; py -m ensurepip --upgrade"
  },
  {
    "objectID": "pandas处理什么样的数据.html#表格数据",
    "href": "pandas处理什么样的数据.html#表格数据",
    "title": "9  pandas处理什么样的数据",
    "section": "表格数据",
    "text": "表格数据\nPandas最常用于处理表格数据，例如CSV文件、Excel文件、数据库查询结果等。你可以使用Pandas读取这些数据，并对其进行各种操作，如过滤、排序、合并、聚合、计算统计指标等。\n当使用Pandas处理表格数据时，你可以使用DataFrame这个主要的数据结构。DataFrame是一个二维的标记数组，类似于电子表格或SQL表。\n\n# 1. 导入pandas包\nimport pandas as pd\n\n# 2. 假设data数据\ndata = {\n  \"calories\": [420, 380, 390],\n  \"duration\": [50, 40, 45]\n}\n\n# 3. 假设df，然后调用pd(pandas包)，将数据转换为DataFrame格式\ndf = pd.DataFrame(data)\n\n# 4. 打印df\ndf\n\n\n\n\n\n\n\n\ncalories\nduration\n\n\n\n\n0\n420\n50\n\n\n1\n380\n40\n\n\n2\n390\n45"
  },
  {
    "objectID": "pandas处理什么样的数据.html#时间序列数据",
    "href": "pandas处理什么样的数据.html#时间序列数据",
    "title": "9  pandas处理什么样的数据",
    "section": "时间序列数据",
    "text": "时间序列数据\nPandas提供了强大的时间序列功能，可以处理日期和时间相关的数据。你可以使用Pandas对时间序列数据进行重采样、滚动计算、时间窗口分析、时间序列绘图等操作。\n\nimport pandas as pd\n\ndate = pd.to_datetime(\"13th of June, 2023\")\n\ndate\n\nTimestamp('2023-06-13 00:00:00')\n\n\n可以使用DateTimeIndex和TimedeltaIndex来表示时间索引和时间间隔。\n\nimport pandas as pd\n# 创建一个包含日期范围的时间索引\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10', freq='D')\n\n# 创建一个DataFrame，并使用时间索引\ndata = pd.DataFrame({'Value': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]}, index=date_range)\n\n# 查看数据的前几行\ndata.head()\n\n\n\n\n\n\n\n\nValue\n\n\n\n\n2023-01-01\n10\n\n\n2023-01-02\n20\n\n\n2023-01-03\n30\n\n\n2023-01-04\n40\n\n\n2023-01-05\n50\n\n\n\n\n\n\n\n选取所需的时间序列数据，并进行计算\n\n# 通过日期索引获取某一天的数据\nday_data = data.loc['2023-01-05']\n\n# 通过日期范围索引获取一段时间内的数据\nrange_data = data.loc['2023-01-03':'2023-01-07']\n\n# 使用日期的年、月、日等属性进行切片\nyear_data = data[data.index.year == 2023]\nmonth_data = data[data.index.month == 1]\nday_data = data[data.index.day == 5]\n\n# 将数据按周进行重采样，计算每周的平均值\nweekly_data = data.resample('W').mean()\n\n# 将数据按月进行重采样，计算每月的总和\nmonthly_data = data.resample('M').sum()"
  },
  {
    "objectID": "pandas处理什么样的数据.html#缺失数据处理",
    "href": "pandas处理什么样的数据.html#缺失数据处理",
    "title": "9  pandas处理什么样的数据",
    "section": "缺失数据处理",
    "text": "缺失数据处理\nPandas提供了灵活的方法来处理缺失数据。你可以使用Pandas来检测和处理缺失值，填充缺失数据，或者根据缺失值进行数据筛选和计算。\n\n# 创建带有缺失数据的DataFrame\ndata = pd.DataFrame({'A': [1, 2, None, 4, 5],\n                     'B': [None, 2, 3, None, 6],\n\n                     'C': [1, 2, 3, 4, 5]})\n\n检查并统计缺失值\n\n# 检测每个单元格是否为缺失值\nmissing_values = data.isnull()\n\n# 统计每列的缺失值数量\nmissing_counts = data.isnull().sum()\n\n# 统计整个DataFrame的缺失值数量\ntotal_missing_count = data.isnull().sum().sum()\n\n对缺失值进行操作\n\n# 删除包含缺失值的行\ndata_dropna = data.dropna()\n\n# 删除全部为缺失值的列\ndata_dropna_cols = data.dropna(axis=1, how='all')\n\n# 填充缺失值为指定的常数\ndata_fillna = data.fillna(0)\n\n# 使用缺失值前面的值进行前向填充\ndata_ffill = data.fillna(method='ffill')\n\n# 使用缺失值后面的值进行后向填充\ndata_bfill = data.fillna(method='bfill')"
  },
  {
    "objectID": "pandas处理什么样的数据.html#数据清洗和转换",
    "href": "pandas处理什么样的数据.html#数据清洗和转换",
    "title": "9  pandas处理什么样的数据",
    "section": "数据清洗和转换",
    "text": "数据清洗和转换\nPandas可以用于数据清洗和转换的各种操作。你可以使用Pandas对数据进行重塑、合并、分组、变形等，以满足特定的分析需求。\n\n# 创建原始数据\ndata = pd.DataFrame({'Name': ['John', 'Emily', 'Michael', 'Emma'],\n                     'Age': [25, 30, 35, 28],\n                     'Gender': ['M', 'F', 'M', 'F'],\n                     'Salary': ['$5000', '$6000', '$4500', '$7000']})\n\n\n数据清洗\n清洗重复或者多余数据\n\n# 去除重复的行\ndata_cleaned = data.drop_duplicates()\n\n# 去除列中的空格\ndata_cleaned['Name'] = data_cleaned['Name'].str.strip()\n\n# 删除缺失值所在的行\ndata_cleaned = data_cleaned.dropna()\n\n\n\n数据转换\n将列表转换为系列（Series）\nseries = pd.Series(list)\n\nimport pandas as pd\n\n# 将列表转换为系列\nmy_list = [1, 2, 3, 4, 5]\nseries = pd.Series(my_list)\nseries\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n\n\n将系列（Series）转换为数据帧（DataFrame）\ndataframe = series.to_frame()\n\n# 将系列转换为数据帧\nseries = pd.Series([1, 2, 3, 4, 5])\ndataframe = series.to_frame()\ndataframe\n\n\n\n\n\n\n\n\n0\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n\n\n\n\n\n将数据帧（DataFrame）转换为列表（list）\nmy_list = df.values.tolist()\n\n# 将数据帧转换为列表\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\nmy_list = df.values.tolist()\nmy_list\n\n[[1, 4], [2, 5], [3, 6]]\n\n\n\n\n\n\n\n\nTip\n\n\n\n数据的清洗和转换是pandas最常使用的功能，之后我们会逐步拆解，进行详细说明"
  },
  {
    "objectID": "pandas处理什么样的数据.html#数据可视化",
    "href": "pandas处理什么样的数据.html#数据可视化",
    "title": "9  pandas处理什么样的数据",
    "section": "数据可视化",
    "text": "数据可视化\nPandas集成了Matplotlib库，可以通过简单的接口生成各种统计图表和可视化图形，以便更好地理解和呈现数据。\n\n# 创建数据\ndata = pd.DataFrame({'Month': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],\n                     'Sales': [100, 150, 120, 200, 180, 250],\n                     'Expenses': [80, 90, 100, 85, 95, 110]})\n\n# 折线图\ndata.plot(x='Month', y='Sales', kind='line')\n\n&lt;Axes: xlabel='Month'&gt;\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n虽然pandas也可以画图，但是还是静态图形，之后我们会详细说明更加简洁和酷炫的可视化库 Plotly库"
  },
  {
    "objectID": "pandas处理什么样的数据.html#数据建模和分析",
    "href": "pandas处理什么样的数据.html#数据建模和分析",
    "title": "9  pandas处理什么样的数据",
    "section": "数据建模和分析",
    "text": "数据建模和分析\nPandas还支持数据建模和分析的操作。你可以使用Pandas进行数据建模、特征工程、数据预处理等，然后将数据传递给机器学习库（如Scikit-learn）进行模型训练和预测。网上看到不错的数据预测案例"
  },
  {
    "objectID": "导入_导出数据.html#导入数据",
    "href": "导入_导出数据.html#导入数据",
    "title": "10  导入&导出数据",
    "section": "导入数据",
    "text": "导入数据\n\n导入本地数据\n\n读取CSV文件, 官方文档参数介绍\n\n第一步先点击data.csv下载文件\n\n获取数据data.csv下载地址，将csv文件下载到本地。建议大家创建一个夏令营文件夹，方便对新文件统一管理\n\n导入pandas包进行调用，import是导入包体，as是重命名为pd，尽量为缩写，方便使用\n设置变量df，方便后续调用（也可以不设置变量直接使用）；pd是pandas包的缩写，使用read_csv()函数；单引号内为本地CSV文件路径\ndf 执行变量\n\nTips：如果已经来到了文件所在路径，则可以直接使用pd.read_csv('data.csv')读取csv文件\n\n# 导入pandas包\nimport pandas as pd\n\n# 注意csv文件路径，读取CSV文件，默认分隔符为逗号\ndf = pd.read_csv('./example_data/data.csv') \n\n# 调用变量df\ndf\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n...\n...\n...\n...\n...\n\n\n164\n60\n105\n140\n290.8\n\n\n165\n60\n110\n145\n300.0\n\n\n166\n60\n115\n145\n310.2\n\n\n167\n75\n120\n150\n320.4\n\n\n168\n75\n125\n150\n330.4\n\n\n\n\n169 rows × 4 columns\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n此处直接使用df打印结果，是因为在pandas中默认使用DataFrame格式，相较于print()会更加清晰。\nDataFrame是Pandas中最常用的数据结构之一，它提供了一种二维表格的数据结构，类似于电子表格或关系型数据库中的数据表。DataFrame由行和列组成，每列可以包含不同的数据类型（例如整数、浮点数、字符串等）。\n\n\n遇到不熟悉的函数或者python库的时候，可以使用help()来查找相应文档，并且一般最下面会给一个例子\n\nhelp(pd.read_table)\n\n\n\n读取Excel文件, 官方文档参数介绍\n\n步骤同上，第一步先点击Financial_Sample.xlsx下载文件\n\n获取数据Financial_Sample.xlsx下载地址，将Excel文件下载到本地。\n\n导入pandas包进行调用；\n使用read_excel()函数；单引号内为本地Excel文件路径\ndf 执行变量\n\nTips：如果出现编码问题无法导入，可尝试将Excel文件，另存为为Utf-8格式，然后重新导入\n\n# 导入pandas包\nimport pandas as pd\n\n# 注意csv文件路径\ndf = pd.read_excel('./example_data/Financial Sample.xlsx') \n\n# 调用变量df，表格前五行\ndf.head()\n\n\n\n\n\n\n\n\nSegment\nCountry\nProduct\nDiscount Band\nUnits Sold\nManufacturing Price\nSale Price\nGross Sales\nDiscounts\nSales\nCOGS\nProfit\nDate\nMonth Number\nMonth Name\nYear\n\n\n\n\n0\nGovernment\nCanada\nCarretera\nNone\n1618.5\n3\n20\n32370.0\n0.0\n32370.0\n16185.0\n16185.0\n2014-01-01\n1\nJanuary\n2014\n\n\n1\nGovernment\nGermany\nCarretera\nNone\n1321.0\n3\n20\n26420.0\n0.0\n26420.0\n13210.0\n13210.0\n2014-01-01\n1\nJanuary\n2014\n\n\n2\nMidmarket\nFrance\nCarretera\nNone\n2178.0\n3\n15\n32670.0\n0.0\n32670.0\n21780.0\n10890.0\n2014-06-01\n6\nJune\n2014\n\n\n3\nMidmarket\nGermany\nCarretera\nNone\n888.0\n3\n15\n13320.0\n0.0\n13320.0\n8880.0\n4440.0\n2014-06-01\n6\nJune\n2014\n\n\n4\nMidmarket\nMexico\nCarretera\nNone\n2470.0\n3\n15\n37050.0\n0.0\n37050.0\n24700.0\n12350.0\n2014-06-01\n6\nJune\n2014\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n如果使用Jupyter，必须确保文件与当前工作目录在同一目录下，或者指定文件的绝对路径。绝对路径 vs 相对路径区别\n\n\n\n\n\n导入线上数据\n线上数据地址 https://www.w3schools.com/python/pandas/data.csv.txt\n\ndf = pd.read_csv('https://www.w3schools.com/python/pandas/data.csv.txt')\n\n# 打印前五个\ndf.head()\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n\n\n\n\n\n\n# 获取案例数据\nimport pandas as pd\ndf = pd.read_csv('https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/titanic.csv') \ndf.head()\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n\n\n\n\n参数介绍\n以下参数也适用于大部分pandas导入方式，也就是read_函数。\n\nfilepath_or_buffer：要读取的文件路径或文件对象。\nsep：字段分隔符，默认为逗号（,），可以使用其他字符或字符串作为分隔符。\nheader：指定作为列名的行号，默认为’infer’，表示使用文件中的第一行作为列名，可以设为None来表示没有列名。\nindex_col：指定作为索引列的列号或列名。\nusecols：要读取的列的列号或列名列表。\ndtype：指定列的数据类型。\nparse_dates：指定要解析为日期的列。\nskiprows：跳过指定的行数。\nna_values：指定用于表示缺失值的字符串列表。\nencoding：指定文件的编码方式。\n\n\nimport pandas as pd\n\n# 默认情况下\ndf1 = pd.read_csv('./example_data/data.csv')\ndf1.head()\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n\n\n\n\n\nheader：指定作为列名的行号，默认为’infer’，表示使用文件中的第一行作为列名，可以设为None来表示没有列名。\n\n# 指定第二行为列名\n\ndf1 = pd.read_csv('./example_data/data.csv', header = 1)\ndf1.head()\n\n\n\n\n\n\n\n\n60\n110\n130\n409.1\n\n\n\n\n0\n60\n117\n145\n479.0\n\n\n1\n60\n103\n135\n340.0\n\n\n2\n45\n109\n175\n282.4\n\n\n3\n45\n117\n148\n406.0\n\n\n4\n60\n102\n127\n300.0\n\n\n\n\n\n\n\nindex_col：指定作为索引列的列号或列名。比如index_col=\"Duration\"，或者第一列index_col=0\n\ndf2 = pd.read_csv('./example_data/data.csv', index_col=\"Duration\")\ndf2.head()\n\n\n\n\n\n\n\n\nPulse\nMaxpulse\nCalories\n\n\nDuration\n\n\n\n\n\n\n\n60\n110\n130\n409.1\n\n\n60\n117\n145\n479.0\n\n\n60\n103\n135\n340.0\n\n\n45\n109\n175\n282.4\n\n\n45\n117\n148\n406.0\n\n\n\n\n\n\n\nencoding：指定文件的编码方式。使用utf-8编码是因为它是一种广泛支持的字符编码，能够处理几乎所有的文本数据。出现编码问题用这个大概率就对了～\n\ndf3 = pd.read_csv('./example_data/data.csv', encoding='utf-8',index_col=0)\ndf3.head()\n\n\n\n\n\n\n\n\nPulse\nMaxpulse\nCalories\n\n\nDuration\n\n\n\n\n\n\n\n60\n110\n130\n409.1\n\n\n60\n117\n145\n479.0\n\n\n60\n103\n135\n340.0\n\n\n45\n109\n175\n282.4\n\n\n45\n117\n148\n406.0\n\n\n\n\n\n\n\n\n\n常见错误\n\n错误：FileNotFoundError: [Errno 2] No such file or directory: ‘data.csv’\n解决方法：检查文件路径和文件名是否正确，并确保文件存在于指定位置。\n错误：ParserError: Error tokenizing data. C error: Expected N fields in line M, saw K\n解决方法：确保文件中的数据与指定的分隔符一致，并且每行数据的字段数目相同。\n错误：UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xff in position 0: invalid start byte\n解决方法：尝试指定正确的文件编码，如encoding=’utf-8-sig’来处理带有BOM（字节顺序标记）的文件。"
  },
  {
    "objectID": "导入_导出数据.html#导出数据",
    "href": "导入_导出数据.html#导出数据",
    "title": "10  导入&导出数据",
    "section": "导出数据",
    "text": "导出数据\n\n导出CSV文件\n在 pandas 中，可以使用 to_csv()方法将数据导出为文本格式（如 CSV 文件）。to_csv() 方法接受一个参数，即导出的文件路径，可以是相对路径或绝对路径\n一般我们的导出对象是 DataFrame 和 Series，将这些数据结构中的数据保存到一个 CSV 文件中。就算是字典或者Numpy的数据结构，也可以转换为DataFrame后进行导出。\n\n创建名为data的字典，作为示例数据；\n调用pandas，将字典转换为DataFrame格式；\n使用to_csv，导出并保存为csv文件，同时命名文件为 output.csv\nindex=False 参数表示不包含行索引。\n\n\nimport pandas as pd\n\n# 创建 DataFrame 示例数据\ndata = {'Name': ['Jack', 'Luxue', 'Wenxi'],\n        'Age': [25, 30, 35],\n        'City': ['New York', 'London', 'Paris']}\n\ndf = pd.DataFrame(data)\n\n# 导出为 CSV 文件，默认为当前路径\ndf.to_csv('output.csv', index=False)\n\nSeries 导出：Series 是 pandas 中的另一个常见数据结构，它是一维标记数组。可以使用 to_csv()、to_excel() 等方法将 Series 导出为 CSV、Excel 等格式。\n\n# 创建 Series 示例数据\ndata = pd.Series([1, 2, 3, 4, 5])\n\n# 导出为 CSV 文件\ndata.to_csv('output.csv', index=False)\n\n# 导出为 Excel 文件\ndata.to_excel('output.xlsx', index=False)\n\n\n\n导出Excel文件\n当涉及到导出为 Excel 文件时，让我们考虑一个简单的案例。假设我们有一个包含学生考试成绩的 DataFrame，我们希望将其导出为一个名为 grades.xlsx 的 Excel 文件。\n\nimport pandas as pd\n\n# 创建一个示例的 DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie'],\n        'Math': [85, 92, 78],\n        'English': [90, 88, 95],\n        'Science': [80, 85, 92]}\n\ndf = pd.DataFrame(data)\n\n# 使用 to_excel() 方法将 DataFrame 导出为 Excel 文件\ndf.to_excel('grades.xlsx', index=False)\n\n\n\n参数介绍\n\nsheet_name：指定要导出到的工作表名称，默认为 ‘Sheet1’。\nna_rep：指定缺失值的表示，默认为空字符串。\ncolumns：指定要导出的列名。可以传入一个列表来指定特定的列，或者使用布尔索引来选择要导出的列。\nheader：指定是否将列名包含在导出的文件中，默认为 True。\nindex：指定是否将行索引包含在导出的文件中，默认为 True。\nindex_label：指定行索引的标签名称，默认为 None。\nstartrow 和 startcol：指定数据在工作表中的起始行和起始列，默认从第一行第一列开始。\n\nsheet_name如果我们想将数据保存在特定的工作表中，可以使用 sheet_name 参数指定工作表的名称\n\ndf.to_excel('grades.xlsx', sheet_name='Exam Scores', index=False)\n\ncolumns 如果我们只想导出特定的列，可以使用 columns 参数来指定要导出的列名，比如只导出 “Name”、“Math” 和 “English” 列的数据。\n\ndf.to_excel('grades.xlsx', columns=['Name', 'Math', 'English'], index=False)\n\n\n\n\n\n连接MySQL数据库导入导出数据（拓展）\n\n步骤1：安装必要的库\n在开始之前，确保已经安装了以下库：\nPandas：用于数据处理和操作。\nSQLAlchemy：用于数据库连接和交互\n可以使用以下命令通过pip安装它们：\n\npip install pandas sqlalchemy\n\n\n\n步骤2：链接数据库\n首先，我们需要使用SQLAlchemy来建立与数据库的连接。根据使用的数据库类型（如MySQL、SQLite、PostgreSQL等），使用适当的连接字符串和数据库驱动程序。\n以下是使用SQLite数据库的示例代码：\n\nimport sqlalchemy\n\n# 建立与数据库的连接\nengine = sqlalchemy.create_engine('sqlite:///path/to/database.db')\n\n\n\n\n\n\n\nTip\n\n\n\n将path/to/database.db替换为实际的数据库文件路径或连接字符串\n\n\n\n\n步骤3：导入数据\n有几种方法可以使用Pandas从数据库中导入数据。最简单的方法是使用read_sql()函数，该函数接受一个SQL查询语句并将结果读取为DataFrame对象。\n以下是使用read_sql()函数导入数据的示例代码：\n\nimport pandas as pd\n\n# 执行SQL查询并将结果读取为DataFrame\nquery = 'SELECT * FROM table_name'\ndf = pd.read_sql(query, engine)\n\n# 打印DataFrame\nprint(df)\n\n\n\n\n\n\n\nTip\n\n\n\n将table_name替换为要查询的实际表名。\n\n\n\n\n步骤4：导出数据\n同样，使用Pandas可以将DataFrame中的数据导出到数据库中。可以使用to_sql()函数将DataFrame写入数据库表。\n以下是使用to_sql()函数导出数据的示例代码\n\n# 将DataFrame写入数据库表\ndf.to_sql('table_name', engine, if_exists='replace', index=False)\n\n\n\n\n\n\n\nTip\n\n\n\n将table_name替换为要写入的实际表名。if_exists=’replace’表示如果表已经存在，则替换它。index=False表示不将DataFrame的索引写入数据库。"
  },
  {
    "objectID": "选取数据.html#根据条件筛选行列",
    "href": "选取数据.html#根据条件筛选行列",
    "title": "11  选取数据",
    "section": "根据条件筛选行列",
    "text": "根据条件筛选行列\n假设我想知道十八岁以下的乘客信息\n\n\nCode\ndf[df[\"Age\"] &lt; 18].head()\n\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n7\n8\n0\n3\nPalsson, Master. Gosta Leonard\nmale\n2.0\n3\n1\n349909\n21.0750\nNaN\nS\n\n\n9\n10\n1\n2\nNasser, Mrs. Nicholas (Adele Achem)\nfemale\n14.0\n1\n0\n237736\n30.0708\nNaN\nC\n\n\n10\n11\n1\n3\nSandstrom, Miss. Marguerite Rut\nfemale\n4.0\n1\n1\nPP 9549\n16.7000\nG6\nS\n\n\n14\n15\n0\n3\nVestrom, Miss. Hulda Amanda Adolfina\nfemale\n14.0\n0\n0\n350406\n7.8542\nNaN\nS\n\n\n16\n17\n0\n3\nRice, Master. Eugene\nmale\n2.0\n4\n1\n382652\n29.1250\nNaN\nQ\n\n\n\n\n\n\n\nDataFrames 可以通过多种方式进行过滤，其中最直观的是使用布尔索引"
  },
  {
    "objectID": "添加新列.html#添加新列",
    "href": "添加新列.html#添加新列",
    "title": "12  增删排序(DataFrame)",
    "section": "添加新列",
    "text": "添加新列\n可以看到目前的案例中是四行三列，如果我想添加新的一列“薪资”，有两种方法：\n\n方法一： df[‘列名’] = 值\n\n\nCode\n\ndf['工资'] = [5000, 6000, '', 7000]\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n工资\n\n\n\n\n0\n张三\n25\nM\n5000\n\n\n1\n李四\n30\nF\n6000\n\n\n2\n王五\n35\nM\n\n\n\n3\n赵六\n28\nF\n7000\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n[值]必须对应行数，这里有四个人就必须有四个值，没有则可以为空白' ' 或者 'NA'；[]里面的顺序也会保持一样\n\n\n\n\n方法二：使用assign()\n\n\nCode\n\ndf = df.assign(工资=[5000, 6000, 4500, 7000])\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n工资\n\n\n\n\n0\n张三\n25\nM\n5000\n\n\n1\n李四\n30\nF\n6000\n\n\n2\n王五\n35\nM\n4500\n\n\n3\n赵六\n28\nF\n7000\n\n\n\n\n\n\n\n我们可以在原有表格中添加新列，也可以从其他数据源（如文件、数据库等）中导入数据，并将其作为新列添加到DataFrame中。"
  },
  {
    "objectID": "添加新列.html#添加新行",
    "href": "添加新列.html#添加新行",
    "title": "12  增删排序(DataFrame)",
    "section": "添加新行",
    "text": "添加新行\n\n方法一： 使用append方法\ndf = df.append(new_row, ignore_index=True)\n其中，new_row是一个包含新行数据的字典或Series对象。\n\n\nCode\n# 重新选取数据\ndata = {'姓名': ['张三', '李四', '王五', '赵六'],\n        '年龄': [25, 30, 35, 28],\n        '性别': ['M', 'F', 'M', 'F']}\n\ndf = pd.DataFrame(data)\n\n\n\n\nCode\n#`ignore_index=True`是确保新行的索引与原始DataFrame的索引保持一致。\n\nnew_row = {'姓名': '熊大', '年龄': 35, '性别': 'M'}\n\ndf = df.append(new_row, ignore_index=True)\ndf\n\n\n/var/folders/fx/3rtntmd93wg4hsmfkcgfpq840000gn/T/ipykernel_42888/3717194637.py:5: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(new_row, ignore_index=True)\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵六\n28\nF\n\n\n4\n熊大\n35\nM\n\n\n\n\n\n\n\n\n\n方法二：使用concat()\n先创建一个新的DataFrame，然后将其与原始DataFrame进行合并\n\n\nCode\nnew_row = {'姓名': '熊二', '年龄': 30, '性别': 'M'}\n\nnew_df = pd.DataFrame([new_row])\n\ndf = pd.concat([df, new_df], ignore_index=True)\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵六\n28\nF\n\n\n4\n熊大\n35\nM\n\n\n5\n熊二\n30\nM"
  },
  {
    "objectID": "添加新列.html#删除行列",
    "href": "添加新列.html#删除行列",
    "title": "12  增删排序(DataFrame)",
    "section": "删除行/列",
    "text": "删除行/列\n\n使用drop方法删除列\ndf = df.drop('column_name', axis=1)\n需要提供要删除的列名，然后指定axis=1表示按列进行操作。删除列后，DataFrame会自动调整列的顺序。\n\n\nCode\ndf = df.drop('性别', axis=1)\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵六\n28\n\n\n4\n熊大\n35\n\n\n5\n熊二\n30\n\n\n\n\n\n\n\n\n\n使用drop方法删除行\ndf = df.drop(row_index)\n使用drop方法根据行的索引来删除特定的行\n\n\nCode\n# 删除第五行数据\ndf = df.drop(5)\ndf\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵六\n28\n\n\n4\n熊大\n35"
  },
  {
    "objectID": "添加新列.html#重命名列",
    "href": "添加新列.html#重命名列",
    "title": "12  增删排序(DataFrame)",
    "section": "重命名列",
    "text": "重命名列\n\n使用rename方法：\ndf = df.rename(columns={'old_column_name': 'new_column_name'})\n其中，old_column_name是要重命名的旧列名，new_column_name是新的列名。\n\n\nCode\ndf = df.rename(columns={'姓名': '乘客id', '年龄':'乘客年龄'})\ndf\n\n\n\n\n\n\n\n\n\n乘客id\n乘客年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵六\n28\n\n\n4\n熊大\n35"
  },
  {
    "objectID": "添加新列.html#按值排序",
    "href": "添加新列.html#按值排序",
    "title": "12  增删排序(DataFrame)",
    "section": "按值排序",
    "text": "按值排序\n\n使用sort_values方法：\ndf = df.sort_values(by='column_name', ascending=True)\n其中，column_name是你想要按其值进行排序的列名。ascending=True表示按升序排序，若要按降序排序，将ascending设置为False。\n通过sort_values方法，你可以根据特定列的值对DataFrame进行排序。你可以选择按单个列的值排序，也可以按多个列的值排序，只需在by参数中提供相应的列名列表即可。\n\n\nCode\ndf = df.sort_values(by='乘客年龄', ascending=True)\ndf\n\n\n\n\n\n\n\n\n\n乘客id\n乘客年龄\n\n\n\n\n0\n张三\n25\n\n\n3\n赵六\n28\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n4\n熊大\n35"
  },
  {
    "objectID": "Pandas计算重塑合并最终版本.html",
    "href": "Pandas计算重塑合并最终版本.html",
    "title": "13  如何计算汇总统计",
    "section": "",
    "text": "describe()的用法\ndescribe() 是 Pandas 中一个常用的基础操作，用于生成关于 DataFrame 列的统计摘要。\n使用 describe() 方法，你可以获得以下统计信息：\n计数（count）：非缺失值的数量。\n均值（mean）：平均值。\n标准差（std）：标准差衡量数据的离散程度。\n最小值（min）和最大值（max）：数据列的最小和最大值。\n四分位数（25%，50%，75%）：数据的四个百分位数，用于描述数据的分布。\n示例代码：\n\nimport pandas as pd\n\n# 创建DataFrame示例\ndata = {'Name': ['John', 'Emma', 'Alex', 'Sophia', 'James'],\n        'Age': [25, 28, 22, 30, 32],\n        'Height': [175, 162, 180, 158, 170],\n        'Weight': [70, 58, 75, 52, 68]}\ndf = pd.DataFrame(data)\n\n# 查看数值型列的汇总统计\nsummary_stats = df.describe()\nmean_age = df['Age'].mean()\nmedian_height = df['Height'].median()\nmax_weight = df['Weight'].max()\n\nprint(summary_stats)\nprint(\"Mean Age:\", mean_age)\nprint(\"Median Height:\", median_height)\nprint(\"Max Weight:\", max_weight)\n\n             Age      Height     Weight\ncount   5.000000    5.000000   5.000000\nmean   27.400000  169.000000  64.600000\nstd     3.974921    9.055385   9.370165\nmin    22.000000  158.000000  52.000000\n25%    25.000000  162.000000  58.000000\n50%    28.000000  170.000000  68.000000\n75%    30.000000  175.000000  70.000000\nmax    32.000000  180.000000  75.000000\nMean Age: 27.4\nMedian Height: 170.0\nMax Weight: 75\n\n\n常用的计算汇总统计的方法：\n\ndescribe()方法：计算数值型列的基本统计信息，包括计数、均值、标准差、最小值、25%、50%和75%分位数以及最大值。\nmean()方法：计算数值型列的平均值。\nmedian()方法：计算数值型列的中位数。\nmin()方法：计算数值型列的最小值。\nmax()方法：计算数值型列的最大值。\nsum()方法：计算数值型列的总和。\ncount()方法：计算非缺失值的数量。\nstd()方法：计算数值型列的标准差。\nvar()方法：计算数值型列的方差。\n\n通过查看数值型列的汇总统计，可以快速了解数据的整体分布和统计特征，有助于进行数据分析和洞察。\n\n\nsize和count\n在Pandas中，size和count是用于计算分组数据的两个方法，常常与groupby一起使用。它们可以提供关于每个分组的计数信息，但在计算方式和返回结果上有一些区别。\nsize方法：\n\nsize方法用于计算每个分组中的元素数量，包括缺失值。\n返回的结果是一个Series，其索引是分组键，值是每个分组中的元素数量。\nsize方法不考虑缺失值，即使某个分组中存在缺失值，它也会将其计算为有效元素。\n\ncount方法：\n\ncount方法用于计算每个分组中非缺失值的数量。\n返回的结果是一个Series，其索引是分组键，值是每个分组中的非缺失值的数量。\ncount方法排除了缺失值，只计算非缺失值的数量。\n\n示例，演示如何使用size和count方法结合groupby对数据进行计数：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {'Group': ['A', 'A', 'B', 'B', 'B'],\n        'Value': [1, 2, 3, None, 5]}\ndf = pd.DataFrame(data)\n\n# 使用groupby和size计算每个分组的元素数量\nsize_result = df.groupby('Group').size()\n\n# 使用groupby和count计算每个分组的非缺失值数量\ncount_result = df.groupby('Group').count()\n\nprint(\"Size结果:\")\nprint(size_result)\nprint(\"\\nCount结果:\")\nprint(count_result)\n\nSize结果:\nGroup\nA    2\nB    3\ndtype: int64\n\nCount结果:\n       Value\nGroup       \nA          2\nB          2\n\n\n在上述示例中，我们创建了一个DataFrame，并使用Group列进行分组。然后，我们分别使用size和count方法对分组后的数据进行计数。可以看到，size方法返回了每个分组的元素数量，而count方法返回了每个分组的非缺失值数量。在分组B中，有一个缺失值，因此size方法返回3，而count方法返回2。\n这两个方法的使用可以根据具体需求来选择。如果需要考虑缺失值并计算所有元素的数量，可以使用size方法；如果只关心非缺失值的数量，可以使用count方法。\n\n\n如何重塑表格布局\n\nsort的用法\n在Pandas中，sort_values和sort_index是用于对DataFrame或Series进行排序的两个常用方法。\nsort_values方法：\n\nsort_values方法用于按照指定的列或多个列的值对DataFrame或Series进行排序。\n可以通过by参数指定要排序的列或多个列，以列表形式提供。\n可以使用ascending参数来控制排序的升序或降序，默认为True（升序）。\n可以使用inplace参数来指定是否原地修改DataFrame或Series，默认为False，即返回排序后的副本。\n示例：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [3, 2, 1], 'B': [1, 3, 2]})\nsorted_df = df.sort_values(by='A', ascending=True)\n\n\n上述代码将按照’A’列的值对DataFrame df 进行升序排序，并将结果存储在sorted_df中。\n\nsort_index方法：\n\nsort_index方法用于根据索引对DataFrame或Series进行排序。\n可以使用axis参数指定要排序的轴，axis=0表示按行索引排序，axis=1表示按列索引排序。\n可以使用ascending参数来控制排序的升序或降序，默认为True（升序）。\n可以使用inplace参数来指定是否原地修改DataFrame或Series，默认为False，即返回排序后的副本。\n示例：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [3, 2, 1], 'B': [1, 3, 2]}, index=[2, 1, 3])\nsorted_df = df.sort_index(axis=0, ascending=True)\n\n\n上述代码将按照行索引对DataFrame df 进行升序排序，并将结果存储在sorted_df中。\n\n排序操作可以根据具体需求来选择使用sort_values还是sort_index。如果希望根据列的值进行排序，使用sort_values方法；如果希望根据索引进行排序，使用sort_index方法。\n\n在Pandas中，可以使用不同的方法来重新塑造（reshape）表格布局，以满足特定的数据分析和处理需求。以下是一些常用的重塑表格布局的方法：\n\n\npivot()方法\npivot()方法：用于将长格式（long format）的数据转换为宽格式（wide format），根据指定的列创建新的列，并使用列值进行填充。\n示例，展示如何使用pivot()方法将数据从长格式转换为宽格式：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndata = {'Name': ['John', 'John', 'Emma', 'Emma', 'Alex', 'Alex'],\n        'Subject': ['Math', 'Science', 'Math', 'Science', 'Math', 'Science'],\n        'Score': [85, 92, 78, 88, 90, 85]}\ndf = pd.DataFrame(data)\n\n# 使用pivot方法重塑表格布局\npivot_df = df.pivot(index='Name', columns='Subject', values='Score')\npivot_df\n\n\n\n\n\n\n\nSubject\nMath\nScience\n\n\nName\n\n\n\n\n\n\nAlex\n90\n85\n\n\nEmma\n78\n88\n\n\nJohn\n85\n92\n\n\n\n\n\n\n\n\n\nmelt()方法\n在Pandas中，melt()是一个用于将宽格式（wide format）的数据转换为长格式（long format）的方法。它将数据从列中展开成为更长的格式，使得数据更适合进行分析和可视化。\nmelt()方法的语法如下：\nDataFrame.melt(id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None)\n参数说明：\n\nid_vars：可选参数，指定要保留的列名，不进行展开操作。\nvalue_vars：可选参数，指定要进行展开操作的列名。如果未指定，则默认展开所有未指定为id_vars的列。\nvar_name：可选参数，指定展开后的列名的名称。\nvalue_name：可选参数，指定展开后的值的列名的名称，默认为value。\ncol_level：可选参数，用于多层索引列的级别。\n\n下面是一个示例，演示如何使用melt()方法将宽格式的数据转换为长格式：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Math': [90, 80, 70],\n    'Science': [95, 85, 75],\n    'History': [92, 82, 72]\n}\ndf = pd.DataFrame(data)\n\n# 使用melt()方法进行数据转换\nmelted_df = df.melt(id_vars='Name', value_vars=['Math', 'Science', 'History'], var_name='Subject', value_name='Score')\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n转换后的DataFrame:\")\nmelted_df\n\n原始DataFrame:\n      Name  Math  Science  History\n0    Alice    90       95       92\n1      Bob    80       85       82\n2  Charlie    70       75       72\n\n转换后的DataFrame:\n\n\n\n\n\n\n\n\n\nName\nSubject\nScore\n\n\n\n\n0\nAlice\nMath\n90\n\n\n1\nBob\nMath\n80\n\n\n2\nCharlie\nMath\n70\n\n\n3\nAlice\nScience\n95\n\n\n4\nBob\nScience\n85\n\n\n5\nCharlie\nScience\n75\n\n\n6\nAlice\nHistory\n92\n\n\n7\nBob\nHistory\n82\n\n\n8\nCharlie\nHistory\n72\n\n\n\n\n\n\n\n\n\nstack()方法\nstack()方法：\n在Pandas中，stack()是一个用于对DataFrame进行堆叠操作的方法。它将列标签（Column labels）转换为行索引（Row index），将数据从宽格式转换为长格式，从而生成一个更紧凑的DataFrame。\nstack()方法的语法如下：\nDataFrame.stack(level=-1, dropna=True)\n参数说明：\n\nlevel：可选参数，用于多层索引列的级别。默认值为-1，表示堆叠所有列。\ndropna：可选参数，指定是否删除包含缺失值的行，默认为True。\n\n示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob'],\n    'Math': [90, 80],\n    'Science': [95, 85],\n    'History': [92, 82]\n}\ndf = pd.DataFrame(data)\n\n# 使用stack()方法进行堆叠操作\nstacked_df = df.set_index('Name').stack().reset_index()\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n堆叠后的DataFrame:\")\nstacked_df\n\n原始DataFrame:\n    Name  Math  Science  History\n0  Alice    90       95       92\n1    Bob    80       85       82\n\n堆叠后的DataFrame:\n\n\n\n\n\n\n\n\n\nName\nlevel_1\n0\n\n\n\n\n0\nAlice\nMath\n90\n\n\n1\nAlice\nScience\n95\n\n\n2\nAlice\nHistory\n92\n\n\n3\nBob\nMath\n80\n\n\n4\nBob\nScience\n85\n\n\n5\nBob\nHistory\n82\n\n\n\n\n\n\n\n\n\nunstack()方法\n在Pandas中，unstack()是用于将表格中的行索引转换为列索引，将数据从长格式转换为宽格式。\nunstack()方法的语法如下：\nDataFrame.unstack(level=-1, fill_value=None)\n参数说明：\n\nlevel：可选参数，用于指定要展开的层次化索引的级别。默认值为-1，表示展开最内层索引。\nfill_value：可选参数，用于指定填充缺失值的值。\n\n示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob'],\n    'Subject': ['Math', 'Science'],\n    'Score': [90, 80]\n}\ndf = pd.DataFrame(data)\n\n# 将DataFrame进行设置层次化索引\nindexed_df = df.set_index(['Name', 'Subject'])\n\n# 使用unstack()方法进行展开操作\nunstacked_df = indexed_df.unstack()\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n展开后的DataFrame:\")\nunstacked_df\n\n原始DataFrame:\n    Name  Subject  Score\n0  Alice     Math     90\n1    Bob  Science     80\n\n展开后的DataFrame:\n\n\n\n\n\n\n\n\n\nScore\n\n\nSubject\nMath\nScience\n\n\nName\n\n\n\n\n\n\nAlice\n90.0\nNaN\n\n\nBob\nNaN\n80.0\n\n\n\n\n\n\n\n在上述示例中，原始数据包含学生的姓名、科目和分数。通过使用pivot()方法，将姓名作为行索引，科目作为列索引，并将分数填充到相应的单元格中，得到了以学生姓名为行、科目为列的宽格式表格布局。\n\n\n\n如何合并多个表中的数据\n在Pandas中，可以使用不同的方法来合并（merge）多个表中的数据。以下是一些常用的合并数据的方法：\n\nconcat()方法\n在Pandas中，concat()是一个用于沿指定轴（行或列）将多个DataFrame对象进行合并的方法。它可以将多个DataFrame对象按照指定的方式进行连接，并返回一个合并后的DataFrame。以下是关于concat()方法的解释和示例说明：\nconcat()方法的语法如下：\npd.concat(objs, axis=0, join='outer', ignore_index=False)\n参数说明：\n\nobjs：要合并的DataFrame对象列表或字典。\naxis：可选参数，指定合并的轴。默认为0，表示按行合并；1表示按列合并。\njoin：可选参数，指定连接的方式。默认为'outer'，表示按照并集进行连接；'inner'表示按照交集进行连接。\nignore_index：可选参数，指定是否忽略合并后的索引。默认为False，表示保留原始索引。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ndf2 = pd.DataFrame({'A': [7, 8, 9], 'B': [10, 11, 12]})\n\n# 使用concat()方法进行合并操作\nmerged_df = pd.concat([df1, df2])\n\nprint(\"合并后的DataFrame:\")\nmerged_df\n\n合并后的DataFrame:\n\n\n\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\n1\n4\n\n\n1\n2\n5\n\n\n2\n3\n6\n\n\n0\n7\n10\n\n\n1\n8\n11\n\n\n2\n9\n12\n\n\n\n\n\n\n\n\n\nmerge()方法\n在Pandas中，merge()是一个用于合并（或连接）多个DataFrame对象的方法。它基于指定的键（或多个键）将多个DataFrame按照指定的方式进行连接，并返回一个合并后的DataFrame。\nmerge()方法的语法如下：\npd.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True)\n参数说明：\n\nleft：左侧的DataFrame对象。\nright：右侧的DataFrame对象。\nhow：可选参数，指定连接方式。默认为'inner'，表示按照键的交集进行连接；'outer'表示按照键的并集进行连接；'left'表示按照左侧DataFrame的键进行连接；'right'表示按照右侧DataFrame的键进行连接。\non：可选参数，用于指定连接的键。可以是一个列名的字符串，或多个列名组成的列表。\nleft_on：可选参数，用于指定左侧DataFrame连接键的列名或列名列表。\nright_on：可选参数，用于指定右侧DataFrame连接键的列名或列名列表。\nleft_index：可选参数，指定是否使用左侧DataFrame的索引作为连接键。\nright_index：可选参数，指定是否使用右侧DataFrame的索引作为连接键。\nsort：可选参数，指定是否按照连接键进行排序。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6], 'Key': ['K1', 'K2', 'K3']})\ndf2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12], 'Key': ['K2', 'K3', 'K4']})\n\n# 使用merge()方法进行合并操作\nmerged_df = pd.merge(df1, df2, on='Key')\n\nprint(\"合并后的DataFrame:\")\nmerged_df\n\n合并后的DataFrame:\n\n\n\n\n\n\n\n\n\nA\nB\nKey\nC\nD\n\n\n\n\n0\n2\n5\nK2\n7\n10\n\n\n1\n3\n6\nK3\n8\n11\n\n\n\n\n\n\n\n\n\njoin()方法\n在Pandas中，join()是一个用于基于索引或列之间的关系将两个DataFrame对象进行连接的方法。它类似于SQL中的JOIN操作，可以根据指定的连接键将两个DataFrame进行合并，并返回一个合并后的DataFrame。\njoin()方法的语法如下：\nDataFrame.join(other, on=None, how='left', lsuffix='', rsuffix='', sort=False)\n参数说明：\n\nother：要连接的另一个DataFrame对象。\non：可选参数，用于指定连接键。可以是一个列名的字符串，或多个列名组成的列表。如果未指定，则根据索引进行连接。\nhow：可选参数，指定连接方式。默认为'left'，表示按照左侧DataFrame的索引或列进行连接；'right'表示按照右侧DataFrame的索引或列进行连接；'inner'表示按照两个DataFrame共有的索引或列进行连接；'outer'表示按照两个DataFrame的并集进行连接。\nlsuffix：可选参数，用于处理连接时重叠列名的后缀（左侧DataFrame）。\nrsuffix：可选参数，用于处理连接时重叠列名的后缀（右侧DataFrame）。\nsort：可选参数，指定是否按照连接键进行排序。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}, index=['K1', 'K2', 'K3'])\ndf2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12]}, index=['K2', 'K3', 'K4'])\n\n# 使用join()方法进行连接操作\njoined_df = df1.join(df2)\n\nprint(\"连接后的DataFrame:\")\njoined_df\n\n连接后的DataFrame:\n\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nK1\n1\n4\nNaN\nNaN\n\n\nK2\n2\n5\n7.0\n10.0\n\n\nK3\n3\n6\n8.0\n11.0\n\n\n\n\n\n\n\n\n\n补充：T（Transpose）转置\n在Pandas中，T（Transpose）是一个用于转置数据的方法。转置操作会将DataFrame或Series的行和列进行交换，从而生成一个新的转置后的数据结构。以下是关于Pandas中的T转置的一些知识点：\n\nDataFrame的转置： 转置DataFrame时，行索引将会变成转置前的列索引，列索引将会变成转置前的行索引。可以使用T方法来执行转置操作，例如：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ntransposed_df = df.T\n\n上述代码将创建一个DataFrame df，然后使用T方法将其转置，结果将会存储在transposed_df中。\n\nSeries的转置： 转置一个Series对象会生成一个具有单一列的DataFrame，行索引将会保持不变，而列索引将会变为转置前的索引值。可以使用T方法对Series进行转置，例如：\n\n\nimport pandas as pd\n\nseries = pd.Series([1, 2, 3, 4], index=['A', 'B', 'C', 'D'])\ntransposed_series = series.T\n\n上述代码将创建一个Series series，然后使用T方法将其转置，结果将会存储在transposed_series中。\n\n转置对数据结构的影响： 转置操作不会改变原始数据结构，而是生成一个新的转置后的数据结构。原始数据结构保持不变，只是行和列的排列顺序发生了变化。\n转置的应用： 转置操作常用于需要改变数据结构的情况，例如在数据分析和处理过程中，可以使用转置来更改数据的布局以满足特定的分析需求。\n\n需要注意的是，转置操作可能会导致数据结构的变化，因此在进行转置操作之后，索引和列名可能需要进行调整以适应新的结构。"
  },
  {
    "objectID": "time_data.html",
    "href": "time_data.html",
    "title": "14  使用Pandas处理时间序列数据",
    "section": "",
    "text": "1. Pandas中的时间序列数据\nPandas中有6种关于时间序列数据的常见对象，分别是timestamp、datetimeindex、period、periodindex、以时间为元素的series和以时间索引的dataframe。\nPandas时序处理中最常见的两种数据类型为datetime和timedelta。\n\ndatetime\ndatetime即既有日期date，又有时间time的数据，表示一个具体的时间点（时间戳）。\ngraph TD;\ndatetime --&gt; date:2023-06-14;\ndatetime --&gt; time:12:00:00;\ntimedelta\ntimedelta表示两个时间点之差。如2023-01-01和2023-01-02之间的timedelta即为一天。\n\n\n\n2. 文本转换\n一般情况下，从.csv文件中导入的数据后，Dataframe中对应的时间列是字符串的形式，Pandas中提供了to_datetime()函数将字符串转换为datetime对象，并将其设置为Dataframe的索引。在Pandas中，这种类似于标准库中的日期时间对象称为：datetime64、datetime.datetime、pandas.Timestamp。\nimport pandas as pd\n\n# 创建包含字符串时间列数据的dataframe\ndata = {'date': ['20230601', '20230602', '20230603', '20230604']}\ndf = pd.DataFrame(data)\n# 展示dataframe\ndf\n# 输出结果为\n#          date\n# 0  20230601\n# 1  20230602\n# 2  20230603\n# 3  20230604\n# 将字符串时间列转换为datetime64格式的对象\ndf['date'] = pd.to_datetime(df['date'])\n\n# 打印转换后的结果\ndf\n\n# 输出结果为\n#         date\n# 0 2023-06-01\n# 1 2023-06-02\n# 2 2023-06-03\n# 3 2023-06-04\n将字符串数据转换为datetime64对象后，这些时间日期数据就具有了可比性，这样一来，我们就可以用它们来获取时间序列的长度。\n# 计算时间序列的长度\ntime_length = df['date'].max() - df['date'].min()\n\n# 打印时间序列的长度\nprint(\"时间序列的长度：\", time_length)\n\n# 输出结果为\n# 时间序列的长度： 3 days 00:00:00\n另外，我们还可以运用dt属性中的month函数来将月份信息提出出来，并将提取的结果赋值给新列。\n# 提取月份信息并形成新列\ndf['month'] = df['date'].dt.month\n\n# 打印DataFrame\nprint(df)\n\n# 输出结果为\n#         date  month\n# 0 2023-06-01      6\n# 1 2023-06-02      6\n# 2 2023-06-03      6\n# 3 2023-06-04      6\n\n\n2. Pandas中的时间日期索引\n在Pandas中，日期索引是一种特殊的索引类型，用于在时间序列数据中以日期或时间作为索引。日期索引在处理时间序列数据时非常有用，可以轻松地对数据进行切片、重采样和时间范围选择等操作。\nPandas提供了两种主要的日期索引类型：Timestamp和DatetimeIndex。\n\nTimestamp:\nTimestamp是Pandas中表示单个时间点的对象，可以使用pd.Timestamp()函数创建一个Timestamp对象，指定日期和时间。\npd.Timestamp('2023-06-17 10:30:00')\nDatetimeIndex:\nDatetimeIndex是一种由Timestamp对象构成的索引对象。可以使用pd.to_datetime()函数将日期时间字符串转换为DatetimeIndex对象。\npd.to_datetime(['2023-06-17', '2023-06-18', '2023-06-19'])\n\n使用日期索引可以实现以下功能：\n\n切片和选择：\n使用日期索引可以切片和选择时间序列数据。\n# 创建一个示例时间序列数据\ndata = {'日期': pd.date_range(start='2023-01-01', periods=10, freq='D'),\n        '销售量': [100, 150, 120, 200, 180, 160, 190, 210, 230, 250]}\ndf = pd.DataFrame(data)\n\n# 将日期列设置为索引\ndf.set_index('日期', inplace=True)\n\n# 选择特定日期范围的数据\nselected_data = df['2023-01-03':'2023-01-07']\nprint(selected_data)\n\n# 选择特定月份的数据\nselected_month = df['2023-02']\nprint(selected_month)\n\n# 使用布尔条件选择数据\nboolean_selection = df[df['销售量'] &gt; 200]\nprint(boolean_selection)\n重采样：\n重采样是指将时间序列数据从一个频率转换为另一个频率。使用日期索引，使用resample()方法可以对数据进行重采样，如按日、按周或按月重采样数据。\n# 按周重采样并计算平均值\nweekly_resampled = df.resample('W').mean()\nprint(weekly_resampled)\n\n# 按月重采样并计算总和\nmonthly_resampled = df.resample('M').sum()\nprint(monthly_resampled)\n时间范围生成：\nPandas提供了几个函数来生成一系列日期索引，如pd.date_range()和pd.period_range()。指定开始日期、结束日期和频率来生成日期范围，以便在创建时间序列数据时使用。\n# 生成一个包含5个连续日期的时间范围\ndate_range = pd.date_range(start='2023-01-01', periods=5, freq='D')\nprint(date_range)\n\n# 生成一个包含3个月份的时间范围\nmonth_range = pd.date_range(start='2023-01-01', periods=3, freq='M')\nprint(month_range)\n\n# 生成一个包含10个工作日的时间范围\nbusiness_days_range = pd.date_range(start='2023-01-01', periods=10, freq='B')\nprint(business_days_range)\n日期偏移：\nPandas提供了日期偏移功能，可以在日期上进行简单的数学运算。例如，您可以使用+或-操作符在日期索引上进行加减运算，例如df.index + pd.DateOffset(days=1)将日期索引向前偏移一天。\n# 创建一个日期索引\ndate_index = pd.date_range(start='2023-01-01', periods=5, freq='D')\n\n# 将日期索引向前偏移一天\nforward_offset = date_index + pd.DateOffset(days=1)\nprint(forward_offset)\n\n# 将日期索引向后偏移两天\nbackward_offset = date_index - pd.DateOffset(days=2)\nprint(backward_offset)\n\n# 将日期索引向前偏移一个月\nmonth_offset = date_index + pd.DateOffset(months=1)\nprint(month_offset)\n\n日期索引是Pandas中处理时间序列数据的重要工具之一，它提供了方便的方法来处理、分析和可视化时间相关的数据。使用日期索引，您可以更轻松地操作和探索时间序列数据。\n在Pandas中，.dt接口提供了许多常用的属性，用于处理日期和时间类型的Series数据。以下是一些常见的.dt接口属性的示例：\n\n\n\n\n\n\n\n属性\n描述\n\n\n\n\n.year\n返回日期的年份。\n\n\n.month\n返回日期的月份。\n\n\n.day\n返回日期的日。\n\n\n.hour\n返回时间的小时。\n\n\n.minute\n返回时间的分钟。\n\n\n.second\n返回时间的秒。\n\n\n.microsecond\n返回时间的微秒。\n\n\n.nanosecond\n返回时间的纳秒。\n\n\n.weekday\n返回日期对应的星期几（0代表星期一，6代表星期日）。\n\n\n.weekday_name\n返回日期对应的星期几的名称。\n\n\n.weekofyear\n返回日期所在年份的第几周。\n\n\n.quarter\n返回日期所属的季度。\n\n\n.is_month_start\n检查日期是否为月初。\n\n\n.is_month_end\n检查日期是否为月末。\n\n\n.is_quarter_start\n检查日期是否为季度初。\n\n\n.is_quarter_end\n检查日期是否为季度末。\n\n\n.is_year_start\n检查日期是否为年初。\n\n\n.is_year_end\n检查日期是否为年末。\n\n\n.is_leap_year\n检查日期是否为闰年。\n\n\n\n\n\n3. 重采样\n在 Pandas 中，重采样是指将时间序列数据从一个频率转换为另一个频率的过程。重采样可以帮助我们对时间序列数据进行聚合、降采样或升采样，以适应不同的分析需求。Pandas 提供了强大的重采样功能，可以根据日期和时间索引对时间序列数据进行灵活的重采样操作。\n重采样主要有两种类型：降采样（Downsampling）和升采样（Upsampling）。\n\n降采样：降采样是将时间序列数据从高频率转换为低频率。例如，从分钟数据转换为小时数据或从小时数据转换为每日数据。在降采样中，我们需要指定一个时间段，然后对该时间段内的数据进行聚合操作，例如求和、平均值、最大值、最小值等。\n示例代码：\npythonCopy code\ndf.resample('D').sum()  # 将数据按天进行降采样，并计算每天的总和\n升采样：升采样是将时间序列数据从低频率转换为高频率。例如，从每日数据转换为小时数据或从每月数据转换为每日数据。在升采样中，我们通常需要使用插值方法来填充新增的时间点，以估计缺失的数据。\n示例代码：\npythonCopy code\ndf.resample('H').ffill()  # 将数据按小时进行升采样，并使用向前填充方法插值数据\n\n在重采样过程中，我们需要使用 resample() 函数指定重采样的频率，例如 ‘D’ 表示按天重采样，‘H’ 表示按小时重采样。然后，我们可以对重采样对象应用聚合函数（例如 sum()、mean()、max()、min() 等）或插值函数（例如 ffill()、bfill() 等）来处理数据。"
  },
  {
    "objectID": "txt_data.html",
    "href": "txt_data.html",
    "title": "15  使用Pandas处理文本数据",
    "section": "",
    "text": "在Pandas中，文本的主要两个类型是string和object。如果不特殊指定类型为string，文本类型一般为object。\n在通过访问器str实现对文本的操作之前，需要注意：\n\n要确保访问的对象类型是字符串str类型，如果不是，需要使用astype(str)转换类型\n访问器只能对Series数据结构使用，可以多个连接使用。\n\n\n1. 文本格式：大小写变换\n在 Pandas 中，可以使用字符串方法 str.lower() 和 str.upper() 对文本数据进行大小写转换。这些方法可以应用于 Pandas 的 Series或DataFrame列中的文本数据，以将其转换为小写或大写形式。\nimport pandas as pd\n\n# 创建示例数据\ndata = {'text': ['Hello World', 'Welcome to Pandas', 'Text Processing']}\ndf = pd.DataFrame(data)\n\n# 字符全部变成小写\ndf['lowercase'] = df['text'].str.lower()\n\n# 字符全部变成大写\ndf['uppercase'] = df['text'].str.upper()\n\n# 每个单词首字母大写\ndf['titlecase'] = df['text'].str.title()\n\n# 字符串第一个字母大写，其余小写\ndf['capitalize'] = df['text'].str.capitalize()\n\n# 大小写字母转换\ndf['swapcase'] = df['text'].str.swapcase()\n\n# 打印处理后的数据集\nprint(df)\n\n\n2. 文本拆分\n在 Pandas 中，可以使用字符串方法 str.split() 对文本数据进行拆分。该方法可以将字符串按指定的分隔符拆分为多个部分，并返回一个包含拆分结果的 Series或DataFrame列。\n在对文本进行拆分时，可以使用expand参数将拆分出来的内容单独成列，使用n参数指定拆分的位置来控制形成几列。在对文本进行拆分以后，也可以使用get方法提取相关部分单独成列。\n# 使用方法\ns.str.split('x', expand=True, n=1)\n\n# 示例\n# 创建一个包含文本数据的 DataFrame\ndata = {'Text': ['Hello World', 'Python Programming', 'Data Science']}\ndf = pd.DataFrame(data)\n\n# 拆分文本并形成新列\ndf[['Word1', 'Word2']] = df['Text'].str.split(' ', expand=True)\n\nprint(df)\n\n# 输出结果\n#                 Text    Word1        Word2\n# 0        Hello World    Hello        World\n# 1  Python Programming   Python  Programming\n# 2       Data Science      Data      Science\n要进行更复杂的拆分可以借助正则表达式，如：\ns.str.split('\\@|\\.', expand=True, n=1)\n\n\n3. 文本包含\n在 Pandas 中，可以使用字符串方法 str.contains() 来判断文本数据是否包含指定的子串。这个方法返回一个布尔值的 Series或DataFrame列，用于表示每个元素是否包含指定的子串。，一般配合loc查询功能使用可搭配的参数有：\n\npat: 匹配字符串，支持正则表达式\ncase: 是否区分大小写，True表示区别\nflags: 正则库re中的标识，比如re.IGNORECASE\nna: 对缺失值填充\nregex: 是否支持正则，默认True支持\n\n# 使用方法\ns.str.contains(\"\")\n\n# 示例\n# 判断文本是否包含特定子串，并创建新列\ndf['Contains_Python'] = df['Text'].str.contains('Python')\n\nprint(df)\n\n# 输出结果\n#                 Text  Contains_Python\n# 0        Hello World            False\n# 1  Python Programming             True\n# 2       Data Science            False\n\n\n4. 文本格式：计数\n在 Pandas 中，可以使用字符串方法 str.count() 计算文本数据中指定子串的出现次数，同时可以使用字符串方法 str.len() 计量文本的长度。这两个方法可以方便地对文本数据进行计数和测量长度的操作。\n# 使用方法\ns.str.count('') # 字符串种包括指定字母的数量\ns.str.len() # 字符串长度\n\n# 示例\n# 计算指定子串的出现次数，并创建新列\ndf['Count_o'] = df['Text'].str.count('o')\n\n# 计量文本长度，并创建新列\ndf['Text_length'] = df['Text'].str.len()\n\nprint(df)\n\n# 输出结果\n#                 Text  Count_o  Text_length\n# 0        Hello World        2           11\n# 1  Python Programming        2           19\n# 2       Data Science        0           12\n\n\n5. 文本替换\n文本替换通常使用replace方法进行，可选参数如下：\n\npal：为被替代的内容字符串，也可以为正则表达式\nrepl：为新内容字符串，也可以是一个被调用的函数\nregex：用于设置是否支持正则，默认是True\n\n# 使用方法\ns.str.replace(\"s\":\"S\", \"f\":\"F\")\n\n# 示例\n# 将指定子串替换为新值，并创建新列\ndf['New_Text'] = df['Text'].str.replace('o', 'x')\n\nprint(df)\n\n# 输出结果\n#                 Text            New_Text\n# 0        Hello World        Hellx Wxrld\n# 1  Python Programming  Pythxn Prxgramming\n# 2       Data Science       Data Science"
  },
  {
    "objectID": "更好的数据可视化.html",
    "href": "更好的数据可视化.html",
    "title": "16  更好的数据可视化(Plotly)",
    "section": "",
    "text": "pip安装conda安装\n\n\n$ pip install plotly\n\n\n$ conda install -c plotly plotly\n\n\n\nplotly.express是plotly的简化包，只需要1～2行就可以生成可视化图表，大家可以滑动鼠标，获取相对应的数据。官方文档\n\n\nCode\nimport plotly.express as px\nfig = px.bar(x=[\"a\", \"b\", \"c\"], y=[6, 1, 8])\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "for循环.html#为什么需要使用for循环",
    "href": "for循环.html#为什么需要使用for循环",
    "title": "17  for循环自动获取股票数据",
    "section": "为什么需要使用for循环？",
    "text": "为什么需要使用for循环？\nfor循环简化了操作、处理大量数据，自动化了重复任务，并提供灵活的遍历顺序。它是一种强大的编程工具，帮助我们优化效率、减少冗余代码。无论初学者还是经验丰富的开发人员，for循环都是不可或缺的技术，提升代码质量、处理数据轻而易举。"
  },
  {
    "objectID": "for循环.html#案例背景",
    "href": "for循环.html#案例背景",
    "title": "17  for循环自动获取股票数据",
    "section": "案例背景",
    "text": "案例背景\n使用for循环调用股票API Tushare获取日线行情。但是有限制调用页数。尝试使用for循环遍历列表，逐个发送API请求获取每只股票的日线行情数据。"
  },
  {
    "objectID": "for循环.html#操作步骤",
    "href": "for循环.html#操作步骤",
    "title": "17  for循环自动获取股票数据",
    "section": "操作步骤",
    "text": "操作步骤\n\n通过def定义函数\nfor循环遍历整个日线行情\nconcat合并上下表"
  },
  {
    "objectID": "python链接数据库.html#为什么要用sqlalchemy连接数据库",
    "href": "python链接数据库.html#为什么要用sqlalchemy连接数据库",
    "title": "18  Python连接Postgresql数据库",
    "section": "为什么要用SQLAlchemy连接数据库？",
    "text": "为什么要用SQLAlchemy连接数据库？\n在企业中，很多数据都存储在数据库当中，通过SQLAlchemy，可以轻松连接多种数据库，包括MySQL、PostgreSQL、SQLite等，并使用统一的API进行数据库操作。SQLAlchemy提供了高级的对象关系映射（ORM）功能，使数据库操作更加面向对象，简化了数据模型的开发和管理。它提供了查询构建器、事务管理、数据迁移等功能，提高了开发效率。"
  },
  {
    "objectID": "python链接数据库.html#所需环境和拓展包",
    "href": "python链接数据库.html#所需环境和拓展包",
    "title": "18  Python连接Postgresql数据库",
    "section": "所需环境和拓展包",
    "text": "所需环境和拓展包\n\njupyternotebook – 撰写python代码\nPostgreSQL & Pgadmin4 – 数据库及其GUI工具（数据库客户端）\nSQLAlchemy – python拓展包，用来连接数据库"
  },
  {
    "objectID": "python链接数据库.html#操作步骤",
    "href": "python链接数据库.html#操作步骤",
    "title": "18  Python连接Postgresql数据库",
    "section": "操作步骤",
    "text": "操作步骤\n\nDocker安装jupyternotebook & Postgresql数据库\n本地数据库备份&迁移\n安装和使用SqlAlechemy"
  },
  {
    "objectID": "Dash案例.html#为什么要使用dash",
    "href": "Dash案例.html#为什么要使用dash",
    "title": "19  Dash创建股票APP",
    "section": "为什么要使用Dash",
    "text": "为什么要使用Dash\nDash Plotly是一个基于Python的开源框架，用于构建交互式数据可视化和分析应用。\n它的优势在于简洁的语法、强大的可视化功能和灵活的布局选项。通过使用Dash Plotly，您可以轻松创建漂亮、交互式的应用程序，展示和探索数据，无论是用于内部报告、数据分析还是对外展示。它提供了丰富的图表类型、注解和样式设置，以及与其他Python库的无缝集成，如pandas和numpy。Dash Plotly还支持部署到Web服务器上，使得应用程序能够通过浏览器进行访问和共享。\n总的来说，Dash Plotly提供了一种简单而强大的方式来创建数据驱动的应用程序，使得数据可视化和交互变得更加容易和高效。"
  },
  {
    "objectID": "Dash案例.html#案例背景",
    "href": "Dash案例.html#案例背景",
    "title": "19  Dash创建股票APP",
    "section": "案例背景",
    "text": "案例背景\n使用Dash 模仿复现股票走势的交互可视化面板，可以查看股票日线级别的涨跌幅度、股票走势和买入卖出盈亏比。以英伟达股票为案例"
  },
  {
    "objectID": "Dash案例.html#相关链接",
    "href": "Dash案例.html#相关链接",
    "title": "19  Dash创建股票APP",
    "section": "相关链接",
    "text": "相关链接\n免费股票数据API\nGitHub Python调用API\n模仿案例网站"
  },
  {
    "objectID": "Dash案例.html#dash股票案例上集",
    "href": "Dash案例.html#dash股票案例上集",
    "title": "19  Dash创建股票APP",
    "section": "Dash股票案例（上集）",
    "text": "Dash股票案例（上集）\n\nAPI获取&调用\npands数据清洗\n导出csv到本地\nDash-Bootstrap主题\nDash-layout排版\nDash-调整位置和宽度"
  },
  {
    "objectID": "Dash案例.html#dash股票案例下集",
    "href": "Dash案例.html#dash股票案例下集",
    "title": "19  Dash创建股票APP",
    "section": "Dash股票案例（下集）",
    "text": "Dash股票案例（下集）\n\napp功能：涨跌百分比\npadnas数据清洗&过滤\nplotly绘制百分比图\napp功能：股票走势图\nupdate_traces VS update_layout\napp功能：滚动数据\nBootstrap组件使用"
  }
]