[
  {
    "objectID": "index.html#文档目录",
    "href": "index.html#文档目录",
    "title": "Python新手文档",
    "section": "文档目录",
    "text": "文档目录\n\nPython简介\n\nPython的特点和应用领域\n安装Python和开发环境\nPython基础知识\n\n\n\n数据类型和变量\n\n运算符和表达式\n数据类型\n数据结构\n\n\n\nPlotly 快速入门\n\nPlotly库介绍与安装\nPlotly绘制基础图表\nPlotly绘制可交互图表\nPlotly绘制地图\n\n\n\nPandas 基本操作\n\nPandas库介绍和安装\nPandas处理什么样的数据\n读取和写入\n选取和筛选\n增删和排序\n分组和聚合\n处理时间序列数据\n处理文本数据\n数据可视化\n\n\n\nPandas 实际应用案例\n\n从实际数据集中读取数据\n数据清洗和预处理\n扩展学习资源\n\n\n\n爬虫快速入门\n\n爬虫基础与HTML概念介绍\n使用Requests获取网页数据\n使用Scrapy编写简单爬虫\n\n\n\n推荐的Pandas学习资源\n\npandas官方文档(自译版)\nPandas对比SQL\nPlotly可视化官方文档\nW3schools for Pandas\n JackB站超级多的视频"
  },
  {
    "objectID": "index.html#结语",
    "href": "index.html#结语",
    "title": "Python新手文档",
    "section": "结语",
    "text": "结语\n通过本文的学习，你将建立起对Python编程语言的基本理解，掌握Pandas库进行数据处理和分析的技能。无论你是想进入数据科学领域、进行数据挖掘，还是对数据处理和分析有兴趣，Python和Pandas都是你的理想选择。开始你的编程之旅吧，让Python和Pandas帮助你实现数据的无限可能！\n\n\n\n\n\n\nNote\n\n\n\n本文档主要针对编程小白，将以简洁易懂的语言和实例进行解释。每个主题都会提供充足的示例代码和实践案例，以便读者能够实际运用所学知识。在学习过程中，不断实践和探索将是提高编程能力的关键，鼓励读者积极动手并勇于尝试。"
  },
  {
    "objectID": "intro.html#主要特点",
    "href": "intro.html#主要特点",
    "title": "Python简介",
    "section": "主要特点",
    "text": "主要特点\nPython是一种高级编程语言，以其简洁、易读、易学和灵活性而受到广泛欢迎。以下是Python的一些主要特点：\n\n简洁易读：Python采用清晰简洁的语法，使得代码易于阅读和理解。它使用缩进来表示代码块，而不是使用大括号，这使得代码更加易读。\n易学性：Python的语法简单明了，相对于其他编程语言来说，学习曲线较低。这使得初学者能够快速入门并开始编写实用的程序。\n跨平台性：Python可以在多个操作系统上运行，包括Windows、macOS和各种Linux发行版。这意味着开发人员可以在不同的平台上编写一次代码，并在不同的环境中运行。\n大量的库和框架：Python拥有庞大且活跃的社区，为各种用途提供了大量的库和框架。这些库和框架使得开发人员能够快速构建各种应用，例如Web应用、科学计算、数据分析和人工智能等。\n可扩展性：Python可以与其他语言（如C/C++和Java）轻松集成，这使得开发人员能够使用现有的代码库和资源，以提高应用程序的性能和功能。"
  },
  {
    "objectID": "intro.html#应用领域",
    "href": "intro.html#应用领域",
    "title": "Python简介",
    "section": "应用领域",
    "text": "应用领域\nPython具有广泛的应用领域，从Web开发到科学计算和人工智能等各种领域都能发挥其优势。它的简洁性和强大的库生态系统使得开发人员能够快速构建各种类型的应用程序。\n\nWeb开发：Python的Web框架（如Django和Flask）使得构建功能强大的Web应用程序变得简单。Python还可以用于服务器端编程、网页爬虫和API开发等。\n数据科学和机器学习：Python在数据科学和机器学习领域非常受欢迎。它提供了许多用于数据处理、数据可视化和机器学习算法的库，如NumPy、Pandas、Matplotlib、Scikit-learn和TensorFlow等。\n科学计算：Python在科学计算领域也得到广泛应用。科学计算库如NumPy和SciPy提供了许多数值计算、优化和统计分析的功能，适用于物理学、数学、生物学等领域。\n自动化和脚本编写：Python的简洁性和易用性使得它成为自动化任务和脚本编写的理想选择。可以使用Python编写脚本来自动执行重复性的任务、处理文件、操作系统和网络等。\n游戏开发：Python也可以用于游戏开发。有一些专门的库和框架，如Pygame，使得使用Python编写2D游戏变得相对容易。"
  },
  {
    "objectID": "02_01_Python基本概念与指令输入.html#python入门",
    "href": "02_01_Python基本概念与指令输入.html#python入门",
    "title": "1  Python基本概念与指令输入",
    "section": "Python入门",
    "text": "Python入门\n\n\n\n\n\n一、Python是什么\n\n1. 最流行的编程语言\nPython是一种流行的、易学易用的编程语言，它开发于1991年。Python的设计注重代码的可读性和简洁性，这使得它成为了初学者和专业开发者喜爱的语言。\n截止到目前，学习Python的人数相当之多，它在计算机编程教育和软件开发领域的受欢迎程度非常高，甚至可以认为Python是世界上最受欢迎的编程语言之一。\n使用Python，你可以编写各种类型的程序，从简单的脚本到复杂的网站和应用程序，甚至是人工智能和数据科学领域的应用。\n仔细看Python的标志——两只蓝色和黄色的小蟒蛇，你今后会在许多地方见到它。在本次夏令营中，我们会带领你们使用这个强大、灵活且有趣的编程语言，学习如何对数据进行清洗，以及对我们清洗完成的数据进行可视化处理。\n\n\n\n2. Python文件\n在我们的日常电脑使用中，我们会遇到各种各样的文件，它们的类型和功能各不相同。例如，mp4文件通常是用来存储音视频数据，而pdf文件则是一种用于存储文本和图片的格式。\nPython文件是一种特殊类型的文件，通常使用.py扩展名。这些文件包含用Python编程语言编写的代码。与其他文件不同，Python文件并不直接存储音视频或图像等内容，而是用于存储计算机程序的源代码。\n在Python文件中，我们可以使用Python编程语言来编写程序，这些程序可以完成各种任务，比如数学计算、数据处理、网络操作等。一旦编写完成，我们可以通过Python解释器来执行这些文件中的代码，让计算机按照我们编写的指令来完成相应的任务。\n总的来说，Python文件是一种特殊的文本文件，它们承载着用Python语言编写的程序代码，为我们提供了一种强大且灵活的方式来控制计算机的行为。\n\n\n\n二、如何运行Python文件\n在我们的夏令营中，我们使用JupyterLab作为我们的开发环境。JupyterLab是一个交互式的开发环境，我们可以使用它编写、运行和分享代码。另外，JupyterLab已经做好了Python环境的配置，对于新手来说，可以省去很大一部分工作，更轻松的进行Python学习。\n首先，我们进入JupyterLab的界面。通常来说，你的默认浏览器会显示一个网页，这就是JupyterLab的用户界面，这个界面类似于文件资源管理器，你可以在其中浏览文件夹和文件。\n然后，我们点击创建一个Python File。这样一来，我们就成功创建了一个.py文件了，但是我们的文件中还没有代码，需要我们进行进一步的操作。\n在左边的目录中，我们可以看到我们新建的文件，通常来说，它会被命名为Untitled.py，我们可以在目录中直接修改文件名。\n点击进入Python文件之后，我们就可以开始撰写代码了，试试看，输入：\n\nprint(\"世界和平\")\n\n世界和平\n\n\n暂时你还不领会这段代码的含义，但是没关系，在后面的教程中，我们会慢慢来告诉你。\n\n接下来，回到主菜单(你可以点击标题栏旁边的’+‘)，点击’Terminal’，你就会进入到终端(这是一个一个黑色的窗口)，在这里输入你刚才创建的文件的名称，然后按下回车键。你就会发现，刚才我们输入在Python文件中的代码被执行了，终端中输出了：\n世界和平\n我们刚才在Python文件中输入的代码的含义就是，打印”世界和平”这四个字。\n\n\n\n\n\n\n\nNote\n\n\n\n在终端中，输入python进入python解释器后，即可运行python代码\n\n\n\n\n三、如何运行.ipynb文件\n\n1. 什么是.ipynb文件\n通过刚才的操作，你可能会发现，运行Python文件的步骤可能有些太多了，而且我们也没办法直观的看到我们的代码所产生的效果。\n在我们所使用的JupyterLab中，有一种更简便的方式来运行我们的代码，那就是使用.ipynb格式的文件。\n.ipynb文件是Jupyter Notebook的保存格式，它是一个JSON（JavaScript Object Notation）格式的文本文件，其中包含了Jupyter Notebook的所有内容，包括代码、输出结果、文本说明等。\n\n\n2. 如何运行.ipynb文件\n当我们打开一个.ipynb格式的文件后就会发现，这里的界面与刚才的Python File界面不同，界面中有一些块状元素，这就是我们撰写代码的地方。\n.ipynb格式的文件中的块分为两类，一类是markdown块，用于书写文本内容，另一类就是代码块，我们可以很方便地在其中输入代码，然后点击标题栏下方的运行按钮，或者按下Shift + Enter就可以执行我们的代码。\n\n试试看新建一个.ipynb文件，然后输入刚才的代码，你会很直观的看到代码的运行结果。\n现在，你自己尝试一下新建一个.ipynb文件并运行，这会帮助你加深对文件运行方法的理解。\n在后面的学习中，我们会经常用到.ipynb文件，大家可以从微信群中下载所需要用到的文件，然后上传到JupyterLab中打开。\n\n\n\n四、Python基础语法\n在之前的学习中，我们了解到Python是一种编程语言，与自然语言（例如汉语）截然不同。虽然它们是两种不同的语言类型，但编程语言与自然语言相似，都需要遵守语法规则。这些语法规则用于规范句子和表达式的结构，以确保正确的表达和理解。\n因此，不要感到畏难，你可以像学习一门自然语言一样来学习Python。一旦掌握了Python的基础语法规则，你就可以与计算机很方便地进行交流，编写出功能强大的程序。\n现在，打开你的JupyterLab，新建一个.ipynb文件，让我们尝试编写一个简单的表达式，通过这个例子初步认识一下Python的语法规则。\n\n\n\n\n\n\nNote\n\n\n\n通俗地说，在编程中，表达式就是一段产生值的代码。\n下面是一些简单的表达式，用于帮助你理解：\n算术表达式：2 + 3 * 4 （计算结果为 14）\n逻辑表达式：a &gt; b and c &lt;= 10 （根据变量a、b和c的值判断是否满足条件）\n\n\n\n\n2023 + 4090\n\n6113\n\n\n在上面的例子中，我们编写了一个简单的算术表达式，用来计算2023与4090的和。在执行后，我们可以在输出区域看到运算结果：\n6113\n现在，让我们尝试另外一种表达式：逻辑表达式。\n\n9 &gt; 1\n\nTrue\n\n\n上面的表达式对9和1的大小进行了判断。由于9 &gt; 1成立，因此程序返回True；相反，如果我们编写1 &gt; 9，则会返回False。在这里，True和False统称为布尔值，在后续的数据类型课程中，我们会详细地介绍它们。\n在编写代码时，难免会遇到错误。\n如果我们让一个未赋值的变量(也就是一个空值)与数字进行比较会发生什么呢？现在，试试看删除上面的表达式中&gt;右侧的数字1，重新执行代码。\n\n9 &gt; \n\nSyntaxError: invalid syntax (1639543893.py, line 1)\n\n\n在上述代码中，我们进行了一个比较运算，但只填入了一个值，导致程序报错。\n终端提示我们这个错误叫做SyntaxError，这个错误通常表示我们的代码语法写错了，不符合Python的规则。换句话说，我们的代码不能被计算机正确地理解和执行。遇到这种情况，我们需要检查代码，确保语法正确，以便程序能够顺利运行。\n现在，我们已经初步了解了Python的语法规则，就像我们在自然语言中需要遵守语法规则一样。在接下来的学习中，我们将一起深入探讨Python的语法规则，并逐步提升我们的编程能力。"
  },
  {
    "objectID": "02_01_Python基本概念与指令输入.html#python基础语法",
    "href": "02_01_Python基本概念与指令输入.html#python基础语法",
    "title": "1  Python基本概念与指令输入",
    "section": "Python基础语法",
    "text": "Python基础语法\n\n一、变量与赋值\n\n1. 什么是变量\n变量是用来存储和表示数据的一种抽象概念。它们为数据赋予了一个标识符，以便我们可以在程序中引用和操作这些数据。通过变量，我们可以方便地在代码中存储和访问数据，并在程序执行过程中对数据进行修改和处理。\n\n\n2. 变量的命名规则\n\n变量名必须以字母（A-Z，a-z）或下划线（_）开头，不可以以数字开头。\n变量名可以包含字母、数字（0-9）和下划线（_）。\n变量名区分大小写，例如age和Age是两个不同的变量。\n变量名不能使用Python的保留关键字，如if、else、while等。\n变量名应具有描述性，能够清晰地表示变量的含义。\n\n\n\n3. 变量的赋值\n在Python中，可以使用赋值操作符（=）来给变量赋值。在=左侧的元素就是变量名，在=右侧的元素则是存储在变量中的值。赋值操作就是将右侧的数据或表达式的值存储到变量中。在赋值时，等号右侧的值先被计算，然后再赋给等号左侧的变量。如：\n\nx = 5\nname = \"John\"\n\nprint(x)\nprint(name)\n\n尝试上面的代码，这会有助于帮助你理解赋值操作。\n\n\n4. 变量的使用\n一旦变量被赋值，我们可以在程序中使用它们。通过变量名，我们可以获取存储在变量中的值，并在代码中进行各种操作。\n试着在JupyterLab中输入下面的示例代码，这将会调用变量x计算其平方并打印结果：\n\nx = 5\nsquare = x * x\nprint(square)\n\n\n\n5. 变量的重新赋值\n变量的值可以随时更改。通过简单地再次使用赋值操作符，我们可以为变量分配新的值。新值将覆盖之前的值。\n下面的例子向我们演示了如何为我们在上面定义的变量重新进行赋值：\n\nx = 10\nname = \"Jack\"\n\nprint(x)\nprint(name)\n\n现在你已经了解了变量的基础概念。接下来，你可以试试看如何将字符串”Hello, Python!“赋值给一个名为message的变量，并输出它的值。\n\n\n\n\n\n\nNote\n\n\n\n关于字符串的概念，我们将在后文中向你详细讲解。\n\n\n\n\n\n二、注释的撰写与阅读\n在Python中，注释就像是给代码做注解或添加备注的便签。计算机不会执行注释，它们只是供开发者阅读和理解代码时参考的文本。注释对于让代码更易读、更易维护非常重要。通过注释，其他人（包括未来的自己）可以更轻松地理解代码的目的和功能。就像在写作文时加上小纸条一样，注释帮助我们更好地组织思路和理解代码。\n\n1. 单行注释\n单行注释是通过在一行代码后面使用井号#符号添加的注释。任何位于#后面的文本都会被Python解释器忽略，不会对代码产生影响。单行注释通常用于对代码进行简短的解释、备注或说明，帮助开发者理解代码的功能和意图。\n看看下面的代码，这是单行注释的两种形式：\n\n# 这是一个单行注释\nprint(\"Hello, World!\")  # 打印输出文本\n\n\n\n2. 多行注释\n多行注释是通过使用三个单引号'''或三个双引号\"\"\"将多行文本包围起来，从而形成一个注释块。这种注释方式通常用于注释较长的段落或函数的文档说明，以提供更详细的代码解释和描述。例如：\n\n\"\"\"\n这是一个多行注释，\n用于提供更详细的代码解释和描述。\n可以跨越多行，非常方便。\n\n以下是代码的主要功能：\n- 输入用户的姓名\n- 打印欢迎消息和姓名\n\"\"\"\n\nname = input(\"请输入您的姓名：\")\nprint(\"欢迎，\" + name + \"!\")\n\n\n\n\n\n\n\nNote\n\n\n\n如果想要一次性注释多行代码，可以先用鼠标选取要注释的多行，然后按下Ctrl+/进行注释。这样，选中的所有行都会被自动添加注释符号，快速实现多行注释的操作。\n\n\n\n\n3. 注释的规范\n撰写和阅读注释的规范：\n\n清晰明了： 注释应该简洁明了，用简单的语言描述代码的目的和功能。\n位置准确： 注释应该位于需要解释的代码附近，以便更容易理解其含义。\n避免多余注释： 不要对显而易见的代码添加过多注释，注释应该解释那些可能不容易理解的部分。\n保持更新： 随着代码的更改和更新，确保注释保持与代码同步，避免出现不一致的情况。\n注释风格： 遵循通用的注释风格，如使用中文或英文注释，根据约定使用单行或多行注释。\n\n\n\n\n三、行与缩进\n\n1. 行\n在Python中，行是代码的基本组成单位，代表着一条指令或表达式。Python作为一种解释性语言，代码由一行一行的语句构成，每一行通常包含一个完整的操作或计算。无需特别处理换行符，Python解释器会自动识别代码中的换行，可以通过按下Enter键或使用续行字符\\将代码分成多行，使代码更易读。每当解释器遇到换行，它就会开始执行下一行代码，一步步按顺序执行整个程序。这样的编码方式让Python代码看起来简洁、清晰，并且方便理解和维护。\n总结有关行的知识点，我们可以得到下面这些注意事项：\n\nPython是一种解释性语言，代码由一行一行的语句组成，它们由换行符\\n来进行分隔。\n每一行通常包含一个完整的语句或表达式，用于执行特定的操作或计算。\n代码从上到下依次执行，每执行一行，计算机会按顺序执行相应的操作。\n\n下面的例子，向我们展示了Python中行最重要的功能：语句分隔\n\nprint(\"Hello,\")  # 第一行代码\nprint(\"Python!\")  # 第二行代码\n\n在一些情况下，行可能会非常长，为了让代码更美观，我们可以使用反斜杠\\作为续行字符将一行代码分成多行。例如：\n\nlong_line = \"This is a very long line, and we want to split it into multiple lines \\\n             for better readability.\"\n\n在上述代码中，我们演示了将一个特别长的字符串赋值给变量long_line。为了使代码更易读，我们在字符串中间使用了\\进行换行。\n另外，你还可以使用括号(圆括号、方括号、花括号)来隔行编写多行语句，就像下面的例子一样：\n\nresult = (10 + 20 +\n          30 + 40 +\n          50)\n\nprint(result)  # 输出：150\n\n\n\n2. 缩进\n在Python中，缩进是一种用来表示代码层次结构和代码块之间嵌套关系的重要机制。在下面的要点总结中，你可以了解到缩进的注意事项：\n\n在Python中，缩进是指代码块中的空白空间(缩进通常使用空格或制表符，但在同一个代码块中必须保持一致)。\n缩进用来表示代码的层次结构，表明代码块之间的嵌套关系，以及代码块的开始与结束。\n缩进是Python中定义代码块的唯一方法。\n在同一代码块中的语句必须具有相同的缩进量，以表示它们属于同一层次的执行范围。\n\n\n\n\n\n\n\nNote\n\n\n\n在Python中，代码块由缩进来表示，以冒号:引入。代码块是一个逻辑单元，包含一组组关联的语句，例如条件语句、循环和函数定义\n\n\n看看下面的代码，展示了缩进在代码块定义中的应用。\n\ndef draw_heart():\n    # 第一层缩进，函数的代码块开始\n    print(\"  ❤️    ❤️  \")\n    print(\"❤️   ❤️   ❤️\")\n    print(\"❤️        ❤️\")\n    print(\"  ❤️    ❤️\")\n    print(\"     ❤️ \")\n    # 第一层缩进，函数的代码块结束\n\n\n# 主程序从这里开始执行\nprint(\"我画了一个可爱的心形：\")\ndraw_heart()\n\n我画了一个可爱的心形：\n  ❤️    ❤️  \n❤️   ❤️   ❤️\n❤️        ❤️\n  ❤️    ❤️\n     ❤️ \n\n\n在上面的代码中，我们定义了一个函数(函数的知识以后会讲到)，使用缩进定义了它的代码块。\n\n\n\n\n\n\nWarning\n\n\n\n缩进造成的错误，应该名列 Python 错误榜第一\n\n\n在Python中，缩进是强制性的，它对代码的执行和逻辑起着重要作用。通常情况下，推荐使用4个空格作为缩进量，这有助于代码的可读性和与他人合作时的效率。\n\n\n\n\n\n\nNote\n\n\n\n养成良好的编码习惯有助于提高代码质量：\n\n保持一致的缩进：在整个代码中使用相同数量的空格或制表符进行缩进，这有助于代码的一致性和可读性。\n使用合适的缩进级别：根据代码逻辑嵌套关系，选择适当的缩进级别。通常建议每个缩进级别使用4个空格。\n使用注释：在关键的代码部分添加注释，解释代码的目的和功能。注释可以提高代码的可读性和可维护性。\n注意行的长度：尽量将每行代码控制在适当的长度范围内，通常推荐不超过80个字符。可以使用换行符（）或括号来换行。\n\n遵循这些建议，可以使代码更加优雅、易读，并且有助于与他人合作时的沟通和协作。编写高质量的代码离不开良好的编码习惯。"
  },
  {
    "objectID": "02_02_Python数据类型.html#数据类型",
    "href": "02_02_Python数据类型.html#数据类型",
    "title": "2  Python数据类型",
    "section": "数据类型",
    "text": "数据类型\n当我们编写程序时，数据是不可或缺的。\n在Python中，数据类型用于表示数据的不同种类和属性，决定了数据的存储方式和可进行的操作。Python中的数据类型包括数字类型（整数、浮点数）、布尔类型（True和False）以及字符串等。通过了解和灵活运用这些数据类型，我们可以有效地处理和操作各种数据，使程序更加灵活和高效。数据类型是Python编程的基础，也是我们展开深入学习的起点。了解和正确使用这些数据类型对于编写Python代码非常重要。\n\n\n\n\n\n\nNote\n\n\n\n你可以使用type()函数来查看元素的类型。尝试在代码框中输入print(type(元素名))，来查看你的元素的数据类型。\n\n\n\n一、数字类型(Numeric Types)\n\n1. 整数类型(int)\n整数类型(int)是数字类型数据中的一个重要的组成部分，是基本的数字类型之一，也是进行算术运算和计数操作的基础。在Python中，整数是用来表示没有小数部分的数值，可以是正数、负数或零。\n整数类型的数据可以用常规的整数表示方式来表示，例如：10、-5等。整数类型也支持基本的算术运算，如加法、减法等。同时，Python的整数类型支持无限精度，即整数的大小不受限制，可以表示任意大的整数。\n试试看下面的代码，创建一些整数对象。\n\n# 定义整数变量\nnum1 = 10\n\nprint(num1)\nprint(type(num1))\n\n10\n&lt;class 'int'&gt;\n-5\n&lt;class 'int'&gt;\n\n\n\nnum2 = -5\n\nprint(num2)\nprint(type(num2))\n\n在编写程序时，整数类型经常用于计数、计算和存储整数数据。在处理整数时，需要注意整数运算的结果可能会超出预期，因为整数运算可能会产生浮点数结果。\n\n\n2. 浮点数类型(float)\n浮点数类型(float)也是数字类型中的一个重要组成部分，用于标识带有小数部分的数值，例如：3.14、0.5、-2.71828等。在Python中，浮点数的表示方式和数学中的实数类似，使用小数点来标识小数部分。\n浮点数可以用常规的十进制来标识，也可以使用科学计数法表示，例如：1.23、5e-3等。浮点数和整数一样，支持基本的算术运算。与整数不同的是，在计算机中，浮点数是有限的，因此它们具有一定的精度限制。在进行复杂运算时，可能会出现精度丢失的问题。\n下面是一些浮点数的例子，你可以在JupyterLab中尝试一下。\n\n# 定义浮点数变量\npi = 3.1415926\n\nprint(pi)\nprint(type(pi))\n\n3.1415926\n&lt;class 'float'&gt;\n25.5\n&lt;class 'float'&gt;\n\n\n\ntemperature = 25.5\n\nprint(temperature)\nprint(type(temperature))\n\n在编写程序时，浮点数常用于涉及小数的计算和数据处理。需要注意的是，由于浮点数的精度限制，可能会出现舍入误差，因此在比较浮点数是否相等时，应使用适当的误差范围进行比较，以确保计算结果的准确性。\n\n\n\n二、布尔类型(Boolean Type)\n布尔类型(bool)是Python数据类型中的一个关键部分。布尔类型只有两个取值：True(表示’真’)和False(表示’假’)。布尔类型通常用于表示逻辑条件的结果，如判断某条件是否成立，或变量是否满足某种条件。\n\n\n\n\n\n\nNote\n\n\n\n对于布尔类型的数据，首先需要注意的是布尔类型只能取True或False这两个值，区分大小写（首字母必须大写）。\n\n\n布尔类型通常用于条件判断和逻辑运算，如if语句、while循环和逻辑运算符（and、or、not）等。布尔类型在编程中非常重要，因为它们用于控制程序的流程和决策。在条件判断和逻辑运算时，布尔类型充当关键的判断条件，根据不同的条件结果执行相应的代码块。\n下面是一个布尔类型的数据的应用示例：\n\n# 使用布尔类型进行条件判断\nage = 25\nis_adult = age &gt;= 18  # 将判断结果赋值给变量is_adult\nif is_adult:\n    print(\"你是一个成年人。\")\n    print(\"是成年人吗:\", is_adult)  # 输出布尔值\nelse:\n    print(\"你还没有成年。\")\n    print(\"成年了吗:\", is_adult)  # 输出布尔值\n\n你是一个成年人。\n是成年人吗: True\n\n\n可以看到，由于变量age的值为25，大于条件判断中的18，因此，条件成立，程序会返回布尔值True，然后输出语句：You are an adult. 这说明在条件判断中，布尔类型的值会根据条件的真假返回True或False，从而影响程序的执行分支。在这个例子中，由于条件为真，所以输出了相应的信息。\n你可以试修改变量age的值，试试看不同的情况下，程序的运行情况。\n在实际应用中，布尔类型通常与条件语句和循环结构紧密结合，帮助程序做出复杂的决策和执行不同的操作。熟练掌握布尔类型的用法，是编写高效和灵活的Python代码的关键。\n\n\n三、字符串类型(String Type)\n\n1. 字符串的定义\n现在，让我们来看看Python中最常用的数据类型——字符串(str)。字符串类型str是其中一种常见且重要的数据类型。字符串用于表示文本信息，可以包含字母、数字、标点符号等字符序列。在Python中，字符串可以使用单引号' '或双引号\" \"来定义，例如：\n\nmessage1 = 'Hello, Python!'\n\nprint(message1)\n\nHello, Python!\nWelcome to the world of Python!\n\n\n\nmessage2 = \"Welcome to the world of Python!\"\n\nprint(message2)\n\n\n\n2. 字符串拼接(格式化字符串)\n在Python中，字符串拼接的目的是将多个字符串连接成一个新的字符串。这样一来，在输出时，我们就可以一次性输出许多字符串的内容，而不用写太繁琐的代码。\n字符串拼接在处理文本信息和字符串处理任务中非常常见，这在构建动态文本、输出用户友好的提示信息以及处理数据时非常有用。\n在这里，我们向你介绍三个最常用的字符串拼接方法：使用+运算符、.format()方法，以及更加简洁和直观的f-string(格式化字符串)方式。通过了解这些拼接方式，我们可以灵活地处理字符串，并使代码更加清晰易读。\n\n(1) 使用+运算符进行字符串拼接\n通过+运算符，我们可以将两个字符串连接成一个新的字符串。例如：\n\nname = \"Python\"\ngreeting = \"Hello, \" + name + \"!\"\nprint(greeting)\n\nHello, Python!\n\n\n在上面的示例代码中，我们定义了一个名为name的字符串变量，然后使用+运算符将\"Hello,\"、name和\"!\"连接在一起，形成新的字符串greeting。\n使用+运算符，你还可以将更多的元素拼接在一起，但这种方式太过繁琐，我们还有更简便的字符串拼接方式——.format()方法和f-string。让我们来看看这两种更灵活的拼接方式。\n\n\n(2) 使用.format()方法拼接字符串\n相较于使用+运算符，使用.format()方法更加灵活，可以在字符串中插入多个变量值，对于多个值的拼接，是一种更常用方式。\n.format()方式使用占位符 {} 来表示将要被替换的部分。例如：\n\nname = \"Python\"\ngreeting = \"Hello, {}!\".format(name)\nprint(greeting)\n\nHello, Python!\n\n\n在这个例子中，我们定义了一个名为name的字符串变量，然后使用.format()方法将 {} 替换为name的值，从而形成新的字符串greeting。\n\n\n\n\n\n\nNote\n\n\n\n在使用.format()方法时，一定要注意，使用占位符{ }来表示将要被替换的部分，如\"Hello, {}!\".format(name)\n另外，.format()方法还需要遵守位置对应的规则，在使用该方法时，需要确保占位符{ }的未知和传入的变量值一一对应。如果占位符的个数大于传入的变量值，或者顺序不匹配，会导致错误或者意想不到的结果。\n\n\n在使用.format()方式输出数字类型的数据时，我们还可以对数据进行以下两种格式控制：\na. 浮点数格式化\n使用:.nf来限制浮点数的小数位数，其中n代表要显示的小数位，例如：\n\npi = 3.1415926\nprint(\"The value of pi is {:.2f}\".format(pi))\n\nThe value of pi is 3.14\n\n\n在上面的代码中，我们在使用.format()方法时，通过在占位符中规定:.2f，实现了对变量精度的控制。\nb. 整数宽度控制\n使用{:n}来规定整数的宽度，其中n代表要显示的最小字符宽度。如果整数的宽度不足，会使用空格进行填充。例如：\n\nnumber = 42\nprint(\"The number is {:5}\".format(number))\n\nThe number is    42\n\n\n在上面的代码中，我们使用了.format()方法来格式化输出。在字符串中的占位符{:5}中，我们指定了一个字段宽度为5，这样输出的内容将总共占据5个字符的宽度。\n\n\n(3) 使用f-string方式拼接字符串\nf-string是最新的格式化字符串方式，简洁直观，易于理解。它在拼接字符串时更加简便，适用于大部分字符串格式化的场景。需要注意的是，f-string只适用于 Python 3.6 及以上的版本。\n在我们后面的学习中，f-string方式将会是我们最常使用的字符串拼接方式。\nf-string方式的使用非常简单，只需要在字符串前面加上f或F前缀，然后在字符串中使用{}占位符来引用变量或表达式。Python 将自动将这些花括号中的内容替换为对应的变量值或表达式结果。\n例如：\n\nname = \"Python\"\ngreeting = f\"Hello, {name}!\"\nprint(greeting)\n\nHello, Python!\n\n\n这里我们定义了一个名为name的字符串变量，然后使用f前缀以及{}占位符，将{}替换为name的值，形成新的字符串greeting。\n使用f-string的好处是，它不仅使字符串的格式化更加简洁明了，而且还支持在花括号中进行更复杂的表达式计算，甚至可以调用函数。在实际使用中，f-string是推荐的字符串格式化方法，因为它既简单又强大，能够满足大多数字符串格式化的需求。\n\n\n\n\n四、数据类型转换\n\n1. 整数与浮点数之间的转换\n将整数转换为浮点数可以使用float()函数。例如：\n\nnum_int = 10\nnum_float = float(num_int)\nprint(num_float)\nprint(type(num_float))\n\n10.0\n&lt;class 'float'&gt;\n\n\n将浮点数转换为整数可以使用int()函数。这会截取浮点数的小数部分，只保留整数部分。例如：\n\nnum_float = 3.14\nnum_int = int(num_float)\nprint(num_int)\nprint(type(num_int))\n\n3\n&lt;class 'int'&gt;\n\n\n\n\n2. 整数或浮点数与字符串之间的转换\n将整数或浮点数转换为字符串可以使用str()函数。例如：\n\nnum_int = 42\nnum_float = 3.14\n\nstr_int = str(num_int)\n\nprint(str_int)\nprint(type(str_int))\n\n42\n&lt;class 'str'&gt;\n\n\n\nstr_float = str(num_float)\n\nprint(str_float)\nprint(type(str_float))\n\n3.14\n&lt;class 'str'&gt;\n\n\n将字符串转换为整数或浮点数可以使用int()或float()函数。但要注意，字符串必须包含有效的整数或浮点数表示，否则会抛出ValueError错误。例如：\n\nnum_str_int = \"123\"\nnum_str_float = \"3.14\"\n\nint_num = int(num_str_int)\n\nprint(int_num)\nprint(type(int_num))\n\n123\n&lt;class 'int'&gt;\n\n\n\nfloat_num = float(num_str_float)\n\nprint(float_num)\nprint(type(float_num))\n\n3.14\n&lt;class 'float'&gt;\n\n\n\n\n\n\n\n\nNote\n\n\n\n注意事项：\n\n在进行数据类型转换时，要确保数据的有效性。如果转换的字符串不能表示有效的整数或浮点数，将会抛出ValueError错误。\n在将浮点数转换为整数时，小数部分会被截取，不会进行四舍五入。\n在将字符串转换为数值类型（整数或浮点数）时，如果字符串中包含非数字字符或不符合数值表示的内容，将会抛出ValueError错误。因此，在进行转换之前，最好使用合适的校验机制来确保数据的有效性。\n注意数据类型转换后的结果可能会产生意外的结果，特别是在涉及数值计算和精度要求较高的情况下。要谨慎处理数据类型转换，确保程序的正确性和准确性。"
  },
  {
    "objectID": "02_02_Python数据类型.html#运算符",
    "href": "02_02_Python数据类型.html#运算符",
    "title": "2  Python数据类型",
    "section": "运算符",
    "text": "运算符\n当你编写Python代码时，你可能会经常涉及到各种计算和比较操作。在Python中，运算符就是用来执行这些操作的特殊符号或关键字。它们使你能够对变量、常量和表达式进行各种数学运算、逻辑操作和比较判断。例如，你可以使用运算符来执行加法、减法、乘法等数学运算，也可以用它们来判断两个值是否相等、大小关系等。通过灵活使用这些运算符，你可以让你的代码更加强大和智能。\n\n一、算术运算符\n算术运算符就像编程中的特殊工具，用来做数学计算。在Python里，你可以使用这些特殊符号来做加减乘除、取余、整数除法和乘方运算。它们就像计算器上的加号、减号等按钮一样，帮助你在程序中处理数字和数据，完成各种数学运算。这些运算符让你的程序变得灵活又强大，可以进行更复杂的计算。\n下面是Python中常见的算术运算符：\n\n\n\n\n\n\n\n\n\n运算符\n名称\n描述\n举例\n\n\n\n\n+\n加法运算符\n用于相加两个数或连接两个字符串\na = 5 + 3 # 结果为8\n\n\n-\n减法运算符\n用于从一个数中减去另一个数\nb = 10 - 5 # 结果为5\n\n\n*\n乘法运算符\n用于将两个数相乘\nc = 2 * 3 # 结果为6\n\n\n/\n除法运算符\n用于将一个数除以另一个数，得到浮点数结果\nd = 10 / 2 # 结果为5.0\n\n\n//\n整数除法运算符\n用于将一个数除以另一个数，得到整数结果（向下取整）\ne = 10 // 3 # 结果为3\n\n\n%\n取余运算符\n用于得到两个数相除的余数\nf = 10 % 3 # 结果为1\n\n\n**\n幂运算符\n用于将一个数的值提高到另一个数的幂\ng = 2 ** 3 # 结果为8\n\n\n\n通过下面的一系列例子，你可以更好地理解算术运算符在编程中的简单应用：\n\n# 加法运算符 (+)：用于相加两个数或连接两个字符串。\na = 5 + 3\nb = \"Hello\" + \" \" + \"World\"\n\nprint(f\"a 的值是: {a}\")\nprint(f\"b 的值是: {b}\")\n\n\na 的值是: 8\nb 的值是: Hello World\n\n\n\n# 减法运算符 (-)：用于从一个数中减去另一个数。\nc = 10 - 5\n\nprint(f\"c 的值是: {c}\")\n\nc 的值是: 5\n\n\n\n# 乘法运算符 (*)：用于将两个数相乘。\nd = 2 * 3\n\nprint(f\"d 的值是: {d}\")\n\nd 的值是: 6\n\n\n\n# 除法运算符 (/)：用于将一个数除以另一个数，得到浮点数结果。\ne = 10 / 2\n\nprint(f\"e 的值是: {e}\")\n\n\ne 的值是: 5.0\n\n\n\n# 整数除法运算符 (//)：用于将一个数除以另一个数，得到整数结果（向下取整）。\nf = 10 // 3\n\nprint(f\"f 的值是: {f}\")\n\n\nf 的值是: 3\n\n\n\n# 取余运算符（模运算符） (%)：用于得到两个数相除的余数。\ng = 10 % 3\n\nprint(f\"g 的值是: {g}\")\n\n\ng 的值是: 1\n\n\n\n# 幂运算符 (**)：用于将一个数的值提高到另一个数的幂。\nh = 2 ** 3\n\nprint(f\"h 的值是: {h}\")\n\nh 的值是: 8\n\n\n\n\n二、赋值运算符\n赋值运算符是编程中用来给变量赋值的特殊符号。在Python中，常见的赋值运算符是等号=。它的作用是将右边的值赋给左边的变量，从而将数据存储在变量中，方便后续的使用和操作。\n除了等号外，还有一些拓展的赋值运算符，它们的作用是在进行运算的同时进行赋值，使得代码更加简洁高效。以下是常见的拓展赋值运算符：\n\n\n\n\n\n\n\n\n\n运算符\n名称\n描述\n示例\n\n\n\n\n=\n等号\n将右边的值赋给左边的变量\nx = 10\n\n\n+=\n加等\n将右边的值与左边的变量相加，并赋值\nx += 5（等同于x = x + 5）\n\n\n-=\n减等\n将右边的值从左边的变量中减去，并赋值\ny -= 3（等同于y = y - 3）\n\n\n*=\n乘等\n将右边的值与左边的变量相乘，并赋值\nz *= 4（等同于z = z * 4）\n\n\n/=\n除等\n将左边的变量除以右边的值，并赋值\na /= 2（等同于a = a / 2）\n\n\n//=\n整数除等\n将左边的变量整数除以右边的值，并赋值\nb //= 3（等同于b = b // 3）\n\n\n%=\n取余等\n将左边的变量除以右边的值取余，并赋值\nc %= 4（等同于c = c % 4）\n\n\n**=\n幂等\n将左边的变量的值提高到右边的值的幂，并赋值\nd **= 3（等同于d = d ** 3）\n\n\n\n你可以在在JupyterLab中尝试以下关于赋值运算符的简单示例，这将有助于你更好地理解赋值运算符的概念。\n\n# 赋值运算符：将右边的值赋给左边的变量\nx = 10\nprint(f\"x 的值是: {x}\")\n\nx 的值是: 10\n\n\n\n# 扩展赋值运算符示例：\n# 加等运算符：将右边的值与左边的变量相加，并赋值\nx += 5  # 等同于 x = x + 5\nprint(f\"x 的值是: {x}\")\n\n\n# 减等运算符：将右边的值从左边的变量中减去，并赋值\ny = 20\ny -= 3  # 等同于 y = y - 3\nprint(f\"y 的值是: {y}\")\n\n\n# 乘等运算符：将右边的值与左边的变量相乘，并赋值\nz = 3\nz *= 4  # 等同于 z = z * 4\nprint(f\"z 的值是: {z}\")\n\n\n# 除等运算符：将左边的变量除以右边的值，并赋值\na = 15\na /= 2  # 等同于 a = a / 2\nprint(f\"a 的值是: {a}\")\n\n\n# 整数除等运算符：将左边的变量整数除以右边的值，并赋值\nb = 10\nb //= 3  # 等同于 b = b // 3\nprint(f\"b 的值是: {b}\")\n\n\n# 取余等运算符：将左边的变量除以右边的值取余，并赋值\nc = 17\nc %= 4  # 等同于 c = c % 4\nprint(f\"c 的值是: {c}\")\n\n\n# 幂等运算符：将左边的变量的值提高到右边的值的幂，并赋值\nd = 2\nd **= 3  # 等同于 d = d ** 3\nprint(f\"d 的值是: {d}\")\n\n\n\n三、比较运算符\n比较运算符在Python中是用来比较两个值之间的关系的特殊符号。它们让我们可以判断变量之间是否相等、大小关系以及其他比较情况。通过使用这些运算符，我们可以轻松地进行逻辑判断，从而在程序中做出不同的决策和控制流程。让我们看看以下比较运算符的示例和用法。\n\n\n\n\n\n\n\n\n\n运算符\n名称\n描述\n示例\n\n\n\n\n==\n等于\n判断两个操作数是否相等\nx == y （如果x等于y，结果为True）\n\n\n!=\n不等于\n判断两个操作数是否不相等\nx != y （如果x不等于y，结果为True）\n\n\n&gt;\n大于\n判断左操作数是否大于右操作数\nx &gt; y （如果x大于y，结果为True）\n\n\n&lt;\n小于\n判断左操作数是否小于右操作数\nx &lt; y （如果x小于y，结果为True）\n\n\n&gt;=\n大于等于\n判断左操作数是否大于等于右操作数\nx &gt;= y （如果x大于等于y，结果为True）\n\n\n&lt;=\n小于等于\n判断左操作数是否小于等于右操作数\nx &lt;= y （如果x小于等于y，结果为True）\n\n\n\n这些比较运算符允许我们对变量进行各种比较操作，用于条件判断、循环控制和逻辑运算，是编程中非常常用的一类运算符。以下代码是比较运算符的简单应用示例：\n\nx = 5\ny = 10\n\n# 等于运算符 (==)：判断两个操作数是否相等\nprint(x == y)\n\nFalse\n\n\n\n# 不等于运算符 (!=)：判断两个操作数是否不相等\nprint(x != y)\n\nTrue\n\n\n\n# 大于运算符 (&gt;)：判断左操作数是否大于右操作数\nprint(x &gt; y)\n\nFalse\n\n\n\n# 小于运算符 (&lt;)：判断左操作数是否小于右操作数\nprint(x &lt; y)\n\nTrue\n\n\n\n# 大于等于运算符 (&gt;=)：判断左操作数是否大于等于右操作数\nprint(x &gt;= y)\n\nFalse\n\n\n\n# 小于等于运算符 (&lt;=)：判断左操作数是否小于等于右操作数\nprint(x &lt;= y)\n\nTrue\n\n\n\n\n\n\n\n\nNote\n\n\n\n在Python中应用运算符时，务必注意赋值运算符=表示赋值操作，而==才与我们在日常生活中理解的’等于’概念相近。因此，在使用这些运算符时要区分清楚，避免混淆。\n\n\n\n\n四、逻辑运算符\n在编程世界中，逻辑运算符是我们用来进行逻辑判断的特殊工具。它们让我们可以对布尔值进行逻辑操作，以便在程序中根据不同的条件做出不同的决策和控制流程。通过合理地使用逻辑运算符，我们能够将复杂的条件表达式简化为更直观、更高效的代码，使得程序更加灵活、可读性更强。现在，让我们一起来了解一下逻辑运算符的各种用法和示例。\n\n\n\n\n\n\n\n\n\n运算符\n名称\n描述\n示例\n\n\n\n\nand\n逻辑”与”\n当两个操作数都为True时，结果为True\nx and y （如果x和y都为True，结果为True；否则为False）\n\n\nor\n逻辑”或”\n当两个操作数中有一个为True时，结果为True\nx or y （如果x或y有一个为True，结果为True；如果x和y都为False，结果为False）\n\n\nnot\n逻辑”非”\n用于取反操作，如果操作数为True，则结果为False，如果为False，则结果为True\nnot x （如果x为False，结果为True；如果x为True，结果为False）\n\n\n\n逻辑运算符是在条件判断、循环控制和逻辑运算中非常常用的工具，它们帮助我们进行布尔值的组合和判断，使得程序更加灵活、高效和直观。\n尝试一下下面的代码，相信你能很快掌握逻辑运算符的概念。\n\n# 定义两个变量\nx = True\ny = False\n\n# 逻辑与运算符 (and)：当两个操作数都为True时，结果为True，否则为False\nprint(x and y)\n\nFalse\n\n\n\n# 逻辑或运算符 (or)：当两个操作数中有一个为True时，结果为True，否则为False\nprint(x or y)\n\nTrue\n\n\n\n# 逻辑非运算符 (not)：用于取反操作，如果操作数为True，则结果为False，如果为False，则结果为True\nprint(not x)\n\nFalse\n\n\n\n\n五、身份运算符与成员运算符\n在Python中，身份运算符是用于比较两个对象的内存地址是否相同的特殊工具，允许我们判断两个变量是否指向同一个对象，以及是否指向不同的对象，从而更加精确地比较对象之间的关系。\n成员运算符则用于检查某个值是否属于某个容器（如列表、元组、集合等），允许我们判断一个值是否存在于容器中，从而帮助进行成员检查和数据过滤。在处理集合数据时，成员运算符非常有用，能够轻松地判断元素是否在容器中，并做出相应的处理。\n现在，让我们一起来探索这些运算符的用法和示例。\n身份运算符 (Identity Operators)\n\n\n\n\n\n\n\n\n\n运算符\n名称\n描述\n示例\n\n\n\n\nis\n是同一对象\n判断两个对象的内存地址是否相同\nx is y （如果x和y指向同一对象，结果为True）\n\n\nis not\n不是同一对象\n判断两个对象的内存地址是否不相同\nx is not y （如果x和y指向不同对象，结果为True）\n\n\n\n成员运算符 (Membership Operators):\n\n\n\n\n\n\n\n\n\n运算符\n名称\n描述\n示例\n\n\n\n\nin\n存在于\n判断某个值是否存在于某个容器中\nx in list （如果x在列表list中，结果为True）\n\n\nnot in\n不存在于\n判断某个值是否不存在于某个容器中\nx not in set （如果x不在集合set中，结果为True）\n\n\n\n下面这些示例展示了身份运算符和成员运算符在Python中的基本用法。身份运算符用于比较对象的内存地址是否相同，而成员运算符用于判断值是否存在于容器中。这些运算符在Python编程中非常常用，能够帮助我们进行对象和数据的比较、判断和过滤。\n\n# 身份运算符示例\nx = [1, 2, 3]\ny = x\nz = [1, 2, 3]\n\n# is运算符：判断两个对象的内存地址是否相同\nprint(x is y)\nprint(x is z)\n\n\nTrue\nFalse\n\n\n\n# is not运算符：判断两个对象的内存地址是否不相同\nprint(x is not y)\nprint(x is not z)\n\nFalse\nTrue\n\n\n\n# 成员运算符示例\nfruits = [\"apple\", \"banana\", \"orange\"]\n\n# in运算符：判断某个值是否存在于某个容器中\nprint(\"apple\" in fruits)\nprint(\"grape\" in fruits)\n\nTrue\nFalse\n\n\n\n# not in运算符：判断某个值是否不存在于某个容器中\nprint(\"apple\" not in fruits)\nprint(\"grape\" not in fruits)\n\nFalse\nTrue"
  },
  {
    "objectID": "02_03_Python数据结构.html#数据结构",
    "href": "02_03_Python数据结构.html#数据结构",
    "title": "3  Python数据结构",
    "section": "数据结构",
    "text": "数据结构\n数据结构是计算机科学中研究和组织数据的一种方式。它是一种将数据按照特定的方式进行存储、组织和管理的方法，以便于在计算机程序中进行访问、处理和操作。\n数据结构可以看作是数据的容器，它定义了数据元素之间的关系，以及对这些数据元素进行操作的方法。不同的数据结构适用于不同的应用场景，它们可以是简单的数据类型（如整数、浮点数等），也可以是复杂的组合类型（如列表、元组、字典等）。\n在Python中，数据结构是指用于存储和组织数据的不同方式和容器。Python提供了多种内置的数据结构，使得在程序中可以更加灵活地操作和处理数据。\n\n一、列表\n\n1. 列表的概念\n列表 (Lists) 是Python中最常用的数据结构之一。它是一种有序的可变序列，可以存储多个元素，并且允许在列表中添加、删除、修改元素。列表使用方括号 [ ] 表示，各个元素之间用逗号 , 分隔。列表可以根据索引来访问和修改元素，可以存储不同类型的数据，并且允许重复元素。\n另外，列表支持嵌套，也就是说，列表中的元素，也可以是列表或任意类型的数据结构。\n尝试跟着下面的示例，来创建一些列表：\n\n# 创建一个整数列表\nnumbers = [1, 2, 3, 4, 5]\n\nprint(numbers)\nprint(type(numbers))\n\n[1, 2, 3, 4, 5]\n&lt;class 'list'&gt;\n\n\n\n# 创建一个字符串列表\nfruits = [\"apple\", \"banana\", \"orange\"]\n\nprint(fruits)\nprint(type(fruits))\n\n['apple', 'banana', 'orange']\n&lt;class 'list'&gt;\n\n\n\n# 创建一个混合类型的列表\nmixed_list = [1, \"hello\", True, 3.14]\n\nprint(mixed_list)\nprint(type(mixed_list))\n\n[1, 'hello', True, 3.14]\n&lt;class 'list'&gt;\n\n\n\n# 创建一个嵌套列表\nnested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nprint(nested_list)\nprint(type(nested_list))\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n&lt;class 'list'&gt;\n\n\n\n\n\n\n\n\nNote\n\n\n\n列表是有序的序列，因此列表中的每一个元素都有一个索引，索引从0开始，从前往后，依次递增，表示元素在列表中的位置。\n\n\n现在，让我们来看一看，有哪些关于列表的常用操作。\n\n\n2. 列表的常用操作\n\n(1) 查找\n由于列表是一种可以存储多个元素的有序的数据结构，并且支持索引，因此，我们可以根据索引来查找列表中特定的元素。\na. 索引查找\n延续刚才的代码，使用索引来查找其中特定的元素。注意，如果列表是嵌套的列表，同样支持下标索引。在查询嵌套列表中的下标索引时，先找到内层列表的下标编号，在找到内层列表元素在内层列表中的下标编号，将二者联合查询。\n\nprint(f\"整数列表 numbers 中的第一个元素是：{numbers[0]}\")\nprint(f\"字符串列表 fruits 中的第二个元素是：{fruits[1]}\")\nprint(f\"混合列表中 mixed_list 的第三个元素是：{mixed_list[2]}\")\nprint(f\"嵌套列表 nested_list 的第一个子元素中的第一个元素是：nested_list[0][0]\")\n\n整数列表 numbers 中的第一个元素是：1\n字符串列表 fruits 中的第二个元素是：banana\n混合列表中 mixed_list 的第三个元素是：True\n嵌套列表 nested_list 的第一个子列表中的第一个元素是：nested_list[0][0]\n\n\n索引可以帮助我们取出特定位置的数据。另外，下标索引除了从前往后，从0开始递增排序，也可以从最后一个元素开始，从后往前，从-1开始向前递减排序。\nb. .index()方法查找\n除了直接使用索引进行查找指定元素，我们也可以使用.index()方法来查找元素的索引。如果元素不存在，则会抛出ValueError异常。该方法返回列表中第一个匹配的元素的索引。\n试试看下面的代码，你就可以得到特定元素的索引。\n\nprint(f\"整数列表 numbers 中元素 1 的索引是：{numbers.index(1)}\")\nprint(f\"字符串列表 fruits 中元素 apple 的索引是：{fruits.index('apple')}\")\nprint(f\"混合列表中 mixed_list 中元素 3.14 的索引是：{mixed_list.index(3.14)}\")\nprint(f\"嵌套列表 nested_list 中子元素 [1, 2 ,3] 的索引是：{nested_list.index([1, 2, 3])}\")\n\n整数列表 numbers 中元素 1 的索引是：0\n字符串列表 fruits 中元素 apple 的索引是：0\n混合列表中 mixed_list 中元素 3.14 的索引是：3\n嵌套列表 nested_list 中子列表 [1, 2 ,3] 的索引是：0\n\n\n在使用下标索引时，要注意索引的取值范围，超出范围将无法取出元素，并且报错。\n\n\n(2) 修改\n在Python中，列表是可变的，我们可以在需要时对列表中的元素进行修改操作。\n与查找元素一样，修改列表中的元素也是通过索引实现的。\n\n# 查看原列表中的内容\nprint(f\"原列表：{numbers}\")\n\n# 修改列表中的元素\nnumbers[2] = 10\n\n# 查看修改过的列表\nprint(numbers)\n\n原列表：[1, 2, 3, 4, 5]\n[1, 2, 10, 4, 5]\n\n\n列表的可变性使得它在存储和处理数据时非常灵活，在修改列表时，要确保操作的正确性，以避免出现意外的结果。\n\n\n(3) 增加元素\n在Python中，向列表中增加元素一共有两种方法：\na. 在列表末尾添加元素\n使用append()方法可以在列表的末尾添加元素，使用方法如下例所示：\n\n# 查看原列表\nprint(f\"原列表：{fruits}\")\n\n# 在列表末尾添加元素\nfruits.append(\"grape\")\n\n# 查看修改过的列表\nprint(fruits)\n\n原列表：['apple', 'banana', 'orange']\n['apple', 'banana', 'orange', 'grape']\n\n\nb. 在指定位置插入元素\n使用insert()方法可以在列表中的指定位置插入元素，与修改元素一样，我们也需要使用索引用以定位。\n该方法在使用时，要在括号中填入两个参数，第一个参数为索引，第二个参数为添加的元素。insert()\n\n# 查看原列表\nprint(fruits)\n\n# 在指定位置添加元素\nfruits.insert(2,\"watermelon\")\n\n# 查看修改过的列表\nprint(fruits)\n\n['apple', 'banana', 'orange', 'grape']\n['apple', 'banana', 'watermelon', 'orange', 'grape']\n\n\n\n\n(4) 追加多个元素\n有时候，我们会遇见需要追加多个元素的情况，可以使用extend()方法，将其它数据容器的内容取出，依次追加到列表尾部。其语法为：\n\nnumbers.extend(fruits)\n\nprint(numbers)\n\n[1, 2, 10, 4, 5, 'apple', 'banana', 'watermelon', 'orange', 'grape']\n\n\n\n\n(5) 删除元素\n在Python中，有三种常用的方法可以删除列表中的元素。\na. del方法\n使用del方法将根据索引删除指定位置的元素。\n\n# 查看原列表\nprint(f\"原列表：{numbers}\")\n\n# 根据索引，删除指定位置的元素\ndel numbers[3]\n\n# 查看修改过的列表\nprint(numbers)\n\n原列表：[1, 2, 10, 4, 5, 'apple', 'banana', 'watermelon', 'orange', 'grape']\n[1, 2, 10, 5, 'apple', 'banana', 'watermelon', 'orange', 'grape']\n\n\nb. pop()方法\npop()方法在删除指定索引位置的元素时，还会将其返回出来，你可以使用一个变量来接收这个返回值。\n\n\n\n\n\n\nNote\n\n\n\n你可以将pop()方法的逻辑理解为，将列表中指定位置的元素提取了出来，并且不再放回原列表。\n\n\n如果不向括号中填入索引，pop()方法将默认删除末尾元素。\n\n# 查看原列表\nprint(f\"原列表：{numbers}\")\n\n# 根据索引，删除指定位置的元素\npopped_element = numbers.pop(1)\n\n# 查看修改过的列表\nprint(numbers)\nprint(popped_element)\n\n原列表：[1, 2, 10, 5, 'apple', 'banana', 'watermelon', 'orange', 'grape']\n[1, 10, 5, 'apple', 'banana', 'watermelon', 'orange', 'grape']\n2\n\n\nc. remove()方法\n使用remove()方法将会删除第一个匹配的元素，如果不存在则会抛出异常。\n\n# 查看原列表\nprint(f\"原列表{fruits}\")\n\n# 删除指定的元素\nfruits.remove(\"banana\")\n\n# 查看修改过的列表\nprint(fruits)\n\n原列表['apple', 'banana', 'orange']\n['apple', 'orange']\n\n\n列表是Python编程中非常常用的数据结构，它可以用于存储各种类型的数据，并且允许灵活地对数据进行增删改查操作，提供了强大的功能来处理和组织数据。\n大家可以试着创建一个新的列表，并对它进行添加、删除、修改以及查找等操作，以加深对列表的理解。\n\n\n\n\n二、元组\n\n1. 元组的概念\n元组（Tuple）是Python中的一种数据结构，类似于列表，但具有一些重要的区别。元组是有序的，可以包含多个元素，而且一旦创建后，其元素是不可变的，即不可被修改。元组使用圆括号()表示，元素之间用逗号,分隔。\n与列表不同，元组的不可变性使得它适用于存储那些不希望被改变的数据，例如坐标、日期、配置信息等。\n与列表相似的是，元组也支持嵌套操作，这意味着我们可以在一个元组中包含其他元组或任意类型的数据结构，包括列表、字典等。\n\n\n\n\n\n\nNote\n\n\n\n可以认为元组就是一个只读的列表，但是要注意元组内只有一个数据时，这个数据后也要加上,\n\n\n\n# 创建一个整数元组\nnumbers = (1, 2, 3, 4, 5)\n\nprint(numbers)\nprint(type(numbers))\n\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\n('apple', 'banana', 'orange')\n&lt;class 'tuple'&gt;\n[1, 'hello', True, 3.14]\n&lt;class 'list'&gt;\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n&lt;class 'list'&gt;\n\n\n\n# 创建一个字符串元组\nfruits = (\"apple\", \"banana\", \"orange\")\n\nprint(fruits)\nprint(type(fruits))\n\n\n('apple', 'banana', 'orange')\n&lt;class 'tuple'&gt;\n\n\n\n# 创建一个混合类型的元组\nmixed_tuple = (1, \"hello\", True, 3.14)\n\nprint(mixed_list)\nprint(type(mixed_list))\n\n\n\n\n\n\n\nNote\n\n\n\n元组也是有序的序列，元组中的每一个元素都有一个索引，索引从0开始，从前往后，依次递增，表示元素在元组中的位置。\n\n\n\n\n2. 元组的常用操作\n\n(1) 查找\n元组具有与列表一样的下标索引规则，因此也可以通过下标索引进行查找操作。\na. 索引查找\n\nprint(f\"查找整数元组 numbers 中的第一个元素：{numbers[0]}\")  # 输出：1\nprint(f\"查找字符串元组 fruits 中的第二个元素：{fruits[1]}\")   # 输出：\"banana\"\n\n查找整数元组 numbers 中的第一个元素：1\n查找字符串元组 fruits 中的第二个元素：banana\n\n\nb. index()方法查找\n\nprint(numbers.index(1))\nprint(fruits.index('apple'))\nprint(mixed_list.index(3.14))\n\n0\n0\n3\n\n\n\n\n(2) 尝试修改\n与列表不同的是，元组中的内容是不可变的，因此无法直接修改元组中的元素，如果尝试修改则会引发异常\n\nnumbers[2] = 10\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\n\n\n\nNote\n\n\n\n当元组中包含嵌套的列表时，我们可以修改列表中的元素，但不能改变列表本身的数据类型。\n\n\n\n\n(3) 解包\n在Python中，解包（Unpacking）是一种特殊的操作，用于将一个序列（例如列表、元组）或其他可迭代对象中的元素，分别赋值给多个变量。解包可以在一行代码中同时为多个变量赋值，从而方便地提取序列或可迭代对象中的元素。\n解包的语法非常简单，通常使用等号（=）将目标序列与变量列表相结合。要注意的是，被解包的序列中的元素数量必须与变量的数量相匹配，否则会引发ValueError异常。\n\npoint = (10, 20)\nx, y = point\nprint(x)\nprint(y)\n\n元组的不可变性意味着一旦创建了元组，它的内容不会被修改，因此元组通常用于存储一组相关的值，以及在函数返回多个值时使用。虽然元组的内容不可变，但元组本身可以被重新赋值，因此可以用来在不可变和可变数据之间进行转换。\n\n\n\n\n三、字典\n\n1. 字典的概念\n字典是Python中非常重要的数据结构，用于存储键值对(即key-value)映射。字典提供了一种灵活的方式来组织和访问数据，允许根据键快速查找和修改对应的值。字典用花括号{}来创建，每个键值对用冒号:分隔，键必须是不可变的类型，通常使用字符串或整数。\n注意，字典是无序键值对的集合，每个键都是唯一的。这也意味着，字典不可以通过索引来访问，只可以通过’键’来查找’值’。\n\n\n\n\n\n\nNote\n\n\n\n字典中’键’对应的’值’可以为任意元素，也可以为列表、元组等数据结构。\n\n\n\n# 创建一个空字典\nempty_dict = {}\n\n# 创建一个包含键值对的字典\nperson = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"city\": \"New York\"\n}\n\nprint(person)\n\n\n\n2. 字典的常用操作\n\n(1) 查找\n在字典中，由于字典自身的无序性，所以需要使用’键’来代替索引进行查找。\n\nprint(person[\"name\"])\nprint(person[\"age\"])\n\n但是在查找时要注意，如果输入的’键’不存在，会引发KeyError异常。为避免异常，可以使用get()方法来查找’键’对应的’值’。\n\nprint(person.get(\"city\"))\nprint(person.get(\"occupation\"))  # 键\"occupation\"不存在时返回None\n\n\n\n(2) 修改\n字典中的值是可以修改的，与查找过程类似，我们也需要通过指定’键’来更新对应的’值’。\n\nperson[\"age\"] = 31\nprint(person[\"age\"])\n\n如果输入的’键’是字典中不存在的，则会向字典中添加一个键值对。\n\nperson[\"occupation\"] = \"Engineer\"\nprint(person)\n\n\n\n(3) 删除\n对于字典，我们可以使用del方法来进行删除指定的键值对。\n\n# 使用del删除指定键值对\ndel person[\"age\"]\n\n# 输出结果\nprint(person)\n\n也可以使用.clear()方法清空字典中的所有条目。\n\n# 使用clear()清空字典\nperson.clear()\n\n# 输出结果\nprint(person)\n\n字典Dict中键和值是一 一对应的，键是唯一的，如果重复最后的一个键【值】对会替换前面的。若一个键中需要存放多个值，可以考虑使用元组Tuple和列表List 。\n字典是Python编程中非常重要的数据结构，它允许将数据组织为键值对的形式，方便快速查找和修改数据。字典的灵活性和高效性使其在很多场景中得到广泛应用，例如用于存储配置信息、处理JSON数据、构建数据库等。\n\n\n\n\n四、数据结构的通用操作\n数据结构尽管各自有各自的特点，但是也存在一些通用的操作。\n\n1. 通用的统计操作\n\n\n\n\n\n\nNote\n\n\n\n字符串的大小比较是通过ASCⅡ码表进行的，从头到尾，一位位进行比较，其中一位大，后面就无需比较了。对于单个字符，将其转换为ASCⅡ码表中对应的码值数字后来确定大小。\n\n\n\n(1) 统计元素个数\n\nlen(容器)\n\n\n\n(2) 统计最大/最小元素\n\n# 统计最大元素\nmax(容器)\n\n# 统计最小元素\nmin(容器)\n\n\n\n\n2. 通用转换功能\n\n使用 list() 函数将元组转换为列表。\n使用 tuple() 函数将列表转换为元组\n\n\n\"\"\"\n列表、元组互相转换时，看起来会好像只有括号的形式变了\n\"\"\"\n\n# 将给定容器转换为列表\nlist(容器)\n    \"\"\"\n    * 字符串列表时，会将字符串内的每一个字符提取出来作为列表内的一个新元素\n    * 字典转列表时，会舍弃value，只保留key作为列表里面的元素\n    \"\"\"\n    \n    \n# 将给定容器转换为元组\ntuple(容器)\n    \"\"\"\n    * 字符串元组时，会将字符串内的每一个字符提取出来作为元组内的一个新元素\n    * 字典转元组时，会舍弃value，只保留key作为元组里面的元素\n    \"\"\"\n    \n\n\n# 元组转列表\nmy_tuple = (1, 2, 3, 4, 5)\nmy_list = list(my_tuple)\nprint(my_list)\n\n\n# 列表转元组\nmy_list = [1, 2, 3, 4, 5]\nmy_tuple = tuple(my_list)\nprint(my_tuple)\n\n\n# keys() 是一个字典(Dictionary)对象的方法，用于返回字典中所有的键\n\nmy_dict = {\"name\": \"John\", \"age\": 25, \"city\": \"New York\"}\nmy_list = list(my_dict.keys())\nprint(my_list)\n\nprint(type(my_list))\n\n如果想要将字典转换为元组，可以使用items()方法。\n\n# 使用 items() 方法获取字典的键值对，然后使用 tuple() 函数将键值对转换为元组。\n\nmy_dict = {\"name\": \"John\", \"age\": 25, \"city\": \"New York\"}\nmy_tuple = tuple(my_dict.items())\nprint(my_tuple)\n\nprint(type(my_tuple))\n\n\n\n3. 通用排序功能\n使用sorted函数，可以将容器从小到大排序；如果添加reverse=True参数，则会将排序结果反转。\n\nsorted(容器, reverse=True)\n# 使用sorted函数进行排序后，会将内容全部转换为列表对象，实际上，这个函数就是将排序结果放入了列表之中。\n\n\n\n\n五、列表、元组、字典的异同点\n\n1. 列表、元组、字典的相同点：\n\n都是Python中常用的数据结构，用于存储和组织数据。\n都可以存储多个元素，可以包含不同类型的数据。\n都支持索引访问，可以根据位置获取元素。\n都可以用于存储任意数量的数据项。\n都可以通过迭代和循环遍历其中的元素。\n\n\n\n2. 列表、元组、字典的不同点：\n\n可变性：\n\n列表是可变的，可以随时添加、删除和修改其中的元素。\n元组是不可变的，一旦创建了元组，就不能修改其中的元素。\n字典也是可变的，可以根据键添加、删除和修改对应的值。\n\n创建方式：\n\n列表使用方括号 [] 创建。\n元组使用圆括号 () 创建。\n字典使用花括号 {} 创建，每个键值对用冒号 : 分隔。\n\n可以包含的数据类型：\n\n列表和元组都可以包含不同类型的数据，甚至可以包含其他列表或元组（嵌套结构）。\n字典的值可以是任意类型的数据，而键必须是不可变的类型，通常使用字符串或整数。\n\n访问元素方式：\n\n列表和元组使用索引来访问元素，索引从0开始。\n字典使用键来查找对应的值，键必须是唯一的。\n\n适用场景：\n\n列表适用于存储有序、可变的数据集合，常用于保存一组相关的数据项。\n元组适用于存储有序、不可变的数据集合，常用于函数返回多个值或作为字典的键。\n字典适用于存储键值对映射，常用于需要通过键快速查找对应值的情况。\n\n\n总的来说，列表、元组和字典都是有用且重要的数据结构，根据不同的需求和场景，我们可以灵活地选择使用其中的任何一个或多个来处理和组织数据。"
  },
  {
    "objectID": "03_01_Plotly图表绘制与可视化.html#plotly怎么安装",
    "href": "03_01_Plotly图表绘制与可视化.html#plotly怎么安装",
    "title": "4  Plotly 图表绘制与可视化",
    "section": "Plotly怎么安装？",
    "text": "Plotly怎么安装？\n要安装 Plotly，你可以在jupyter中执行以下命令：\n\n# jupyter中安装\n!pip install plotly\n\n# 使用 pip 包管理器在命令行或终端中运行\npip install plotly"
  },
  {
    "objectID": "03_01_Plotly图表绘制与可视化.html#kaleido包安装用于导出图片",
    "href": "03_01_Plotly图表绘制与可视化.html#kaleido包安装用于导出图片",
    "title": "4  Plotly 图表绘制与可视化",
    "section": "Kaleido包安装（用于导出图片）",
    "text": "Kaleido包安装（用于导出图片）\nKaleido 是一个用于生成静态图片或动画的Python绘图工具，它与 Plotly 结合使用，可以帮助你在没有图形界面的服务器上生成图形，并且不需要依赖浏览器或显示器。\n在安装 Kaleido 之前，确保你已经安装了 Python 和 pip。然后按照以下步骤来安装 Kaleido：\n\n# jupyter中安装\n!pip install -U kaleido\n\n# 命令行中安装\npip install -U kaleido\n\n安装完成后，你就可以在 Python 脚本或 Jupyter Notebook 中导入 Plotly，并开始使用它来创建交互式和美观的可视化图表。例如，在 Python 脚本或 Jupyter Notebook 中导入 Plotly：\n\nimport plotly.express as px"
  },
  {
    "objectID": "03_01_Plotly图表绘制与可视化.html#使用plotly可以绘制什么图表",
    "href": "03_01_Plotly图表绘制与可视化.html#使用plotly可以绘制什么图表",
    "title": "4  Plotly 图表绘制与可视化",
    "section": "使用Plotly可以绘制什么图表？",
    "text": "使用Plotly可以绘制什么图表？\n\n散点图（Scatter plot）\n\n散点图的概念和用途：用于展示两个变量之间的关系，如相关性、分布等。\n创建散点图：px.scatter() 函数，设置 x 轴和 y 轴数据，以及通过颜色映射和大小映射展示额外信息。\n\n折线图（Line plot）\n\n折线图的作用：展示随时间或其他连续变量的变化趋势，如时间序列数据、趋势分析等。\n创建折线图： px.line() 函数，包括设置 x 轴和 y 轴数据，添加标记点、调整线条样式等。\n\n柱状图（Bar chart）\n\n解释柱状图的用途：用于比较不同类别或组之间的数值差异，比如销售额、人口统计等。\n创建柱状图： px.bar() 函数，包括设置 x 轴和 y 轴数据，添加堆叠柱状图、分组柱状图等。\n\n饼图（Pie chart）\n\n饼图的含义：展示数据在整体中的占比情况，适用于展示相对比例。\n绘制饼图：px.pie() 函数，设置数据和标签，调整颜色、标签位置等。\n\n直方图（Histogram）\n\n直方图的作用：用于展示数据的分布情况，特别适用于连续变量，帮助了解数据的分布范围和形态。\n绘制直方图： px.histogram() 函数，参数须了解，如 bin 大小、频数或频率显示等。\n\n箱线图（Box plot）\n\n箱线图的含义：用于显示数据的统计特征，如中位数、四分位数和异常值，帮助了解数据的分布和离群点。\n绘制箱线图：px.box() 函数，设置 x 轴和 y 轴数据，添加多个箱线图、调整样式等。"
  },
  {
    "objectID": "03_01_Plotly图表绘制与可视化.html#绘制图表需要掌握的函数理解即可",
    "href": "03_01_Plotly图表绘制与可视化.html#绘制图表需要掌握的函数理解即可",
    "title": "4  Plotly 图表绘制与可视化",
    "section": "绘制图表需要掌握的函数（理解即可）",
    "text": "绘制图表需要掌握的函数（理解即可）\n\npx.scatter() 函数绘制散点图\npx.scatter() 是 Plotly Express 中用于创建散点图的函数。散点图用于展示两个变量之间的关系，并通过点的位置和颜色来表示数据的特征。该函数简化了创建散点图的过程，只需提供数据和一些基本参数，即可生成可视化图形。\n以下是 px.scatter() 函数的简单案例：（复制代码测试下图表效果即可，理解其中参数）\n\n\n\n\n\n\nWarning\n\n\n\nplotly在本地运行无法显示图片的话，可以尝试直接使用 fig.show()，去掉 renderer=\"notebook\"\n\n\n\nimport plotly.express as px\n\n# 准备数据\nx_data = [1, 2, 3, 4, 5]\ny_data = [10, 12, 8, 14, 9]\n\n# 使用px.scatter()创建散点图\nfig = px.scatter(x=x_data, y=y_data, title='散点图', labels={'x': 'X轴', 'y': 'Y轴'})\n\n# 显示图表，使用 fig.show() 即可\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n参数解释：\n\nx（必需参数）：这是一个列表、一维数组或DataFrame列，用于指定散点图中X轴的数据。\ny（必需参数）：这是一个列表、一维数组或DataFrame列，用于指定散点图中Y轴的数据。\ndata_frame（可选参数）：这是一个DataFrame，如果您有一个数据框，可以通过data_frame参数直接指定，而不需要分别指定x和y参数。\ntitle（可选参数）：用于设置散点图的标题，以字符串形式指定。\nlabels（可选参数）：一个字典，用于指定X轴和Y轴的标签。例如，labels={'x': '时间', 'y': '销量'}将X轴标签设置为”时间”，Y轴标签设置为”销量”。\ncolor（可选参数）：用于设置散点图的颜色。您可以通过指定颜色名称或HEX代码来自定义散点的颜色。还可以设置为列名或一维数组，根据其值自动给散点上色。\nsize（可选参数）：用于设置散点的大小。可以指定一个数值或列名，根据数据中的值调整散点的大小。\ntemplate（可选参数）：用于设置图表的样式模板，包括颜色、背景等。\ntrendline（可选参数）：是否显示散点图上的趋势线。\n\n通过 px.scatter() 函数，你可以轻松地创建各种散点图，将数据可视化，发现变量之间的关系，并更好地理解数据的特征和模式。\n\n\npx.line()绘制折线图\n当使用Plotly Express中的px.line()函数时，您可以绘制折线图（Line Plot），它是一种展示数据随连续变量变化而变化的图表。px.line()函数是Plotly库的高级封装，它简化了创建折线图的过程，使可视化变得更加简单和快捷。\n下面是px.line()函数的基本用法和常用参数解释：（复制代码测试下图表效果即可，理解其中参数）\n\nimport plotly.express as px\n\n# 准备数据\nx_data = [1, 2, 3, 4, 5]\ny_data = [10, 12, 8, 14, 9]\n\n# 使用px.line()创建折线图\nfig = px.line(x=x_data, y=y_data, title='折线图', labels={'x': 'X轴', 'y': 'Y轴'})\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n参数解释：\n\nx（必需参数）：这是一个列表或一维数组，用于指定折线图中X轴的数据点。\ny（必需参数）：这也是一个列表或一维数组，用于指定折线图中Y轴的数据点。\ndata_frame（可选参数）：这是一个DataFrame，如果您有一个数据框，可以通过data_frame参数直接指定，而不需要分别指定x和y参数。\ntitle（可选参数）：用于设置折线图的标题，以字符串形式指定。\nlabels（可选参数）：一个字典，用于指定X轴和Y轴的标签。例如，labels={'x': '时间', 'y': '销量'}将X轴标签设置为”时间”，Y轴标签设置为”销量”。\nline_group（可选参数）：用于绘制多个折线图并将它们分组。这个参数可以指定一个列名或一维数组，具有相同值的数据点将被视为同一组，并绘制在同一条折线上。\ncolor_discrete_sequence（可选参数）：用于指定折线的颜色序列。您可以通过指定颜色名称或HEX代码的列表来自定义折线的颜色。\ntemplate（可选参数）：用于设置图表的样式模板，包括颜色、背景等。\n\n\n\npx.bar()绘制条形图\npx.bar()函数是Plotly Express库中的一个函数，用于绘制条形图（Bar Chart）。条形图是一种常用的数据可视化方式，用于展示不同类别之间的数量或比较数据。\n以下是px.bar()函数的基本用法和常用参数解释：（复制代码测试下图表效果即可，理解其中参数）\n\nimport plotly.express as px\n\n# 准备数据\ncategories = ['A', 'B', 'C', 'D', 'E']\nvalues = [30, 15, 20, 25, 10]\n\n# 使用 px.bar() 创建条形图\nfig = px.bar(x=values, y=categories, orientation='h', title='条形图', labels={'x': '数量', 'y': '类别'})\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n参数解释：\n\nx（必需参数）：这是一个列表、一维数组或DataFrame列，用于指定条形图中各个条形的类别或X轴数据。\ny（必需参数）：这是一个列表、一维数组或DataFrame列，用于指定条形图中各个条形的高度或Y轴数据。\ndata_frame（可选参数）：这是一个DataFrame，如果您有一个数据框，可以通过data_frame参数直接指定，而不需要分别指定x和y参数。\ntitle（可选参数）：用于设置条形图的标题，以字符串形式指定。\norientation(可选参数): 用于设置条形图的方向，‘h’ 表示水平，‘v’ 表示垂直\nlabels（可选参数）：一个字典，用于指定X轴和Y轴的标签。例如，labels={'x': '产品', 'y': '销量'}将X轴标签设置为”产品”，Y轴标签设置为”销量”。\ncolor（可选参数）：用于设置条形图的颜色。您可以通过指定颜色名称或HEX代码来自定义条形的颜色。还可以设置为列名或一维数组，根据其值自动给条形上色。\nbarmode（可选参数）：用于指定多个数据系列的条形图显示模式。默认为”group”，表示每个类别的不同系列将并排显示。还可以设置为”stack”，表示将多个系列堆叠显示。\ntemplate（可选参数）：用于设置图表的样式模板，包括颜色、背景等。\n\n\n\npx.pie()函数绘制饼图\npx.pie()函数是Plotly Express库中的一个函数，用于绘制饼图（Pie Chart）。饼图是一种常见的数据可视化方式，用于展示不同类别的数据在整体中的比例关系。\n以下是px.pie()函数的基本用法和常用参数解释：（复制代码测试下图表效果即可，理解其中参数）\n\nimport plotly.express as px\n\n# 准备数据\nlabels = ['A', 'B', 'C', 'D', 'E']\nvalues = [30, 15, 20, 25, 10]\n\n# 使用px.pie()创建饼图\nfig = px.pie(values=values, names=labels, title='饼图')\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n参数解释：\n\nvalues（必需参数）：这是一个列表、一维数组或DataFrame列，用于指定各个类别的数据值，即饼图的扇区大小。\nnames（必需参数）：这是一个列表、一维数组或DataFrame列，用于指定各个类别的名称，即饼图的标签。\ndata_frame（可选参数）：这是一个DataFrame，如果您有一个数据框，可以通过data_frame参数直接指定，而不需要分别指定values和names参数。\ntitle（可选参数）：用于设置饼图的标题，以字符串形式指定。\ncolor（可选参数）：用于设置饼图扇区的颜色。您可以通过指定颜色名称或HEX代码来自定义扇区的颜色。还可以设置为列名或一维数组，根据其值自动给扇区上色。\ntemplate（可选参数）：用于设置图表的样式模板，包括颜色、背景等。\nhole（可选参数）：用于设置饼图的中心孔的大小。可以指定一个0到1之间的小数，值为0表示完整饼图，值为1表示一个圆环图。\nlabels（可选参数）：用于控制饼图标签的显示方式。默认为”percent”，表示显示百分比标签。也可以设置为”label”，表示显示类别名称标签。还可以设置为”name”，表示显示数据名称标签。\n\n\n\npx.histogram()函数绘制直方图\npx.histogram()函数是Plotly Express库中的一个函数，用于绘制直方图（Histogram）。直方图是一种常见的数据可视化方式，用于展示连续变量的分布情况。\n以下是px.histogram()函数的基本用法和常用参数解释：（复制代码测试下图表效果即可，理解其中参数）\n\nimport plotly.express as px\n\n# 准备数据\ndata = [2, 3, 1, 4, 5, 2, 3, 3, 4, 4, 4, 5, 5, 5]\n\n# 使用px.histogram()创建直方图\nfig = px.histogram(data, title='直方图', labels={'value': '数值', 'count': '频数'})\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n参数解释：\n\ndata_frame（必需参数）：这是一个DataFrame或一维数组，用于指定要绘制直方图的数据。\nx（可选参数）：这是一个字符串或一维数组，用于指定直方图中X轴的数据。如果不指定，x默认为数据列中的值。\nnbins（可选参数）：用于指定直方图的箱子数量，即直方图的条数。默认值为”auto”，会自动选择合适的箱子数量。\ntitle（可选参数）：用于设置直方图的标题，以字符串形式指定。\nlabels（可选参数）：一个字典，用于指定X轴和Y轴的标签。例如，labels={'value': '数值', 'count': '频数'}将X轴标签设置为”数值”，Y轴标签设置为”频数”。\ncolor（可选参数）：用于设置直方图的颜色。您可以通过指定颜色名称或HEX代码来自定义直方图的颜色。\ntemplate（可选参数）：用于设置图表的样式模板，包括颜色、背景等。\nmarginal（可选参数）：用于在直方图的边缘添加边缘直方图或箱线图。可以设置为”rug”、“box”、“violin”等。\n\n\n\npx.box()函数绘制箱线图（仅做了解）\npx.box()函数是Plotly Express库中的一个函数，用于绘制箱线图（Box Plot）。箱线图是一种常见的数据可视化方式，用于展示数据的分布情况和异常值。\n以下是px.box()函数的基本用法和常用参数解释：（复制代码测试下图表效果即可，理解其中参数）\n\nimport plotly.express as px\n\n# 准备数据\ndata_1 = [2, 3, 1, 4, 5, 2, 3, 3, 4, 4, 4, 5, 5, 5]\ndata_2 = [3, 4, 2, 5, 6, 1, 3, 4, 3, 5, 6]\n\n# 合并数据并添加标识列\ndf = []\nfor val in data_1:\n    df.append({'Value': val, 'Data': '数据集1'})\nfor val in data_2:\n    df.append({'Value': val, 'Data': '数据集2'})\n\n# 使用px.box()创建箱线图\nfig = px.box(df, y='Value', color='Data', title='箱线图', labels={'Value': '值', 'Data': '数据集'})\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n参数解释：\n\ndata_frame（必需参数）：这是一个DataFrame，用于指定要绘制箱线图的数据。在我们的例子中，我们使用了一个包含’Value’和’Data’列的DataFrame df，其中’Value’列包含箱线图的Y轴数据，’Data’列用于指定箱线图的不同数据集。\ny（必需参数）：这是一个字符串，用于指定箱线图中Y轴的数据。在我们的例子中，我们将’Value’列作为箱线图的Y轴数据。\ncolor（可选参数）：这是一个字符串，用于设置箱线图的颜色分类。在我们的例子中，我们使用’Data’列作为颜色分类，将两个数据集分别标记为’数据集1’和’数据集2’，这样就可以在箱线图中区分它们。\ntitle（可选参数）：用于设置箱线图的标题，以字符串形式指定。在我们的例子中，我们设置了标题为”箱线图”。\nlabels（可选参数）：一个字典，用于指定图表的标签。例如，labels={'Value': '值', 'Data': '数据集'}将Y轴标签设置为”值”，颜色分类标签设置为”数据集”。\ntemplate（可选参数）：用于设置图表的样式模板，包括颜色、背景等。"
  },
  {
    "objectID": "03_01_Plotly图表绘制与可视化.html#plotly-express图表导出",
    "href": "03_01_Plotly图表绘制与可视化.html#plotly-express图表导出",
    "title": "4  Plotly 图表绘制与可视化",
    "section": "Plotly Express图表导出",
    "text": "Plotly Express图表导出\nPlotly Express图表导出为静态图像文件或生成可分享的交互式图表链接，以下是两种方法的说明：\n\n导出为静态图像文件：\n\n使用plotly.io.write_image()函数可以将Plotly Express图表导出为静态图像文件，支持多种格式，如PNG、JPEG、SVG等。以下是一个示例：\n\nimport plotly.express as px\n\n\n# 准备数据\nx_data = [1, 2, 3, 4, 5]\ny_data = [10, 12, 8, 14, 9]\n\n# 使用px.line()创建折线图\nfig = px.line(x=x_data, y=y_data, title='折线图', labels={'x': 'X轴', 'y': 'Y轴'})\n\n# 导出为静态图像文件（PNG格式）\npio.write_image(fig, 'line_plot.png')\n\n运行上述代码后，将会在当前目录下生成名为”line_plot.png”的PNG格式图片文件，即将折线图保存为静态图像。（记得先选择当前文件夹）\n\n生成可分享的交互式图表链接：\n\n要生成可分享的交互式图表链接，您可以使用plotly.offline.plot()函数。这将创建一个HTML文件，其中包含交互式的Plotly Express图表，并且你可以将此HTML文件分享给其他人。以下是一个示例：\n\nimport plotly.express as px\nimport plotly.offline as pyo\n\n# 准备数据\nx_data = [1, 2, 3, 4, 5]\ny_data = [10, 12, 8, 14, 9]\n\n# 使用px.line()创建折线图\nfig = px.line(x=x_data, y=y_data, title='折线图', labels={'x': 'X轴', 'y': 'Y轴'})\n\n# 生成交互式图表链接并保存为HTML文件\npyo.plot(fig, filename='interactive_line_plot.html')\n\n'interactive_line_plot.html'\n\n\n运行上述代码后，将会在当前目录下生成名为”interactive_line_plot.html”的HTML文件，其中包含交互式的折线图。你可以将此HTML文件分享给其他人，他们可以通过浏览器查看和与图表进行交互。\n通过这两种方法，你可以方便地分享你的Plotly Express图表，无论是静态图像还是交互式图表。"
  },
  {
    "objectID": "03_01_Plotly图表绘制与可视化.html#plotly.graph_objects高级绘图模块",
    "href": "03_01_Plotly图表绘制与可视化.html#plotly.graph_objects高级绘图模块",
    "title": "4  Plotly 图表绘制与可视化",
    "section": "plotly.graph_objects高级绘图模块",
    "text": "plotly.graph_objects高级绘图模块\n当你导入plotly.graph_objects模块并使用别名go，你可以使用go来创建和定制Plotly图形对象。\n\n以下是plotly.graph_objects模块中go的主要内容和用法：\n\n1、创建图表对象：使用go.Figure()方法创建一个图表对象。这是创建几乎所有Plotly图表的起点。\n2、添加图表轨迹：使用go模块中的各种图表类型（例如Scatter、Bar、Pie等）创建图表轨迹（trace）。每个图表轨迹代表图表上的一组数据点或数据柱。\n3、图表布局和样式：使用update_layout()方法来设置图表的布局和样式，例如设置标题、轴标签、背景颜色等。\n4、图表交互性：Plotly允许你为图表添加交互性，例如鼠标悬停提示、缩放、平移等。可以使用update_traces()方法来设置图表轨迹的交互行为。\n5、绘制和显示图表：使用show()方法显示图表或使用write_image()方法将图表导出为图像文件。\n以下是融合了散点图和柱状图的示例代码：\n\nimport plotly.graph_objects as go\n\n\n\n# 创建一个图表对象\nfig = go.Figure()\n\n# 添加散点图轨迹\nfig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[10, 11, 12, 13], mode='markers', name='散点图'))\n\n# 添加柱状图轨迹\nfig.add_trace(go.Bar(x=[1, 2, 3, 4], y=[5, 6, 7, 8], name='柱状图'))\n\n# 设置图表布局和样式\nfig.update_layout(title='示例图表', xaxis_title='X轴', yaxis_title='Y轴')\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\nplotly.graph_objects模块提供了丰富的图表类型和配置选项，让你能够灵活地创建和定制各种类型的图表，满足你的数据可视化需求。可以查阅Plotly官方文档获取更多关于go模块的详细信息和用法。\n\n.add_trace图表轨迹方法\n.add_trace是用于向Plotly图表对象中添加不同类型的图表轨迹（trace）的方法。每个图表轨迹代表图表上的一组数据点或数据柱。\n在Plotly中，你可以在同一个图表对象中添加多个图表轨迹，从而在同一个图表中展示多个不同类型的数据。这让你可以将多个数据集以不同的图表类型呈现在同一个图表中，方便进行数据比较和分析。\n.add_trace方法的基本语法如下：\nfig.add_trace(trace)\n其中，fig是go.Figure图表对象，trace是你要添加的图表轨迹。\n以下是.add_trace方法的具体用法和示例：\n添加散点图轨迹：\n\nimport plotly.graph_objects as go\n\n\n\n# 示例数据\nx = [1, 2, 3, 4]\ny = [10, 11, 12, 13]\n\n# 创建一个图表对象\nfig = go.Figure()\n\n# 添加散点图轨迹\nfig.add_trace(go.Scatter(x=x, y=y, mode='markers', name='散点图'))\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n添加折线图轨迹：\n\nimport plotly.graph_objects as go\n\n\n\n# 示例数据\nx = [1, 2, 3, 4]\ny = [10, 11, 12, 13]\n\n# 创建一个图表对象\nfig = go.Figure()\n\n# 添加折线图轨迹\nfig.add_trace(go.Scatter(x=x, y=y, mode='lines', name='折线图'))\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n#添加柱状图轨迹：\n\nimport plotly.graph_objects as go\n\n\n\n# 示例数据\nx = ['A', 'B', 'C', 'D']\ny = [10, 20, 15, 25]\n\n# 创建一个图表对象\nfig = go.Figure()\n\n# 添加柱状图轨迹\nfig.add_trace(go.Bar(x=x, y=y, name='柱状图'))\n\n# 显示图表\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n通过.add_trace方法，你可以在同一个图表对象中添加多个图表轨迹，实现数据的多重展示。这使得你可以更好地进行数据比较、分析和可视化。注意，每个图表轨迹可以有不同的样式和设置，使得图表的外观和表现更加灵活和丰富。\n\n\n表格可视化\n在Plotly中，使用go.Figure可以很方便地展示表格可视化。\n在这部分，我们使用go.Figure函数创建了一个图表对象table_figure，并将表格图形对象table_trace作为数据传入。\n准备数据并创建一个go.Table对象：\n\n# 示例数据\ndata = {\n    \"Name\": [\"John\", \"Emma\", \"Michael\", \"Sophia\"],\n    \"Age\": [28, 24, 22, 26],\n    \"City\": [\"New York\", \"San Francisco\", \"Los Angeles\", \"Chicago\"],\n}\n\n# 创建一个数据帧\ndf = pd.DataFrame(data)\n\n# 创建一个表格图形对象\ntable_trace = go.Table(\n    header=dict(values=list(df.columns)),  # 定义表头，将数据帧的列名作为表头的值\n    cells=dict(values=[df.Name, df.Age, df.City])  # 定义单元格内容，将数据帧的数据作为单元格的值\n)\n\n\n在这部分中，我们创建了一个示例数据字典data，其中包含了姓名（“Name”）、年龄（“Age”）和所在城市（“City”）的数据。接着，使用pandas的DataFrame函数将数据字典转换为数据帧df，这将创建一个表格结构，其中包含了姓名、年龄和所在城市这三列数据。然后，我们使用go.Table来创建一个表格图形对象。在go.Table中，我们传入了header和cells参数：\nheader用于定义表格的表头，我们将df.columns（即数据帧df的列名）作为表头的值。\ncells用于定义表格的单元格内容，我们将df.Name、df.Age和df.City作为单元格的值。这样，数据帧中的姓名、年龄和城市数据将分别显示在表格的三列中。\n创建go.Figure图表对象并添加表格轨迹：\n\n# 创建图表对象，并将表格轨迹添加到图表中\ntable_figure = go.Figure(data=[table_trace])\n\n在这部分，我们使用go.Figure函数创建了一个图表对象table_figure，并将表格图形对象table_trace作为数据传入。\n显示图表：\n\n# 显示图表\ntable_figure.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n更直接的把go.Table嵌套在go.Figure中的方法是：\n你可以直接将go.Table嵌套在go.Figure中来创建一个包含表格可视化的图表对象。这样的做法非常方便，特别是当你只需要展示一个简单的表格可视化时，直接在go.Figure中添加go.Table即可，无需另外创建一个图表轨迹。\n以下是直接将go.Table嵌套在go.Figure中的方法：\n\nimport plotly.graph_objects as go\nimport pandas as pd\n\n# 示例数据\ndata = {\n    \"Name\": [\"John\", \"Emma\", \"Michael\", \"Sophia\"],\n    \"Age\": [28, 24, 22, 26],\n    \"City\": [\"New York\", \"San Francisco\", \"Los Angeles\", \"Chicago\"],\n}\n\n# 创建一个数据帧\ndf = pd.DataFrame(data)\n\n# 创建一个表格图形对象\ntable_figure = go.Figure(data=[go.Table(\n    header=dict(values=list(df.columns)),  # 定义表头，将数据帧的列名作为表头的值\n    cells=dict(values=[df.Name, df.Age, df.City])   # 定义单元格内容，将数据帧的数据作为单元格的值\n)])\n\n# 显示图表\ntable_figure.show(renderer=\"notebook\")"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#表格",
    "href": "03_02_Plotly高阶图表.html#表格",
    "title": "5  Plotly高阶图表",
    "section": "表格",
    "text": "表格\n在 Plotly 中，可以使用 go.Figure(data) 来创建一个包含数据表格的图表。数据表格可以用于显示数据集的详细内容，包括表格中的文本和数值。\n\n一个简单的表格示例\n\nimport plotly.graph_objects as go\n\nfig = go.Figure(data=[go.Table(\n    header=dict(values=['数学', '英语'],\n                line_color='darkslategray',\n                fill_color='lightskyblue',\n                align='left'),\n    cells=dict(values=[[100, 90, 80, 90], # 第一列\n                       [95, 85, 75, 95]], # 第二列\n               line_color='darkslategray',\n               fill_color='lightcyan',\n               align='left'))\n])\n\nfig.update_layout(width=500, height=300)\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\n参数解释\n\nheader：用于设置表格的标题行。您可以使用 dict(values=header_values) 来设置标题行的内容。\ncells：用于设置表格的数据行。您可以使用 dict(values=data_values) 来设置数据行的内容。\nalign：用于设置表格内容的对齐方式。默认为 “left”。\ncolumnwidth：用于设置列的宽度。可以是一个整数、列表或字典。\nfill_color`：用于设置表格单元格的填充颜色。\nfont：用于设置表格文本的字体属性，如大小、颜色等。\nheader_align：用于设置标题行的对齐方式。\nline_color：用于设置表格边框的颜色。"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#旭日图",
    "href": "03_02_Plotly高阶图表.html#旭日图",
    "title": "5  Plotly高阶图表",
    "section": "旭日图",
    "text": "旭日图\n旭日图，也叫做Sunburst Charts，主要用来展示具有层级结构的数据，其中每个数据点都有一个父级和一个或多个子级。\n\n旭日图可以理解为是表示分层数据的多级饼图，在一个圆环中嵌套多个圆环，每个圆环代表一个层级的分类数据，离中心越近的圆环层级越高。\n旭日图能够同时表现数据的局部和整体的占比情况，以及数据层级之间的关系。相较于饼图，旭日图更适合展示层级多的比例数据关系，更适合呈现复杂的数据结构。\n旭日图通过环形结构，使得用户可以清楚地看到数据从大类到子类的层级关系，以及不同类别之间的相对比例。\n\n\n一个简单的旭日图示例\n\nimport plotly.express as px\n\n# 旭日图数据（层次结构数据）\nsunburst_data = {\n    'Region': ['Asia', 'Asia', 'Europe', 'Africa', 'North America', 'South America', 'North America'],\n    'Country': ['China', 'Japan', 'Germany', 'Nigeria', 'USA', 'Brazil', 'Mexico'],\n    'Population': [1439323776, 124520000, 83783942, 214028302, 331002651, 212559417, 129040000]\n}\ndf = pd.DataFrame(sunburst_data)\n# 绘制旭日图\nfig_sunburst = px.sunburst(df, path=['Region', 'Country'], \n                           values='Population', color='Region',\n                           title='Sunburst Plot'\n                           )\nfig_sunburst.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n参数介绍：\n\n不论绘制任何图像，第一个参数基本上为传递给绘图参数的数据，这里是数据框df。\npath : 层次结构的路径：洲Region-&gt;国Country。一个列名列表，在前面的列为更靠近圆环中心的大类。 从中心向外的层层圆环，从前往后的列名列表，都表示从高层级向子层级展开。\nvalues : 决定圆环中各部分占比的变量，这里是人口数Population。\ncolor : 表示这个变量中的所有不同取值用不同颜色来区分，这里不同洲地区的板块显示为不同的颜色。\n\n通过鼠标点击旭日图中不同的环块，可以展开或折叠不同层级的数据。"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#树状图",
    "href": "03_02_Plotly高阶图表.html#树状图",
    "title": "5  Plotly高阶图表",
    "section": "树状图",
    "text": "树状图\n树状图是一种展现层次结构的可视化图表，通过矩形的嵌套和面积大小来展示数据的层级关系。\n\n树状图主要用于展示层次结构数据，例如文件夹大小、组织架构、经济分布等。\n树状图可以帮助用户快速了解数据的组织结构，同时直观地比较不同层级之间的数据大小。\n\n\n一个简单的树状图示例\n\n# 树状图数据（层次结构数据）\n# 各个领域的商品销量\ntree_map_data = {\n    'Category': ['Electronics', 'Fashion', 'Fashion', 'Beauty', 'Toys'],\n    'Product': ['Laptop', 'Shirt', 'Pants', 'Lipstick', 'Action Figure'],\n    'Sales': [1200, 800, 600, 600, 300]\n}\ndf = pd.DataFrame(tree_map_data)\n# 绘制树状图\n# 参数可以参照旭日图\n# path表示层次结构路径，values为决定矩形大小的变量，color决定用不同颜色区分哪个层级。\nfig_tree_map = px.treemap(df, path=[px.Constant('Sale'), 'Category', 'Product'], \n                          values='Sales', color='Category', title='TreeMap Plot')\nfig_tree_map.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\ncolor参数\n当使用数值列来决定不同矩形的颜色时，可以设置color相关的参数：\n\ncolor_continuous_scale ：这个参数设置了颜色的渐变色标尺，’RdBu’表示红蓝双色渐变。\ncolor_continuous_midpoint ：这个参数用于设置颜色渐变的中点。将某个值作为颜色渐变的中点，可以使得图表的颜色更加平衡。\n\n\nimport numpy as np\nfig1_tree_map = px.treemap(df, path=[px.Constant('Sale'), 'Category', 'Product'], \n                           values='Sales', color='Sales', color_continuous_scale='RdBu',\n                           color_continuous_midpoint=np.average(df['Sales'])\n                           )\nfig1_tree_map.show(renderer=\"notebook\")\n\n\n                                                \n\n\n通过鼠标点击树状图中不同的矩形版块，可以展开或折叠不同层级的数据。"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#动画效果",
    "href": "03_02_Plotly高阶图表.html#动画效果",
    "title": "5  Plotly高阶图表",
    "section": "动画效果",
    "text": "动画效果\n通过图像连续变化来展示一系列动作或过程，就叫做动效，通常用来展示数据的可视化图表随时间变化的过程。\n\n绘图示例\n\nimport plotly.express as px\n# 内置数据集\ndf = px.data.gapminder()\n\n# 绘制加入动画效果的散点图，展示随时间变化的散点图走势\nfig = px.scatter(df, x=\"gdpPercap\", y=\"lifeExp\", \n                 animation_frame=\"year\", animation_group=\"country\",\n                 size=\"pop\", color=\"continent\", hover_name=\"country\",\n                 log_x=True, size_max=55, range_x=[100,100000], range_y=[25,90])\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\nGapminder数据集变量介绍\n\n用于展示全球人口、经济和健康状况的变化情况。\ncountry：国家名称。\ncontinent：所属洲。\nyear：年份。\nlifeExp：平均预期寿命。\npop：人口数量。\ngdpPercap：人均GDP。\n\n\n\n参数介绍\n\nhover_name ：鼠标悬停在散点上时显示的标签。\nlog_x ：控制 x 轴是否使用对数刻度。将其设置为True，则 x 轴使用对数刻度。 在对数刻度中，刻度值是指数增长的，例如刻度值为100、101、102、103\nsize_max ：设置散点的最大大小以避免散点过大。\nrange_x ：x 轴的取值范围。\nrange_y ：y 轴的取值范围。\nanimation_frame ：设置动画效果的关键字，此处为year表示散点图将以动画形式展示数据随时间的变化\nanimation_group ：确定动画效果的关键字，此处为country表示将展示各个国家的变化数据趋势。"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#交互式功能",
    "href": "03_02_Plotly高阶图表.html#交互式功能",
    "title": "5  Plotly高阶图表",
    "section": "交互式功能",
    "text": "交互式功能\n\n鼠标交互：\n鼠标悬停提示：Plotly 默认会在图表上显示数据点的数值信息。鼠标悬停在数据点上时，会显示该点的具体数值，包括 x 轴和 y 轴的值。这个功能在 Plotly 中是默认开启的，无需设置。\n缩放和平移：通过鼠标拖拽可以实现图表的缩放和平移。当鼠标指针放在图表上方时，会出现缩放和平移的图标，通过拖动可以改变图表的视图范围。\n\n\n工具栏操作：\n工具栏按钮：Plotly 默认会在图表的右上角显示一个工具栏，其中包含一系列按钮，例如缩放、平移、自动缩放、重置轴范围等。这些按钮可以用于调整图表的外观和交互方式。\n\n\n图例控制：\n图例样式：可以通过设置图例的样式来调整图例的外观，例如字体大小、背景颜色等。通过在 legend 参数中设置相应的属性来实现。\n图例位置：可以通过设置图表布局中的 legend 参数来控制图例的位置。例如，layout=dict(legend=dict(x=0, y=1)) 表示将图例放在图表的左上角。默认情况下，Plotly 会自动根据图表的内容和大小来选择最佳的图例位置。\nlegend常用参数：\n\nx 和 y ：设置图例的水平和垂直位置，取值范围为0到1，0表示图表的最左边或最下边，1表示图表的最右边或最上边。\nxanchor 和 yanchor ：设置图例的水平和垂直锚点，用于确定图例相对于设置的 x 和 y 位置的对齐方式。\nbgcolor ：设置图例的背景颜色。\nbordercolor 和 borderwidth ：设置图例的边框颜色和宽度。\ntraceorder ：设置图例中数据系列的显示顺序，可选值为 ‘normal’（默认）或 ‘reversed’。\nitemsizing ：设置图例中每个数据系列的尺寸，可选值为 ‘trace’（默认）或 ‘constant’。‘trace’ 表示图例中每个数据系列的尺寸与其在图表中的尺寸成比例，‘constant’ 表示图例中每个数据系列的尺寸保持不变。\n\n\nimport plotly.express as px\n\n# 内置数据集\ndf = px.data.gapminder()\n\n# 绘制加入动画效果的散点图，展示随时间变化的散点图走势\nfig = px.scatter(df, x=\"gdpPercap\", y=\"lifeExp\", \n                 animation_frame=\"year\", animation_group=\"country\",\n                 size=\"pop\", color=\"continent\", hover_name=\"country\",\n                 log_x=True, size_max=55, range_x=[100,100000], range_y=[25,90])\n# update_layout定制图表布局\n# legend参数设置图表的图例位置和样式\nfig.update_layout(\n    # x=1表示右，y=1表示上，图例显示在右上角，背景色为白色，边框黑色且宽度为1\n    legend=dict(x=1, y=1, bgcolor='white', bordercolor='black', borderwidth=1)\n)\n\n# 显示图表\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#滑块和dropdown选择器",
    "href": "03_02_Plotly高阶图表.html#滑块和dropdown选择器",
    "title": "5  Plotly高阶图表",
    "section": "滑块和dropdown选择器",
    "text": "滑块和dropdown选择器\n\nslider滑块\n\nimport plotly.express as px\n\ndf = px.data.gapminder()\nfig = px.scatter(df, x=\"gdpPercap\", y=\"lifeExp\", animation_frame=\"year\", animation_group=\"country\",\n           size=\"pop\", color=\"continent\", hover_name=\"country\",\n           log_x=True, size_max=55, range_x=[100,100000], range_y=[25,90])\n\nfig[\"layout\"].pop(\"updatemenus\") # 省去动画的播放按钮\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\nDropdown下拉菜单（仅作了解）\n\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# 示例数据\nyears = [2010, 2011, 2012, 2013, 2014]\nsales = [100, 150, 200, 180, 250]\nprice = [10, 12, 15, 18, 20]\n\n# 创建图表\nfig = go.Figure()\n\n# 添加销售额折线图，不可见\nfig.add_trace(go.Scatter(x=years, y=sales, mode='lines+markers', name='Sales', visible=True))\n\n# 添加价格折线图，默认可见\nfig.add_trace(go.Scatter(x=years, y=price, mode='lines+markers', name='Price', visible=False))\n\n# 设置布局\nfig.update_layout(title='Sales and Price over Time',\n                  xaxis_title='Year',\n                  yaxis_title='Value'\n                  )\n\n# 添加 Dropdown 组件\nfig.update_layout(\n    updatemenus=[\n        dict(\n            buttons=list([\n                dict(\n                    args=[{'visible': [True, False]}],\n                    label='Sales',\n                    method='update'\n                ),\n                dict(\n                    args=[{'visible': [False, True]}],\n                    label='Price',\n                    method='update'\n                )\n            ]),\n            direction='down',\n            showactive=True,\n            x=0.1,\n            xanchor='left',\n            y=1.1,\n            yanchor='top'\n        ),\n    ]\n)\n\n# 显示图表\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#数据的分组聚合-groupby和agg",
    "href": "03_02_Plotly高阶图表.html#数据的分组聚合-groupby和agg",
    "title": "5  Plotly高阶图表",
    "section": "数据的分组聚合: groupby()和agg()",
    "text": "数据的分组聚合: groupby()和agg()\n使用groupby()和agg()实现数据的分组聚合：\n\nimport plotly.express as px\nimport pandas as pd\n\n# 示例数据\ndata = {\n    'Category': ['A', 'B', 'A', 'B', 'A', 'B'],\n    'Value': [10, 15, 20, 25, 30, 35]\n}\ndf = pd.DataFrame(data)\n\n# 嵌套使用 groupby 和 agg 进行数据分组和聚合\ngrouped_data = df.groupby('Category').agg({'Value': 'mean'}).reset_index()\n\n# 使用 Plotly 绘制条形图\nfig = px.bar(grouped_data, x='Category', y='Value', title='Category Average')\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "03_02_Plotly高阶图表.html#数据转换-filtergroupbyaggregate",
    "href": "03_02_Plotly高阶图表.html#数据转换-filtergroupbyaggregate",
    "title": "5  Plotly高阶图表",
    "section": "数据转换: Filter/Groupby/Aggregate",
    "text": "数据转换: Filter/Groupby/Aggregate\nPlotly中有一种Transform可以对数据进行转换处理，通过transform可以实现对数据的筛选过滤filter、分组groupby、聚合aggregate操作。\n请查看下面的示例代码和图表。\n\nFilter\n\nimport plotly.io as pio\n\nstudent = ['Amy', 'Laura', 'Lisa', 'Amy', 'Laura', 'Lisa', 'Laura', 'Lisa', 'Amy']\nscore = [77, 88, 99, 87, 76, 65, 78, 89, 90]\n# 使用 dict() 定义一个散点图的数据字典列表 data。\n# data 中包含一个字典，其中定义了散点图的数据属性。\ndata = [dict(\n  type = 'scatter', \n  # 指定x轴和y轴\n  x = student, \n  y = score,\n  # mode 参数用于控制绘制散点图时标记的形状。\n  # markers:圆点。'lines':折线,'lines+markers':圆点+折线,'text'：显示文本标签。\n  mode = 'markers',\n  transforms = [dict(\n    type = 'filter',  # 'filter'表示筛选过滤，'groupby'表示分组，'aggregate'表示聚合\n    target = 'y',     # 数据转换filter的目标对象为y\n    operation = '&gt;',  # 过滤条件：&gt;\n    value = 80        # 过滤条件临界值：80\n  )]\n)]\n\nlayout = dict(\n    title = 'Scores &gt; 80'\n)\n\nfig_dict = dict(data=data, layout=layout)\n# validate=False表示无需验证数据，直接输出图像\npio.show(fig_dict, validate=False, renderer=\"notebook\")\n\n                                                \n\n\n\n\nGroupby\n\nimport plotly.io as pio\n\nstudent = ['Amy', 'Laura', 'Lisa', 'Amy', 'Laura', 'Lisa', 'Laura', 'Lisa', 'Amy']\nscore = [77, 88, 99, 87, 76, 65, 78, 89, 90]\n\ndata = [dict(\n  type = 'scatter', \n  x = student, \n  y = score,\n  mode = 'markers',\n  transforms = [dict(\n    type = 'groupby',  \n    groups = student,  # 以不同学生来分组\n    # styles: 样式列表，其中包含不同学生的样式设置，这里显示为特定的不同颜色\n    styles = [\n        dict(target = 'Amy', value = dict(marker = dict(color = 'blue'))),\n        dict(target = 'Laura', value = dict(marker = dict(color = 'red'))),\n        dict(target = 'Lisa', value = dict(marker = dict(color = 'black')))\n    ]\n  )]\n)]\n\nfig_dict = dict(data=data)\npio.show(fig_dict, validate=False, renderer=\"notebook\")\n\n                                                \n\n\n\n\nAggregate\n\ncount: 数量。\nsum: 总和。\navg: 平均值。\nmedian: 中位数。\nmode: 众数。\nrms: 均方根。\nstddev: 标准差。\nmin: 最小值。\nmax: 最大值。\nfirst: 第一个值。\nlast: 最后一个值。\n\n\nimport plotly.io as pio\n\nstudent = ['Amy', 'Laura', 'Lisa', 'Amy', 'Laura', 'Lisa', 'Laura', 'Lisa', 'Amy']\nscore = [77, 88, 99, 87, 76, 65, 78, 89, 90]\n\ndata = [dict(\n  type = 'scatter', \n  x = student, \n  y = score,\n  mode = 'markers',\n  transforms = [dict(\n    type = 'aggregate',\n    groups = student,\n    aggregations = [dict(\n        # 聚合的目标对象:y, 聚合结果：返回平均值。\n        target = 'y', func = 'avg', enabled = True),\n    ]\n  )]\n)]\n\nlayout = dict(\n    title = 'Average Score'\n)\nfig_dict = dict(data=data, layout=layout)\npio.show(fig_dict, validate=False, renderer=\"notebook\")"
  },
  {
    "objectID": "03_03_Plotly地图可视化.html#地图可视化概念",
    "href": "03_03_Plotly地图可视化.html#地图可视化概念",
    "title": "6  Plotly地图可视化",
    "section": "地图可视化概念",
    "text": "地图可视化概念\n地图可视化是数据可视化的一种重要形式，它将数据以地理位置为基础进行可视化展示。通过地图可视化，我们可以直观地看到数据在地理空间上的分布、趋势和关联关系，帮助我们更好地理解数据所在的空间背景和地理特征。\n使用 Plotly Express 和地图可视化，我们可以：\n\n绘制各种类型的地图图表，包括气泡图、散点地图、连线地图、热力图、区域地图等，展示不同类型的地理数据。\n添加交互功能，如鼠标悬停显示数据信息、缩放、拖动和动画效果，使图表更具交互性和可操作性。\n自定义图表样式和主题，使图表更符合项目需求和品牌风格。\n结合其他 Python 数据处理库，如 Pandas，进行数据准备和处理，从而更方便地生成可视化图表。\n\n更高阶的地图可视化，还能和其他图表一起组合成为数据大屏，搭配Dash做到类似以下的效果"
  },
  {
    "objectID": "03_03_Plotly地图可视化.html#地图数据结构",
    "href": "03_03_Plotly地图可视化.html#地图数据结构",
    "title": "6  Plotly地图可视化",
    "section": "地图数据结构",
    "text": "地图数据结构\n相较于其他数据，地理位置的数据结构略微有些不同，地图可视化通常需要使用经纬度坐标或地理编码来表示地理位置，以及其他与地理位置相关的属性数据。通常数据文件格式为.SHP或者.GeoJSON这类的矢量GIS文件格式。详细请看地理数据格式介绍\n常见的地图数据结构可以是以下两种：\n\n点数据结构：这种数据结构用于表示地图上的散点数据，每个数据点都有一个经纬度坐标和其他属性数据。每个数据点在地图上呈现为一个点，可以用来标记地理位置或展示某个属性值在地图上的分布。\n区域数据结构：这种数据结构用于表示地图上的区域数据，如国家、城市、行政区等，每个区域有一个地理边界和其他属性数据。区域数据可以用来绘制地图上的色块或边界，表示不同地区的属性值。\n\n\n# 创建点数据结构\n点数据结构 = {\n    'City': ['New York', 'Paris', 'Tokyo', 'Beijing', 'London'],\n    'Lat': [40.7128, 48.8566, 35.6895, 39.9042, 51.5074],\n    'Lon': [-74.0060, 2.3522, 139.6917, 116.4074, -0.1278],\n    'Population': [8398748, 2140526, 37393129, 21705000, 8982000]\n}\n\n\n# 创建区域数据结构\n区域数据结构 = {\n    'Country': ['United States', 'Canada', 'France', 'Japan', 'China'],\n    'Coordinates': [\n        [[-125, 50], [-65, 50], [-65, 25], [-125, 25]],     # 美国边界坐标\n        [[-140, 72], [-55, 72], [-55, 40], [-140, 40]],     # 加拿大边界坐标\n        [[-5, 52], [9, 52], [9, 42], [-5, 42]],             # 法国边界坐标\n        [[129, 45], [149, 45], [149, 25], [129, 25]],       # 日本边界坐标\n        [[73, 53], [135, 53], [135, 18], [73, 18]]          # 中国边界坐标\n    ]\n}"
  },
  {
    "objectID": "03_03_Plotly地图可视化.html#使用-plotly-express-绘制散点地图",
    "href": "03_03_Plotly地图可视化.html#使用-plotly-express-绘制散点地图",
    "title": "6  Plotly地图可视化",
    "section": "使用 Plotly Express 绘制散点地图",
    "text": "使用 Plotly Express 绘制散点地图\nPlotly Express 中，可以使用 px.scatter_geo 来绘制散点地图。px.scatter_geo()参数介绍 以及官方案例\n下面为官方给出的数据案例：所有官方数据集\n\n从plotly官方提供的示例数据集中提取gapminder，包含了世界各国在不同年份的一些经济指标，如国家/地区、年份、人口数量、GDP、预期寿命等信息。\n\n\n# 导入plotly.express库\nimport plotly.express as px\n\ndf = px.data.gapminder()\ndf \n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\niso_alpha\niso_num\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\nAFG\n4\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\nAFG\n4\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\nAFG\n4\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\nAFG\n4\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\nAFG\n4\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1699\nZimbabwe\nAfrica\n1987\n62.351\n9216418\n706.157306\nZWE\n716\n\n\n1700\nZimbabwe\nAfrica\n1992\n60.377\n10704340\n693.420786\nZWE\n716\n\n\n1701\nZimbabwe\nAfrica\n1997\n46.809\n11404948\n792.449960\nZWE\n716\n\n\n1702\nZimbabwe\nAfrica\n2002\n39.989\n11926563\n672.038623\nZWE\n716\n\n\n1703\nZimbabwe\nAfrica\n2007\n43.487\n12311143\n469.709298\nZWE\n716\n\n\n\n\n1704 rows × 8 columns\n\n\n\n\n因为散点图不适合制作时间序列相关数据，所以需要筛选年份为某一年，这里筛选为2007年的数据。\n\n\n# 筛选出年份等于2007年的数据。 df = px.data.gapminder().query(\"year == 2007\")\ndf = df[df[\"year\"] == 2007].head()\ndf\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\niso_alpha\niso_num\n\n\n\n\n11\nAfghanistan\nAsia\n2007\n43.828\n31889923\n974.580338\nAFG\n4\n\n\n23\nAlbania\nEurope\n2007\n76.423\n3600523\n5937.029526\nALB\n8\n\n\n35\nAlgeria\nAfrica\n2007\n72.301\n33333216\n6223.367465\nDZA\n12\n\n\n47\nAngola\nAfrica\n2007\n42.731\n12420476\n4797.231267\nAGO\n24\n\n\n59\nArgentina\nAmericas\n2007\n75.320\n40301927\n12779.379640\nARG\n32\n\n\n\n\n\n\n\n\n数据准备好后，使用px.scatter_geo绘图。通常设置变量为fig。\n\n主要参数介绍：\n\ndata_frame：要绘制的数据的DataFrame，也就是变量df，其中必须包含地理信息，如经度（lon）和纬度（lat）。\nlocations 表示地图上要标记的位置，可以是国家、城市或其他地理位置的标识。\nsize：指定散点的大小。可以是一个具体的大小值，也可以是与数据列关联的列名，用于根据数据的值自动调整散点大小。\n\n\n\n\n\n\n\nNote\n\n\n\nISO 2字母代码通常被称为 ISO Alpha-2 代码。它是一个国家/地区的两个大写字母的缩写，能够快速标识和表示该国家/地区。例如，中国的 ISO Alpha-2 代码是 “CN”，美国的代码是 “US”，英国的代码是 “GB” 等。\n\n\n\nfig = px.scatter_geo(data_frame=df, \n                     locations=\"iso_alpha\", # 指定地理位置的ISO 2字母国家/地区代码所在的列名，定位散点在地图上的位置。\n                     size=\"pop\", # 指定散点的大小所在的列名，根据人口数量调整散点的大小。\n                     )\nfig.show(renderer=\"notebook\") # 显示绘制的地理散点图。\n\n\n                                                \n\n\n\n绘制气泡地图\n气泡图是散点图的升级版，通常会在原有基础上增加了另一个数据维度，通常用散点的大小或颜色来表示该维度的数据。每个数据点仍用一个散点来表示其地理位置，但通过调整散点的大小或颜色，可以同时显示第二个数据维度的信息。例如地理位置与人口数量或销售额之间的关系。\n同样使用上面筛选过后的2007年的世界经济数据，展示各个国家的地理位置，并用不同颜色表示它们所属的大洲，通过数据点的大小表示国家的人口数量。官方案例\n主要参数介绍：\n\ncolor: 字符串或列名，用于给散点图的数据点着色。\nhover_name: 字符串或列名，表示当鼠标悬停在数据点上时，显示在悬停提示框中的文本。\nprojection: 字符串，表示地图投影的类型。\n\n\n\n\n\n\n\nNote\n\n\n\n通过设置 projection 参数，可以选择合适的地图投影方式，以满足不同地理数据可视化需求。可以尝试下不同方式。默认为equirectangular经纬度投影，其他projection请参考官方文档\n\n\n\nfig = px.scatter_geo(data_frame=df, \n                     locations=\"iso_alpha\", \n                     size=\"pop\", \n                     color=\"continent\", # \"continent\"表示每个国家所在的大洲，将用于给数据点按照所属大洲进行着色。\n                     hover_name=\"country\", # \"country\"表示每个数据点所对应的国家名称，将显示在悬停提示框中。\n                     projection=\"natural earth\") # \"natural earth\"表示使用自然地球投影，即将地球投影到二维平面上。可以进行上下左右拖拽\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "03_03_Plotly地图可视化.html#使用-plotly-express-绘制着色地图",
    "href": "03_03_Plotly地图可视化.html#使用-plotly-express-绘制着色地图",
    "title": "6  Plotly地图可视化",
    "section": "使用 Plotly Express 绘制着色地图",
    "text": "使用 Plotly Express 绘制着色地图\n着色地图(Choropleth map)是一种用颜色来表示不同地理区域数据值的地图类型。在 Choropleth map 中，地图的每个区域（例如国家、州、县等）都被着色，颜色的深浅表示该区域的数据值大小或密度。这种地图可以帮助我们直观地看出不同地区之间的数据差异或分布情况，从而更好地理解地理数据的特征。详情请看官方案例\n着色地图的主要数据结构\n需要两种主要输入方式：\n\n几何信息： 可以是一个提供的 GeoJSON 文件，其中每个特征都有一个 id 字段或属性中的一些识别值；或 plotly 内置的几何图形之一：美国各州和世界各国（见下文）\n按特征标识符索引的值列表： GeoJSON 数据会传入 geojson 参数，数据会传入 px.choropleth 的颜色参数，顺序与传入 location 参数的 ID 相同。\n\n\n\n\n\n\n\nNote\n\n\n\n请注意，geojson 属性也可以是 GeoJSON 文件的 URL，这在某些情况下可以加快地图渲染速度。\n\n\n\n读取地理数据\n这里我们加载一个 GeoJSON 文件，其中包含美国各县的几何信息，其中feature.id是FIPS 代码。\n\nfrom urllib.request import urlopen\nimport json\nwith urlopen('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json') as response:\n    counties = json.load(response)\n\ncounties[\"features\"][0]\n\n{'type': 'Feature',\n 'properties': {'GEO_ID': '0500000US01001',\n  'STATE': '01',\n  'COUNTY': '001',\n  'NAME': 'Autauga',\n  'LSAD': 'County',\n  'CENSUSAREA': 594.436},\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[-86.496774, 32.344437],\n    [-86.717897, 32.402814],\n    [-86.814912, 32.340803],\n    [-86.890581, 32.502974],\n    [-86.917595, 32.664169],\n    [-86.71339, 32.661732],\n    [-86.714219, 32.705694],\n    [-86.413116, 32.707386],\n    [-86.411172, 32.409937],\n    [-86.496774, 32.344437]]]},\n 'id': '01001'}\n\n\n这里我们按县 和 FIPS 代码索引，加载失业数据，注意上面的是json文件，这个是csv文件\n\nimport pandas as pd\ndf = pd.read_csv(\"https://raw.githubusercontent.com/plotly/datasets/master/fips-unemp-16.csv\",\n                   dtype={\"fips\": str})\ndf.head()\n\n\n\n\n\n\n\n\nfips\nunemp\n\n\n\n\n0\n01001\n5.3\n\n\n1\n01003\n5.4\n\n\n2\n01005\n8.6\n\n\n3\n01007\n6.6\n\n\n4\n01009\n5.5\n\n\n\n\n\n\n\n\n\n使用 GeoJSON 绘制着色地图\n注意 在本例中，我们将 layout.geo.scope 设置为 USA，以便自动配置地图，以适当的投影显示以美国为中心的数据。有关范围的更多信息，请参阅 Geo 地图配置文档。\n\n主要参数介绍\n\ngeojson: 这是一个包含地理区域边界信息的 GeoJSON 数据，用于在地图上绘制各个区域的形状。如果不指定该参数，Plotly Express 会自动下载所需的 GeoJSON 数据。\nlocations: 这是一个字符串，表示 DataFrame 中的列名，它与 geojson 中的区域标识符（例如 FIPS 码）进行匹配，以正确地将数据绘制到地图上的各个区域。\ncolor: 这是一个字符串，表示 DataFrame 中的列名，用于表示每个地理区域的颜色深浅。通常，它是一个连续数值型列，例如失业率或人口数量。\ncolor_continuous_scale: 这是一个字符串，表示用于表示颜色深浅的连续色标尺。你可以选择内置的颜色映射，例如 \"Viridis\"、\"Cividis\"、\"Plasma\" 等，也可以指定自定义的颜色映射。\nrange_color: 这是一个元组，表示颜色映射的取值范围。它用于将数据值映射为颜色深浅的范围。（可作颜色渐变地图）\nscope: 这是一个字符串，表示绘制的地理范围。常用的值包括 “world”（绘制全球地图）、“usa”（绘制美国地图）等。\nlabels: 这是一个字典，用于设置图例的标签。\ntitle: 这是一个字符串，表示图表的标题。\n\n\nimport plotly.express as px\n\nfig = px.choropleth(df, geojson=counties, # 包含各县边界信息的 GeoJSON 文件，用于绘制地图区域\n                        locations='fips', # 表示地图区域的唯一标识符，这里使用数据中的 'fips' 列\n                        color='unemp',    # 表示用于颜色填充的数值，这里使用数据中的 'unemp' 列\n                        color_continuous_scale=\"Viridis\", # 设置颜色范围\n                        range_color=(0, 12),              # 设置颜色范围\n                        scope=\"usa\",                      # 设置地图范围\n                        labels={'unemp':'失业率'},         # 设置标签\n                        title=\"美国失业率\"                  # 设置标题\n                          )\nfig.update_layout(margin={\"r\":50,\"t\":50,\"l\":50,\"b\":50})     # 修改整体布局，通过设置各个边缘的边距值为 0，将图表与绘图区域的边缘对齐，使图表填充整个绘图区域。\nfig.show(renderer='notebook')\n\n\n                                                \n\n\n\n\n\n绘制美国城市人口地图\nPlotly 支持两种不同类型的地图：\n地理地图: 是基于轮廓的地图。如果您的图层是使用px.scatter_geo,px.line_geo或px.choropleth函数创建的，或者以其他方式包含一个或多个类型go.Scattergeo或的trace_go.Choropleth，则layout.geo图层中的对象包含地图本身的配置信息。\nMapbox: 地图是基于图块的地图。如果您的图层是使用px.scatter_mapbox, px.line_mapbox,px.choropleth_mapbox或px.density_mapbox函数创建的，或者以其他方式包含一个或多个类型go.Scattermapbox, 或的trace_go.Choroplethmapbox，则图层中的go.Densitymapbox对象layout.mapbox包含地图本身的配置信息。Mapbox图层文档，使用Mapbox可以获得更加精细化的地图样式。 详情请看，Mapbox散点图\n\n# 读取美国城市人口数据\nimport pandas as pd\nus_cities = pd.read_csv(\"https://raw.githubusercontent.com/plotly/datasets/master/us-cities-top-1k.csv\")\nus_cities.head()\n\n\n\n\n\n\n\n\nCity\nState\nPopulation\nlat\nlon\n\n\n\n\n0\nMarysville\nWashington\n63269\n48.051764\n-122.177082\n\n\n1\nPerris\nCalifornia\n72326\n33.782519\n-117.228648\n\n\n2\nCleveland\nOhio\n390113\n41.499320\n-81.694361\n\n\n3\nWorcester\nMassachusetts\n182544\n42.262593\n-71.802293\n\n\n4\nColumbia\nSouth Carolina\n133358\n34.000710\n-81.034814\n\n\n\n\n\n\n\n\nfig = px.scatter_mapbox(us_cities, lat=\"lat\", lon=\"lon\", hover_name=\"City\", hover_data=[\"State\", \"Population\"],\n                        color_discrete_sequence=[\"fuchsia\"], zoom=3, height=300)\nfig.update_layout(\n    mapbox_style=\"white-bg\",\n    mapbox_layers=[\n        {\n            \"below\": 'traces',\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": \"United States Geological Survey\",\n            \"source\": [\n                \"https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}\"\n            ]\n        }\n      ])\nfig.update_layout(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\nfig.show(renderer='notebook')"
  },
  {
    "objectID": "03_03_Plotly地图可视化.html#使用-plotly-express-绘制热力地图",
    "href": "03_03_Plotly地图可视化.html#使用-plotly-express-绘制热力地图",
    "title": "6  Plotly地图可视化",
    "section": "使用 Plotly Express 绘制热力地图",
    "text": "使用 Plotly Express 绘制热力地图\n热力图（Heatmap）又称密度图，是一种二维数据可视化技术，通过使用颜色编码来展示数据矩阵中每个数据点的大小，从而直观地呈现数据的分布和模式。例如温度分布，可以展示不同地理位置的温度分布情况，通过色彩的变化直观显示不同地区的温度高低。或者城市规划，可以用于显示人流、交通流等信息，帮助优化城市交通和设施布局。亦或者金融分析，用于分析股票和证券市场的相关性，揭示不同股票之间的关联程度。\n给定一个带坐标的数据帧，并为每个点赋值，就可以用 plotly 在 Python 中创建动态空间热图。为此，可以使用 plotly express 中的 density_mapbox 函数。这种图表对于可视化不同类型的数据（如人口数据、电话信号数据、道路拥堵情况等）\n以下为地震热力地图，可以更直观地了解地震的发生地点和震级情况，帮助我们分析地震的分布和规律。\n\n读取地震数据\n\n\n# 读取地震数据\nimport pandas as pd\ndf = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv')\ndf.head()\n\n\n\n\n\n\n\n\nDate\nLatitude\nLongitude\nMagnitude\n\n\n\n\n0\n01/02/1965\n19.246\n145.616\n6.0\n\n\n1\n01/04/1965\n1.863\n127.352\n5.8\n\n\n2\n01/05/1965\n-20.579\n-173.972\n6.2\n\n\n3\n01/08/1965\n-59.076\n-23.557\n5.8\n\n\n4\n01/09/1965\n11.938\n126.427\n5.8\n\n\n\n\n\n\n\n\n主要参数介绍\n详细Mapbox style地图参数设置\n\nlat和lon：分别指定数据框中代表纬度和经度的列名。这些列将决定数据点在地图上的位置。\nz：代表颜色强度的数值列。密度地图将使用该列的数值来表示数据点的密度。\nradius：设置聚合的半径大小。较小的半径将显示更细致的细节，而较大的半径将显示更广泛的数据趋势。\ncenter：用于设置地图的中心位置，是一个字典，包含lat和lon两个键，分别对应中心点的纬度和经度。\nzoom：设置地图的缩放级别，用于调整地图的显示范围。\nmapbox_style：设置地图的样式，可以选择不同的预定义地图样式，如”open-street-map”、“carto-positron”等。\n\n\nimport plotly.express as px\nfig = px.density_mapbox(df, # 地震数据集（必需参数）\n                        lat='Latitude',  # 维度列（必需参数）\n                        lon='Longitude', # 经度列（必需参数）\n                        z='Magnitude',   # 地震值（必需参数）其颜色会根据数据值的大小而变化。\n                        radius=10,       # 调整地图上数据点的大小\n                        center=dict(lat=0, lon=90), # 表示地图的中心坐标。默认为dict(lat=0, lon=180)，表示地图的中心位于纬度0，经度18的位置。\n                        zoom=1, # 表示地图的缩放级别。默认为0，表示地图显示全球范围。\n                        mapbox_style=\"stamen-terrain\") # 表示地图的样式。默认为\"open-street-map\"，还可以选择\"stamen-terrain\"、\"carto-positron\"等不同的样式。\n                        \nfig.show(renderer='notebook')"
  },
  {
    "objectID": "03_03_Plotly地图可视化.html#下拉菜单仅作了解",
    "href": "03_03_Plotly地图可视化.html#下拉菜单仅作了解",
    "title": "6  Plotly地图可视化",
    "section": "下拉菜单（仅作了解）",
    "text": "下拉菜单（仅作了解）\n通过创建一个下拉菜单来更改不同变量之间的绘制值（例如，预期寿命、GDP、人口） 详细可见官方文档以及下述代码块中的注释\n\n读取数据 是哟哦那个gapminder数据，并指定为2007年。\n\n最后创建了一个字符串列表cols_dd，其中包含了三个绘制值的名称：Population、GDP per Capita和Life Expectancy。\n\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objs as go\nimport plotly.express as px\n\n# 读取数据\ndf = px.data.gapminder().query(\"year==2007\")\ndf = df.rename(columns=dict(pop=\"Population\",\n                            gdpPercap=\"GDP per Capita\",\n                            lifeExp=\"Life Expectancy\"))\ncols_dd = [\"Population\", \"GDP per Capita\", \"Life Expectancy\"]\n\n\n绘制地图和下拉菜单\n\n通过遍历cols_dd中的绘制值名称，分别创建钻取地图的绘制值对象和按钮对象，然后将按钮对象放入updatemenus列表中。最后，使用这些对象来创建go.Figure，实现在钻取地图中切换不同绘制值的功能。\n\n\n\n# 定义了一个visible数组，用于指示哪个绘制值在初始情况下可见。\nvisible = np.array(cols_dd)\n\n# 分别创建一个空列表traces和buttons，用于存储后续创建的绘制值对象和按钮对象。\ntraces = []\nbuttons = []\n\nfor value in cols_dd: # 遍历cols_dd列表中的每个绘制值。\n    traces.append(go.Choropleth( # 代表一个钻取地图\n       locations=df['iso_alpha'], # 空间坐标\n        z=df[value].astype(float), # 数据用彩色编码\n        colorbar_title=value,\n        visible= True if value==cols_dd[0] else False)) # 根据当前遍历到的绘制值是否为初始值（cols_dd[0]）来决定是否可见。\n\n# 创建一个按钮对象，用于切换可见性\n    buttons.append(dict(label=value, # 显示的文本\n                        method=\"update\", # 指定了按钮的行为\n                        args=[{\"visible\":list(visible==value)}, # 按钮点击后执行的操作，包括设置可见性和更改标题。\n                              {\"title\":f\"&lt;b&gt;{value}&lt;/b&gt;\"}]))\n\n# 创建一个包含按钮对象的updatemenus列表，用于实现下拉菜单。active参数指定了初始时激活的按钮索引。\nupdatemenus = [{\"active\":0,\n                \"buttons\":buttons,\n               }]  \n  \n\n# 创建一个go.Figure对象\nfig = go.Figure(data=traces,  # 指定了绘制值对象的列表traces\n                layout=dict(updatemenus=updatemenus)) # 指定了图表的布局，其中updatemenus用于添加下拉菜单\n\n# 将cols_dd列表中的第一个绘制值名称赋值给变量first_title\nfirst_title = cols_dd[0]\nfig.update_layout(title=f\"&lt;b&gt;{first_title}&lt;/b&gt;\",title_x=0.5) #  更新图表的布局，其中title参数设置图表标题，title_x参数设置标题在X轴方向上的位置。\nfig.show(renderer='notebook')"
  },
  {
    "objectID": "04_01_Pandas安装.html",
    "href": "04_01_Pandas安装.html",
    "title": "7  Pandas安装",
    "section": "",
    "text": "使用Anaconda安装\n对于没有经验的小白来说，直接上手用代码来安装各种包可能有点困难，而Anaconda作为一个发行平台，可以非常轻松的安装除了Pandas之外的各种Python包（IPython、NumPy、 Matplotlib等）\n可以直接在jupyter代码块中安装\n\n# 在jupyter代码块中使用\nconda install pandas\n\n\n\n\n\n使用PyPI中的 pip 安装\n\n# 在命令行（终端）中使用\npip install pandas\n\n\n使用pip show pandas检验是否安装成功\n\n\n\n\n\n\nTip\n\n\n\n一般来说这是python自带的安装方式，但有时候你的虚拟环境没有或者服务器里的需要更新，可以参考文档\n\n\n\n安装pip的步骤\n\n首先，确保您已经安装了Python。Pip是Python的包管理工具，它通常随着Python的安装一起提供。\n打开终端（命令提示符）。\n输入以下命令来检查是否已安装pip：\n\n\n# 命令行中输入\npip --version\n\n# 在jupyter中输入 \n%pip --version\n\n如果已经安装了pip，您将看到版本号信息。否则，将显示错误信息或没有任何输出。\n如果未安装pip，可以使用以下方法进行安装：\n\n\n\nLinux&MacOSWindows\n\n\n打开终端，运行以下命令来安装pip\n$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\npython get-pip.py\n\n\n使用Python自带的ensurepip模块来安装或升级pip。\nC:&gt; py -m ensurepip --upgrade"
  },
  {
    "objectID": "04_02_Pandas处理什么样的数据.html#表格数据",
    "href": "04_02_Pandas处理什么样的数据.html#表格数据",
    "title": "8  Pandas处理什么样的数据",
    "section": "表格数据",
    "text": "表格数据\nPandas最常用于处理表格数据，例如CSV文件、Excel文件、数据库查询结果等。你可以使用Pandas读取这些数据，并对其进行各种操作，如过滤、排序、合并、聚合、计算统计指标等。\n当使用Pandas处理表格数据时，你可以使用DataFrame这个主要的数据结构。DataFrame是一个二维的标记数组，类似于电子表格或SQL表。\n\n# 1. 导入pandas包\nimport pandas as pd\n\n# 2. 假设data数据\ndata = {\n  \"calories\": [420, 380, 390],\n  \"duration\": [50, 40, 45]\n}\n\n# 3. 假设df，然后调用pd(pandas包)，将数据转换为DataFrame格式\ndf = pd.DataFrame(data)\n\n# 4. 打印df\ndf\n\n\n\n\n\n\n\n\ncalories\nduration\n\n\n\n\n0\n420\n50\n\n\n1\n380\n40\n\n\n2\n390\n45"
  },
  {
    "objectID": "04_02_Pandas处理什么样的数据.html#时间序列数据",
    "href": "04_02_Pandas处理什么样的数据.html#时间序列数据",
    "title": "8  Pandas处理什么样的数据",
    "section": "时间序列数据",
    "text": "时间序列数据\nPandas提供了强大的时间序列功能，可以处理日期和时间相关的数据。你可以使用Pandas对时间序列数据进行重采样、滚动计算、时间窗口分析、时间序列绘图等操作。\n很多时候在处理带有时间性质的数据时，我们需要将数据转换为时间类型的数据，例如，在读取csv文件时，计算机不会自动识别日期，而是会统一将数值型数据以外的数据识别为字符串，所以需要运用pd.to_datetime()将数据转换为时间类型的数据。\n\nimport pandas as pd\ndf_date = pd.DataFrame({'date': ['2021-01-01', '2022-01-01']})\nprint(type(df_date['date'][1]))\ndf_date\n    \n\n&lt;class 'str'&gt;\n\n\n\n\n\n\n\n\n\ndate\n\n\n\n\n0\n2021-01-01\n\n\n1\n2022-01-01\n\n\n\n\n\n\n\n\n# 将date列转化为时间类型数据\ndf_date['date'] = pd.to_datetime(df_date['date'])\nprint(df_date['date'][1])\n\n2022-01-01 00:00:00\n\n\n如果不需要显示时间点的部分，可以使用dt.date提取日期部分。\n\n# 截取日期部分，去除时间部分00:00:00\ndf_date['date'] = df_date['date'].dt.date\nprint(df_date['date'][1])\ntype(df_date['date'][1])\n\n2022-01-01\n\n\ndatetime.date\n\n\n\nimport pandas as pd\n\ndate = pd.to_datetime(\"13th of June, 2023\")\n\ndate\n\nTimestamp('2023-06-13 00:00:00')\n\n\n可以使用DateTimeIndex和TimedeltaIndex来表示时间索引和时间间隔。\n\nimport pandas as pd\n# 创建一个包含日期范围的时间索引\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10', freq='D')\n\n# 创建一个DataFrame，并使用时间索引\ndata = pd.DataFrame({'Value': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]}, index=date_range)\n\n# 查看数据的前几行\ndata.head()\n\n\n\n\n\n\n\n\nValue\n\n\n\n\n2023-01-01\n10\n\n\n2023-01-02\n20\n\n\n2023-01-03\n30\n\n\n2023-01-04\n40\n\n\n2023-01-05\n50\n\n\n\n\n\n\n\n选取所需的时间序列数据，并进行计算\n\n# 通过日期索引获取某一天的数据\nday_data = data.loc['2023-01-05']\n\n# 通过日期范围索引获取一段时间内的数据\nrange_data = data.loc['2023-01-03':'2023-01-07']\n\n# 使用日期的年、月、日等属性进行切片\nyear_data = data[data.index.year == 2023]\nmonth_data = data[data.index.month == 1]\nday_data = data[data.index.day == 5]\n\n# 将数据按周进行重采样，计算每周的平均值\nweekly_data = data.resample('W').mean()\n\n# 将数据按月进行重采样，计算每月的总和\nmonthly_data = data.resample('M').sum()"
  },
  {
    "objectID": "04_02_Pandas处理什么样的数据.html#缺失数据处理",
    "href": "04_02_Pandas处理什么样的数据.html#缺失数据处理",
    "title": "8  Pandas处理什么样的数据",
    "section": "缺失数据处理",
    "text": "缺失数据处理\nPandas提供了灵活的方法来处理缺失数据。你可以使用Pandas来检测和处理缺失值，填充缺失数据，或者根据缺失值进行数据筛选和计算。\n\n# 创建带有缺失数据的DataFrame\ndata = pd.DataFrame({'A': [1, 2, None, 4, 5],\n                     'B': [None, 2, 3, None, 6],\n                     'C': [1, 2, 3, 4, 5]})\n\n检查并统计缺失值\n\n# 检测每个单元格是否为缺失值\nmissing_values = data.isnull()\n\n# 统计每列的缺失值数量\nmissing_counts = data.isnull().sum()\n\n# 统计整个DataFrame的缺失值数量\ntotal_missing_count = data.isnull().sum().sum()\n\n对缺失值进行操作\n\n# 删除包含缺失值的行\ndata_dropna = data.dropna()\n\n# 删除全部为缺失值的列\ndata_dropna_cols = data.dropna(axis=1, how='all')\n\n# 填充缺失值为指定的常数\ndata_fillna = data.fillna(0)\n\n# 使用缺失值前面的值进行前向填充\ndata_ffill = data.fillna(method='ffill')\n\n# 使用缺失值后面的值进行后向填充\ndata_bfill = data.fillna(method='bfill')"
  },
  {
    "objectID": "04_02_Pandas处理什么样的数据.html#数据清洗和转换",
    "href": "04_02_Pandas处理什么样的数据.html#数据清洗和转换",
    "title": "8  Pandas处理什么样的数据",
    "section": "数据清洗和转换",
    "text": "数据清洗和转换\nPandas可以用于数据清洗和转换的各种操作。你可以使用Pandas对数据进行重塑、合并、分组、变形等，以满足特定的分析需求。\n\n# 创建原始数据\ndata = pd.DataFrame({'Name': ['John', 'Emily', 'Michael', 'Emma'],\n                     'Age': [25, 30, 35, 28],\n                     'Gender': ['M', 'F', 'M', 'F'],\n                     'Salary': ['$5000', '$6000', '$4500', '$7000']})\n\n\n数据清洗\n清洗重复或者多余数据\n\n# 去除重复的行\ndata_cleaned = data.drop_duplicates()\n\n# 去除列中的空格\ndata_cleaned['Name'] = data_cleaned['Name'].str.strip()\n\n# 删除缺失值所在的行\ndata_cleaned = data_cleaned.dropna()\n\n\n\n数据转换\n将列表转换为序列（Series）\nseries = pd.Series(list)\n\nimport pandas as pd\n\n# 将列表转换为序列\nmy_list = [1, 2, 3, 4, 5]\nseries = pd.Series(my_list)\nseries\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n\n\n将序列（Series）转换为数据框（DataFrame）\ndataframe = series.to_frame()\n\n# 将序列转换为数据框\nseries = pd.Series([1, 2, 3, 4, 5])\ndataframe = series.to_frame()\ndataframe\n\n\n\n\n\n\n\n\n0\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n\n\n\n\n\n将数据框（DataFrame）转换为列表（list）\nmy_list = df.values.tolist()\n\n# 将数据框转换为列表\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\nmy_list = df.values.tolist()\nmy_list\n\n[[1, 4], [2, 5], [3, 6]]\n\n\n\n\n\n\n\n\nTip\n\n\n\n数据的清洗和转换是pandas最常使用的功能，之后我们会逐步拆解，进行详细说明"
  },
  {
    "objectID": "04_02_Pandas处理什么样的数据.html#数据可视化",
    "href": "04_02_Pandas处理什么样的数据.html#数据可视化",
    "title": "8  Pandas处理什么样的数据",
    "section": "数据可视化",
    "text": "数据可视化\nPandas集成了Matplotlib库，可以通过简单的接口生成各种统计图表和可视化图形，以便更好地理解和呈现数据。\n\n# 创建数据\ndata = pd.DataFrame({'Month': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],\n                     'Sales': [100, 150, 120, 200, 180, 250],\n                     'Expenses': [80, 90, 100, 85, 95, 110]})\n\n# 折线图\ndata.plot(x='Month', y='Sales', kind='line')\n\n&lt;Axes: xlabel='Month'&gt;\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n虽然pandas也可以画图，但是还是静态图形，之后我们会详细说明更加简洁和酷炫的可视化库 Plotly库"
  },
  {
    "objectID": "04_02_Pandas处理什么样的数据.html#数据建模和分析",
    "href": "04_02_Pandas处理什么样的数据.html#数据建模和分析",
    "title": "8  Pandas处理什么样的数据",
    "section": "数据建模和分析",
    "text": "数据建模和分析\nPandas还支持数据建模和分析的操作。你可以使用Pandas进行数据建模、特征工程、数据预处理等，然后将数据传递给机器学习库（如Scikit-learn）进行模型训练和预测。网上看到不错的数据预测案例"
  },
  {
    "objectID": "04_03_导入导出数据.html#导入数据",
    "href": "04_03_导入导出数据.html#导入数据",
    "title": "9  导入&导出数据",
    "section": "导入数据",
    "text": "导入数据\n\n导入本地数据\n\n读取CSV文件的步骤\n关于函数参数的详情可以查看官方文档参数介绍。\n\n点击链下载链接下载文件到本地\n\n获取数据data.csv下载地址，将csv文件下载到本地。通过把本地csv文件拖到JupyterLab的目录界面，可以将csv文件传到服务器。建议大家创建一个夏令营文件夹，方便对文件统一管理。\n关于Jupyter服务器上的文件路径，将鼠标移至目录上方/左边的文件夹图标，可以显示服务器本地的主目录:/home/jupyter-账号名称，在读取路径时可用~表示，在此目录下创建一个名为夏令营的文件夹，将数据文件data.csv上传到当前路径，读取文件时，只需执行指令df = pd.read_csv('~/夏令营/data.csv')即可。\n\n\n导入pandas包进行调用，import pandas as pd，这样在后续调用pandas库的函数时使用缩写就好。\n读取数据时赋给变量df，方便后续调用数据（也可以不设置变量直接使用）；pd是pandas包的缩写，使用read_csv()函数；单引号内为本地CSV文件路径。\ndf 执行变量\n\nTips：如果已经来到了文件所在路径，则可以直接使用pd.read_csv('data.csv')读取csv文件\n\n# 导入pandas包\nimport pandas as pd\n\n# 注意csv文件路径，读取CSV文件，默认分隔符为逗号\ndf = pd.read_csv('./example_data/data.csv') \n\n# 调用变量df\ndf\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n...\n...\n...\n...\n...\n\n\n164\n60\n105\n140\n290.8\n\n\n165\n60\n110\n145\n300.0\n\n\n166\n60\n115\n145\n310.2\n\n\n167\n75\n120\n150\n320.4\n\n\n168\n75\n125\n150\n330.4\n\n\n\n\n169 rows × 4 columns\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n此处直接使用df打印结果，是因为在pandas中默认使用DataFrame格式，相较于print()会更加清晰。\nDataFrame是Pandas中最常用的数据结构之一，它提供了一种二维表格的数据结构，类似于电子表格或关系型数据库中的数据表。DataFrame由行和列组成，每列可以包含不同的数据类型（例如整数、浮点数、字符串等）。\n路径中的.表示当前的工作目录，要查询当前的工作目录可以使用os模块中的getcwd()函数。\n\nimport os\nos.getcwd()\n\n\n\n遇到不熟悉的函数或者python库的时候，可以使用help()来查找相应文档，并且一般最下面会给一个例子\n\nhelp(pd.read_table)\n\n\n\n读取Excel文件, 官方文档参数介绍\n\n步骤同上，第一步先点击Financial_Sample.xlsx下载文件\n\n获取数据Financial_Sample.xlsx下载地址，将Excel文件下载到本地。\n\n导入pandas包进行调用；\n使用read_excel()函数；单引号内为本地Excel文件路径\ndf 执行变量\n\nTips：如果出现编码问题无法导入，可尝试将Excel文件，另存为为Utf-8格式，然后重新导入\n\n# 导入pandas包\nimport pandas as pd\n\n# 注意csv文件路径\ndf = pd.read_excel('./example_data/Financial Sample.xlsx') \n\n# 调用变量df，表格前五行\ndf.head()\n\n\n\n\n\n\n\n\nSegment\nCountry\nProduct\nDiscount Band\nUnits Sold\nManufacturing Price\nSale Price\nGross Sales\nDiscounts\nSales\nCOGS\nProfit\nDate\nMonth Number\nMonth Name\nYear\n\n\n\n\n0\nGovernment\nCanada\nCarretera\nNone\n1618.5\n3\n20\n32370.0\n0.0\n32370.0\n16185.0\n16185.0\n2014-01-01\n1\nJanuary\n2014\n\n\n1\nGovernment\nGermany\nCarretera\nNone\n1321.0\n3\n20\n26420.0\n0.0\n26420.0\n13210.0\n13210.0\n2014-01-01\n1\nJanuary\n2014\n\n\n2\nMidmarket\nFrance\nCarretera\nNone\n2178.0\n3\n15\n32670.0\n0.0\n32670.0\n21780.0\n10890.0\n2014-06-01\n6\nJune\n2014\n\n\n3\nMidmarket\nGermany\nCarretera\nNone\n888.0\n3\n15\n13320.0\n0.0\n13320.0\n8880.0\n4440.0\n2014-06-01\n6\nJune\n2014\n\n\n4\nMidmarket\nMexico\nCarretera\nNone\n2470.0\n3\n15\n37050.0\n0.0\n37050.0\n24700.0\n12350.0\n2014-06-01\n6\nJune\n2014\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n如果使用Jupyter，必须确保文件与当前工作目录在同一目录下，或者指定文件的绝对路径。绝对路径 vs 相对路径区别\n\n\n\n\n\n导入线上数据\n线上数据地址 https://www.w3schools.com/python/pandas/data.csv.txt\n\ndf = pd.read_csv('https://www.w3schools.com/python/pandas/data.csv.txt')\n\n# 打印前五个\ndf.head()\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n\n\n\n\n\n\n# 获取案例数据\nimport pandas as pd\ndf = pd.read_csv('https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/titanic.csv') \ndf.head()\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n\n\n\n\n参数介绍\n以下参数也适用于大部分pandas导入方式，也就是read_函数。\n\nfilepath_or_buffer：要读取的文件路径或文件对象。\nsep：字段分隔符，默认为逗号（,），可以使用其他字符或字符串作为分隔符。\nheader：指定作为列名的行号，默认为’infer’，表示使用文件中的第一行作为列名，可以设为None来表示没有列名。\nindex_col：指定作为索引列的列号或列名。\nusecols：要读取的列的列号或列名列表。\nnrows：读取制定行数\ndtype：指定列的数据类型。\nparse_dates：指定要解析为日期的列。\nskiprows：跳过指定的行数。\nna_values：指定用于表示缺失值的字符串列表。\nencoding：指定文件的编码方式。\n\n\nimport pandas as pd\n\n# 默认情况下\ndf1 = pd.read_csv('./example_data/data.csv')\ndf1.head()\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n\n\n\n\n\nheader：指定作为列名的行号，默认为’infer’，表示使用文件中的第一行作为列名，可以设为None来表示没有列名。\n\n# 指定第二行为列名\n\ndf1 = pd.read_csv('./example_data/data.csv', header = 1)\ndf1.head()\n\n\n\n\n\n\n\n\n60\n110\n130\n409.1\n\n\n\n\n0\n60\n117\n145\n479.0\n\n\n1\n60\n103\n135\n340.0\n\n\n2\n45\n109\n175\n282.4\n\n\n3\n45\n117\n148\n406.0\n\n\n4\n60\n102\n127\n300.0\n\n\n\n\n\n\n\nindex_col：指定作为索引列的列号或列名。比如index_col=\"Duration\"，或者第一列index_col=0\n\ndf2 = pd.read_csv('./example_data/data.csv', index_col=\"Duration\")\ndf2.head()\n\n\n\n\n\n\n\n\nPulse\nMaxpulse\nCalories\n\n\nDuration\n\n\n\n\n\n\n\n60\n110\n130\n409.1\n\n\n60\n117\n145\n479.0\n\n\n60\n103\n135\n340.0\n\n\n45\n109\n175\n282.4\n\n\n45\n117\n148\n406.0\n\n\n\n\n\n\n\nusecols：只读取指定的列数据\n\ndf3 = pd.read_csv('./example_data/data.csv', usecols=[\"Pulse\", \"Calories\"])\ndf3.head() \n\n\n\n\n\n\n\n\nPulse\nCalories\n\n\n\n\n0\n110\n409.1\n\n\n1\n117\n479.0\n\n\n2\n103\n340.0\n\n\n3\n109\n282.4\n\n\n4\n117\n406.0\n\n\n\n\n\n\n\nnrows：只读取指定行数的数据\n\ndf4 = pd.read_csv('./example_data/data.csv', nrows=10)\ndf4\n\n\n\n\n\n\n\n\nDuration\nPulse\nMaxpulse\nCalories\n\n\n\n\n0\n60\n110\n130\n409.1\n\n\n1\n60\n117\n145\n479.0\n\n\n2\n60\n103\n135\n340.0\n\n\n3\n45\n109\n175\n282.4\n\n\n4\n45\n117\n148\n406.0\n\n\n5\n60\n102\n127\n300.0\n\n\n6\n60\n110\n136\n374.0\n\n\n7\n45\n104\n134\n253.3\n\n\n8\n30\n109\n133\n195.1\n\n\n9\n60\n98\n124\n269.0\n\n\n\n\n\n\n\nencoding：指定文件的编码方式。使用utf-8编码是因为它是一种广泛支持的字符编码，能够处理几乎所有的文本数据。出现编码问题用这个大概率就对了～\n\ndf5 = pd.read_csv('./example_data/data.csv', encoding='utf-8',index_col=0)\ndf5.head()\n\n\n\n\n\n\n\n\nPulse\nMaxpulse\nCalories\n\n\nDuration\n\n\n\n\n\n\n\n60\n110\n130\n409.1\n\n\n60\n117\n145\n479.0\n\n\n60\n103\n135\n340.0\n\n\n45\n109\n175\n282.4\n\n\n45\n117\n148\n406.0\n\n\n\n\n\n\n\n\n\n常见错误\n\n错误：FileNotFoundError: [Errno 2] No such file or directory: ‘data.csv’\n解决方法：检查文件路径和文件名是否正确，并确保文件存在于指定位置。\n错误：ParserError: Error tokenizing data. C error: Expected N fields in line M, saw K\n解决方法：确保文件中的数据与指定的分隔符一致，并且每行数据的字段数目相同。\n错误：UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xff in position 0: invalid start byte\n解决方法：尝试指定正确的文件编码，如encoding=’utf-8-sig’来处理带有BOM（字节顺序标记）的文件。"
  },
  {
    "objectID": "04_03_导入导出数据.html#导出数据",
    "href": "04_03_导入导出数据.html#导出数据",
    "title": "9  导入&导出数据",
    "section": "导出数据",
    "text": "导出数据\n\n导出CSV文件\n在 pandas 中，可以使用 to_csv()方法将数据导出为文本格式（如 CSV 文件）。to_csv() 方法接受一个参数，即导出的文件路径，可以是相对路径或绝对路径\n一般我们的导出对象是 DataFrame 数据框和 Series 序列，将这些数据结构中的数据保存到一个 CSV 文件中。就算是字典或者Numpy的数据结构，也可以转换为DataFrame后进行导出。\n\n创建名为data的字典，作为示例数据；\n调用pandas，将字典转换为DataFrame格式；\n使用to_csv，导出并保存为csv文件，同时命名文件为 output.csv\nindex=False 参数表示输出的csv文件中不包含行索引。\n\n\nimport pandas as pd\n\n# 创建 DataFrame 示例数据\ndata = {'Name': ['Jack', 'Luxue', 'Wenxi'],\n        'Age': [25, 30, 35],\n        'City': ['New York', 'London', 'Paris']}\n\ndf = pd.DataFrame(data)\n\n# 导出为 CSV 文件，默认为当前路径\ndf.to_csv('output.csv', index=False)\n\nSeries 导出：Series 序列 是 pandas 中的另一个常见数据结构，它是一维标记数组。可以使用 to_csv()、to_excel() 等方法将 Series 导出为 CSV、Excel 等格式。\n\n# 创建 Series 示例数据\ndata = pd.Series([1, 2, 3, 4, 5])\n\n# 导出为 CSV 文件\ndata.to_csv('output.csv', index=False)\n\n# 导出为 Excel 文件\ndata.to_excel('output.xlsx', index=False)\n\n\n\n导出Excel文件\n当涉及到导出为 Excel 文件时，让我们考虑一个简单的案例。假设我们有一个包含学生考试成绩的 DataFrame，我们希望将其导出为一个名为 grades.xlsx 的 Excel 文件。\n\n\n\n\n\n\nWarning\n\n\n\n使用to_excel()时可能会出现报错ModuleNotFoundError: No module named 'openpyxl'，这意味着你的系统中没有安装 openpyxl 模块。\n\n\nopenpyxl 是一个用于处理Excel文件的第三方库，它在Pandas中用于导出Excel文件。为了解决这个错误，你需要安装 openpyxl 模块。\n你可以使用以下命令使用 pip 安装 openpyxl 模块：\n\n%pip install openpyxl\n\n\nimport pandas as pd\n\n# 创建一个示例的 DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie'],\n        'Math': [85, 92, 78],\n        'English': [90, 88, 95],\n        'Science': [80, 85, 92]}\n\ndf = pd.DataFrame(data)\n\n# 使用 to_excel() 方法将 DataFrame 导出为 Excel 文件\ndf.to_excel('grades.xlsx', index=False)\n\n\n\n参数介绍\n\nsheet_name：指定要导出到的工作表名称，默认为 ‘Sheet1’。\nna_rep：指定缺失值的表示，默认为空字符串。\ncolumns：指定要导出的列名。可以传入一个列表来指定特定的列，或者使用布尔索引来选择要导出的列。\nheader：指定是否将列名包含在导出的文件中，默认为 True。\nindex：指定是否将行索引包含在导出的文件中，默认为 True。\nindex_label：指定行索引的标签名称，默认为 None。\nstartrow 和 startcol：指定数据在工作表中的起始行和起始列，默认从第一行第一列开始。\n\nsheet_name如果我们想将数据保存在特定的工作表中，可以使用 sheet_name 参数指定工作表的名称\n\ndf.to_excel('grades.xlsx', sheet_name='Exam Scores', index=False)\n\ncolumns 如果我们只想导出特定的列，可以使用 columns 参数来指定要导出的列名，比如只导出 “Name”、“Math” 和 “English” 列的数据。\n\ndf.to_excel('grades.xlsx', columns=['Name', 'Math', 'English'], index=False)"
  },
  {
    "objectID": "04_03_导入导出数据.html#项目数据",
    "href": "04_03_导入导出数据.html#项目数据",
    "title": "9  导入&导出数据",
    "section": "项目数据",
    "text": "项目数据\n这周的项目数据已经存放在共享文件夹中：数据存放的路径为/srv/data/COVID-19/\n读取文件的路径：\n确诊数据：'/srv/data/COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv'\n死亡数据：'/srv/data/COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv'\n治愈数据：'/srv/data/COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv'"
  },
  {
    "objectID": "04_03_导入导出数据.html#连接mysql数据库导入导出数据拓展",
    "href": "04_03_导入导出数据.html#连接mysql数据库导入导出数据拓展",
    "title": "9  导入&导出数据",
    "section": "连接MySQL数据库导入导出数据（拓展）",
    "text": "连接MySQL数据库导入导出数据（拓展）\n\n步骤1：安装必要的库\n在开始之前，确保已经安装了以下库：\nPandas：用于数据处理和操作。\nSQLAlchemy：用于数据库连接和交互\n可以使用以下命令通过pip安装它们：\n\npip install pandas sqlalchemy\n\n\n\n步骤2：链接数据库\n首先，我们需要使用SQLAlchemy来建立与数据库的连接。根据使用的数据库类型（如MySQL、SQLite、PostgreSQL等），使用适当的连接字符串和数据库驱动程序。\n以下是使用SQLite数据库的示例代码：\n\nimport sqlalchemy\n\n# 建立与数据库的连接\nengine = sqlalchemy.create_engine('sqlite:///path/to/database.db')\n\n\n\n\n\n\n\nTip\n\n\n\n将path/to/database.db替换为实际的数据库文件路径或连接字符串\n\n\n\n\n步骤3：导入数据\n有几种方法可以使用Pandas从数据库中导入数据。最简单的方法是使用read_sql()函数，该函数接受一个SQL查询语句并将结果读取为DataFrame对象。\n以下是使用read_sql()函数导入数据的示例代码：\n\nimport pandas as pd\n\n# 执行SQL查询并将结果读取为DataFrame\nquery = 'SELECT * FROM table_name'\ndf = pd.read_sql(query, engine)\n\n# 打印DataFrame\nprint(df)\n\n\n\n\n\n\n\nTip\n\n\n\n将table_name替换为要查询的实际表名。\n\n\n\n\n步骤4：导出数据\n同样，使用Pandas可以将DataFrame中的数据导出到数据库中。可以使用to_sql()函数将DataFrame写入数据库表。\n以下是使用to_sql()函数导出数据的示例代码\n\n# 将DataFrame写入数据库表\ndf.to_sql('table_name', engine, if_exists='replace', index=False)\n\n\n\n\n\n\n\nTip\n\n\n\n将table_name替换为要写入的实际表名。if_exists=’replace’表示如果表已经存在，则替换它。index=False表示不将DataFrame的索引写入数据库。"
  },
  {
    "objectID": "04_04_选取数据.html#筛选行数据",
    "href": "04_04_选取数据.html#筛选行数据",
    "title": "10  选取数据",
    "section": "筛选行数据",
    "text": "筛选行数据\n可以通过行索引获取行数据，冒号指定范围，一般的模式是，起始索引:结束索引，结束索引不含在内，开始索引为0或结束索引为行数时可省略数字。和NumPy的切片用法一样。\n\n# 选取前3行数据，行索引取0、1、2，结束索引3是取不到的。 \ndf[:3]  # 等价于df[0:3]  \n# 选取第5行(索引4)到第8行(索引7) \ndf[4:8] \n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n5\n6\n0\n3\nMoran, Mr. James\nmale\nNaN\n0\n0\n330877\n8.4583\nNaN\nQ\n\n\n6\n7\n0\n1\nMcCarthy, Mr. Timothy J\nmale\n54.0\n0\n0\n17463\n51.8625\nE46\nS\n\n\n7\n8\n0\n3\nPalsson, Master. Gosta Leonard\nmale\n2.0\n3\n1\n349909\n21.0750\nNaN\nS\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n注意在dataframe中索引0所表示的行才是第一行，所以切片的索引比行数小一个数。\n\n\n\niloc方法基于行索引筛选行\niloc方法是按行索引位置选取数据，可以引用索引列表([index1, index2, ...])或者索引区间(start_index:stop_index)。\n\ndf.iloc[:4]\n# 等价于df.iloc[:4, :]，选取行数据时可以不选取列，一个冒号表示取全部\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n\n\n\n\n\n\n\nloc方法基于行标签筛选行\nloc方法是按行标签选取数据，因为这里没有设置行标签，所以这里行标签默认等于位置索引。\n\ndf.loc[[1, 4]]\n# 等价于df.loc[[1, 4], :]\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n\n\n\n除了列表形式，还可以用区间形式如a:b，引用连续的行标签。\n\ndf.loc[:4]\n# 等价于df.loc[0:4, :]\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n注意使用loc方法是可以取到结束行的。\n\n\n\ndf_summary = df.describe()\ndf_summary.loc[\"count\":\"mean\"]\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nAge\nSibSp\nParch\nFare\n\n\n\n\ncount\n891.0\n891.000000\n891.000000\n714.000000\n891.000000\n891.000000\n891.000000\n\n\nmean\n446.0\n0.383838\n2.308642\n29.699118\n0.523008\n0.381594\n32.204208"
  },
  {
    "objectID": "04_04_选取数据.html#选取列数据",
    "href": "04_04_选取数据.html#选取列数据",
    "title": "10  选取数据",
    "section": "选取列数据",
    "text": "选取列数据\n通过列索引或列名可以获取DataFrame的单列数据或多列数据。\n假如我想知道每位乘客的姓名（选取单列），df为数据表格，Name为列名。\n\n引用列名提取单列\n\ndf['Name']\ndf.Name\n\n0                                Braund, Mr. Owen Harris\n1      Cumings, Mrs. John Bradley (Florence Briggs Th...\n2                                 Heikkinen, Miss. Laina\n3           Futrelle, Mrs. Jacques Heath (Lily May Peel)\n4                               Allen, Mr. William Henry\n                             ...                        \n886                                Montvila, Rev. Juozas\n887                         Graham, Miss. Margaret Edith\n888             Johnston, Miss. Catherine Helen \"Carrie\"\n889                                Behr, Mr. Karl Howell\n890                                  Dooley, Mr. Patrick\nName: Name, Length: 891, dtype: object\n\n\n\n\nloc和iloc方法提取单列\n\n# 使用.loc或.iloc取列: 逗号前筛选行,逗号后面筛选列\n# 行数取全部时只用一个冒号就可以，列取Name列：\ndf.loc[:, 'Name']\n# # 使用.iloc根据列索引来提取第4列(索引3)\ndf.iloc[:, 3]\n\n0                                Braund, Mr. Owen Harris\n1      Cumings, Mrs. John Bradley (Florence Briggs Th...\n2                                 Heikkinen, Miss. Laina\n3           Futrelle, Mrs. Jacques Heath (Lily May Peel)\n4                               Allen, Mr. William Henry\n                             ...                        \n886                                Montvila, Rev. Juozas\n887                         Graham, Miss. Margaret Edith\n888             Johnston, Miss. Catherine Helen \"Carrie\"\n889                                Behr, Mr. Karl Howell\n890                                  Dooley, Mr. Patrick\nName: Name, Length: 891, dtype: object\n\n\n\n\n提取多列数据\n如果需要获取多列，比如所有乘客的幸存情况（Name、Survived），我们再添加一对中括号把所有的列括起来以获取多个列的数据，数据子集依旧为数据框dataframe。\n下面的代码示例用.head()显示前5行。\n\n# 方法一：\ndf[['Name','Survived']]\n\n# 方法二：\n# df.loc[:, ['column_name1', 'column_name2', ...]]\ndf.loc[:, ['Name','Survived']]\n\n# df.iloc[:, [column_index1, column_index2]]\ndf.iloc[:, [3, 1]].head()\n\n\n\n\n\n\n\n\nName\nSurvived\n\n\n\n\n0\nBraund, Mr. Owen Harris\n0\n\n\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\n1\n\n\n2\nHeikkinen, Miss. Laina\n1\n\n\n3\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\n1\n\n\n4\nAllen, Mr. William Henry\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n内部方括号定义了一个带有列名或列索引的Python列表，而外部方括号用于从 dataframe 中筛选数据。\n筛选行的时候可以不提取列，但取列的时候必须用”:, “来选取行，单个冒号表示取全部行。\n\n\n\n除了列表形式，还可以用列标签区间提取连续的列，比如提取乘客的基本信息(Name、Sex、Age)：\n\n# 用区间提取连续的多个列\ndf.loc[:, \"Name\":\"Age\"].head() \n\n\n\n\n\n\n\n\nName\nSex\nAge\n\n\n\n\n0\nBraund, Mr. Owen Harris\nmale\n22.0\n\n\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n\n\n2\nHeikkinen, Miss. Laina\nfemale\n26.0\n\n\n3\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n\n\n4\nAllen, Mr. William Henry\nmale\n35.0\n\n\n\n\n\n\n\n\n\n\n根据条件筛选行数据\n提取十八岁以下的乘客信息:\n\ndf[df[\"Age\"] &lt; 18].head()\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n7\n8\n0\n3\nPalsson, Master. Gosta Leonard\nmale\n2.0\n3\n1\n349909\n21.0750\nNaN\nS\n\n\n9\n10\n1\n2\nNasser, Mrs. Nicholas (Adele Achem)\nfemale\n14.0\n1\n0\n237736\n30.0708\nNaN\nC\n\n\n10\n11\n1\n3\nSandstrom, Miss. Marguerite Rut\nfemale\n4.0\n1\n1\nPP 9549\n16.7000\nG6\nS\n\n\n14\n15\n0\n3\nVestrom, Miss. Hulda Amanda Adolfina\nfemale\n14.0\n0\n0\n350406\n7.8542\nNaN\nS\n\n\n16\n17\n0\n3\nRice, Master. Eugene\nmale\n2.0\n4\n1\n382652\n29.1250\nNaN\nQ\n\n\n\n\n\n\n\n\n\n根据多个条件筛选行数据\n多个条件之间用&或|相连：df[(条件1) & (条件2)] 提取成年(age&gt;=18)男性乘客信息:\n\ncondition = (df.Age &gt;= 18) & (df.Sex == \"male\")\ndf[condition] # 等价于 df[(df[\"Age\"] &gt;= 18) & (df[\"Sex\"] == \"male\")]\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n6\n7\n0\n1\nMcCarthy, Mr. Timothy J\nmale\n54.0\n0\n0\n17463\n51.8625\nE46\nS\n\n\n12\n13\n0\n3\nSaundercock, Mr. William Henry\nmale\n20.0\n0\n0\nA/5. 2151\n8.0500\nNaN\nS\n\n\n13\n14\n0\n3\nAndersson, Mr. Anders Johan\nmale\n39.0\n1\n5\n347082\n31.2750\nNaN\nS\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n883\n884\n0\n2\nBanfield, Mr. Frederick James\nmale\n28.0\n0\n0\nC.A./SOTON 34068\n10.5000\nNaN\nS\n\n\n884\n885\n0\n3\nSutehall, Mr. Henry Jr\nmale\n25.0\n0\n0\nSOTON/OQ 392076\n7.0500\nNaN\nS\n\n\n886\n887\n0\n2\nMontvila, Rev. Juozas\nmale\n27.0\n0\n0\n211536\n13.0000\nNaN\nS\n\n\n889\n890\n1\n1\nBehr, Mr. Karl Howell\nmale\n26.0\n0\n0\n111369\n30.0000\nC148\nC\n\n\n890\n891\n0\n3\nDooley, Mr. Patrick\nmale\n32.0\n0\n0\n370376\n7.7500\nNaN\nQ\n\n\n\n\n395 rows × 12 columns\n\n\n\n在条件前加上~表示取反，即提取除了成年男性以外的乘客信息：\n\ndf[~condition]\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n5\n6\n0\n3\nMoran, Mr. James\nmale\nNaN\n0\n0\n330877\n8.4583\nNaN\nQ\n\n\n7\n8\n0\n3\nPalsson, Master. Gosta Leonard\nmale\n2.0\n3\n1\n349909\n21.0750\nNaN\nS\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n880\n881\n1\n2\nShelley, Mrs. William (Imanita Parrish Hall)\nfemale\n25.0\n0\n1\n230433\n26.0000\nNaN\nS\n\n\n882\n883\n0\n3\nDahlberg, Miss. Gerda Ulrika\nfemale\n22.0\n0\n0\n7552\n10.5167\nNaN\nS\n\n\n885\n886\n0\n3\nRice, Mrs. William (Margaret Norton)\nfemale\n39.0\n0\n5\n382652\n29.1250\nNaN\nQ\n\n\n887\n888\n1\n1\nGraham, Miss. Margaret Edith\nfemale\n19.0\n0\n0\n112053\n30.0000\nB42\nS\n\n\n888\n889\n0\n3\nJohnston, Miss. Catherine Helen \"Carrie\"\nfemale\nNaN\n1\n2\nW./C. 6607\n23.4500\nNaN\nS\n\n\n\n\n496 rows × 12 columns\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n多个条件之间进行连接时，只能用&表示和，用|表示或，不能用and或or。\n\n\n在条件中可以结合isna()和notna()来提取或删除缺失值所在的行：\n\ndf = df[df['Age'].notna()]\ndf\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n885\n886\n0\n3\nRice, Mrs. William (Margaret Norton)\nfemale\n39.0\n0\n5\n382652\n29.1250\nNaN\nQ\n\n\n886\n887\n0\n2\nMontvila, Rev. Juozas\nmale\n27.0\n0\n0\n211536\n13.0000\nNaN\nS\n\n\n887\n888\n1\n1\nGraham, Miss. Margaret Edith\nfemale\n19.0\n0\n0\n112053\n30.0000\nB42\nS\n\n\n889\n890\n1\n1\nBehr, Mr. Karl Howell\nmale\n26.0\n0\n0\n111369\n30.0000\nC148\nC\n\n\n890\n891\n0\n3\nDooley, Mr. Patrick\nmale\n32.0\n0\n0\n370376\n7.7500\nNaN\nQ\n\n\n\n\n714 rows × 12 columns\n\n\n\nDataFrames 可以通过多种方式进行过滤，其中最直观的是使用布尔索引。\n\n\n\n\n\n\nTip\n\n\n\n这些对原始数据进行筛选和提取的操作并不会改变原数据df，如果需要保存数据子集，需要赋值给新的数据变量。"
  },
  {
    "objectID": "04_05_数据的增加、删除、修改.html#添加新列",
    "href": "04_05_数据的增加、删除、修改.html#添加新列",
    "title": "11  数据的增加、删除、修改",
    "section": "添加新列",
    "text": "添加新列\n目前的案例数据是5行三列，添加新的一列，有两种方法：\n\n直接对数据框df添加列\n\nimport numpy as np\ndf['薪资'] = [5000, 6000, 9000, 7000, np.nan]  # 缺失值可以用一对不包含任何内容的引号代替\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n薪资\n\n\n\n\n0\n张三\n25\nM\n5000.0\n\n\n1\n李四\n30\nF\n6000.0\n\n\n2\n王五\n35\nM\n9000.0\n\n\n3\n赵钱\n28\nF\n7000.0\n\n\n4\n孙李\n22\nM\nNaN\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n[值]必须对应行数，这里有四个人就必须有四个值，没有则可以为空白'' 或者 NaN；[]里面的值的顺序也需要和原数据框保持一致。\n\n\n\n\n使用assign()添加列\nassign()不会直接改变原数据框df，需要用新数据框覆盖原数据框的数据。\n\ndf = df.assign(工龄=[1, 1, 3, 2, 0.5])\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n薪资\n工龄\n\n\n\n\n0\n张三\n25\nM\n5000.0\n1.0\n\n\n1\n李四\n30\nF\n6000.0\n1.0\n\n\n2\n王五\n35\nM\n9000.0\n3.0\n\n\n3\n赵钱\n28\nF\n7000.0\n2.0\n\n\n4\n孙李\n22\nM\nNaN\n0.5\n\n\n\n\n\n\n\n\n\n基于已有数据添加列\n\n# 一个例子，假设薪资不变\ndf['年薪'] = df['薪资']*12\ndf['总薪资'] = df['年薪']*df['工龄']\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n薪资\n工龄\n年薪\n总薪资\n\n\n\n\n0\n张三\n25\nM\n5000.0\n1.0\n60000.0\n60000.0\n\n\n1\n李四\n30\nF\n6000.0\n1.0\n72000.0\n72000.0\n\n\n2\n王五\n35\nM\n9000.0\n3.0\n108000.0\n324000.0\n\n\n3\n赵钱\n28\nF\n7000.0\n2.0\n84000.0\n168000.0\n\n\n4\n孙李\n22\nM\nNaN\n0.5\nNaN\nNaN"
  },
  {
    "objectID": "04_05_数据的增加、删除、修改.html#添加新行",
    "href": "04_05_数据的增加、删除、修改.html#添加新行",
    "title": "11  数据的增加、删除、修改",
    "section": "添加新行",
    "text": "添加新行\n\n使用append方法\ndf = df.append(new_row, ignore_index=True)\n其中，new_row是一个包含新行数据的字典或Series对象。ignore_index=True确保新行的索引在原始DataFrame的索引基础上继续增加，而不是使用原来的索引。\n\n# 示例数据\ndata = {'姓名': ['张三', '李四', '王五', '赵钱', '孙李'],\n        '年龄': [25, 30, 35, 28, 22],\n        '性别': ['M', 'F', 'M', 'F', 'M']}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵钱\n28\nF\n\n\n4\n孙李\n22\nM\n\n\n\n\n\n\n\n\nnew_row = {'姓名': '熊大', '年龄': 35, '性别': 'M'}\n\ndf = df.append(new_row, ignore_index=True)\ndf\n\nC:\\Users\\nan\\AppData\\Local\\Temp\\ipykernel_26884\\3152558565.py:3: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(new_row, ignore_index=True)\n\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵钱\n28\nF\n\n\n4\n孙李\n22\nM\n\n\n5\n熊大\n35\nM\n\n\n\n\n\n\n\n\n\n使用concat()合并数据框\n将新行转换为数据框，然后将其与原数据框df进行合并。\n\nnew_row = {'姓名': '熊二', '年龄': 30, '性别': 'M'}\nnew_df = pd.DataFrame([new_row])\n\n# df = pd.concat([df, new_df]) # 不设置ignore_index的话，新行索引沿用旧索引 0\ndf = pd.concat([df, new_df], ignore_index=True)\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n性别\n\n\n\n\n0\n张三\n25\nM\n\n\n1\n李四\n30\nF\n\n\n2\n王五\n35\nM\n\n\n3\n赵钱\n28\nF\n\n\n4\n孙李\n22\nM\n\n\n5\n熊大\n35\nM\n\n\n6\n熊二\n30\nM"
  },
  {
    "objectID": "04_05_数据的增加、删除、修改.html#删除行列",
    "href": "04_05_数据的增加、删除、修改.html#删除行列",
    "title": "11  数据的增加、删除、修改",
    "section": "删除行/列",
    "text": "删除行/列\n\n使用drop方法删除列\ndf = df.drop('column_name', axis=1)\n需要提供要删除的列名，然后指定axis=1表示按列轴进行操作。删除列后，DataFrame会自动调整列的顺序。\n\ndf = df.drop('性别', axis=1)\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n0\n张三\n25\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵钱\n28\n\n\n4\n孙李\n22\n\n\n5\n熊大\n35\n\n\n6\n熊二\n30\n\n\n\n\n\n\n\n\n\n使用drop方法删除行\ndf = df.drop(row_index)\n使用drop方法根据行的索引来删除特定的行\n\n# 删除第一行数据\ndf = df.drop(0)\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵钱\n28\n\n\n4\n孙李\n22\n\n\n5\n熊大\n35\n\n\n6\n熊二\n30"
  },
  {
    "objectID": "04_05_数据的增加、删除、修改.html#修改数据",
    "href": "04_05_数据的增加、删除、修改.html#修改数据",
    "title": "11  数据的增加、删除、修改",
    "section": "修改数据",
    "text": "修改数据\n\nat方法\n\n# 指定行列\ndf.at[4, '年龄'] = 32\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵钱\n28\n\n\n4\n孙李\n32\n\n\n5\n熊大\n35\n\n\n6\n熊二\n30\n\n\n\n\n\n\n\n\n\n根据条件过滤修改数据\n\n# 找到姓名为熊大的行，将年龄修改为31\ndf.loc[df['姓名'] == '熊大', '年龄'] = 31\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n\n\n\n\n1\n李四\n30\n\n\n2\n王五\n35\n\n\n3\n赵钱\n28\n\n\n4\n孙李\n32\n\n\n5\n熊大\n31\n\n\n6\n熊二\n30\n\n\n\n\n\n\n\n\n\n转换类型\n有时候，计算出来的数据是浮点数，可以运用astype(‘int')转换数据列为整数类型:\n\ndf['薪资'] = [6000, 6000, 9000, 7000, 8000, 10000]\ndf['年薪'] = df['薪资']*12\n# 将年薪列转换为整数类型\ndf['年薪'] = df['年薪'].astype('int')\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n薪资\n年薪\n\n\n\n\n1\n李四\n30\n6000\n72000\n\n\n2\n王五\n35\n6000\n72000\n\n\n3\n赵钱\n28\n9000\n108000\n\n\n4\n孙李\n32\n7000\n84000\n\n\n5\n熊大\n31\n8000\n96000\n\n\n6\n熊二\n30\n10000\n120000\n\n\n\n\n\n\n\n\n\napply()+lambda()\n可以使用apply()和lambda函数对数据进行修改：查看下列示例：\n\n# df.apply()函数将括号内的内容运用到df的所有元素\n# lambda: 如果年薪大于10w，显示`&gt;10w`，如果年薪小于10w，显示`&lt;10w`\ndf['年薪'] = df['年薪'].apply(lambda x: '&gt;10w' if x&gt;100000 else '&lt;10w')\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n薪资\n年薪\n\n\n\n\n1\n李四\n30\n6000\n&lt;10w\n\n\n2\n王五\n35\n6000\n&lt;10w\n\n\n3\n赵钱\n28\n9000\n&gt;10w\n\n\n4\n孙李\n32\n7000\n&lt;10w\n\n\n5\n熊大\n31\n8000\n&lt;10w\n\n\n6\n熊二\n30\n10000\n&gt;10w"
  },
  {
    "objectID": "04_05_数据的增加、删除、修改.html#重命名列",
    "href": "04_05_数据的增加、删除、修改.html#重命名列",
    "title": "11  数据的增加、删除、修改",
    "section": "重命名列",
    "text": "重命名列\n\n使用rename\ndf = df.rename(columns={'old_column_name':'new_column_name'})\n其中，old_column_name是旧列名，new_column_name是新的列名。\ndf.rename(index={'old_label':'new_label'})也能用来修改行标签。\n\ndf = df.rename(columns={'姓名': '职员姓名', '年龄':'职员年龄'})\ndf\n\n\n\n\n\n\n\n\n职员姓名\n职员年龄\n薪资\n年薪\n\n\n\n\n1\n李四\n30\n6000\n&lt;10w\n\n\n2\n王五\n35\n6000\n&lt;10w\n\n\n3\n赵钱\n28\n9000\n&gt;10w\n\n\n4\n孙李\n32\n7000\n&lt;10w\n\n\n5\n熊大\n31\n8000\n&lt;10w\n\n\n6\n熊二\n30\n10000\n&gt;10w\n\n\n\n\n\n\n\n\n\n直接设置columns\n\ndf.columns = ['姓名', '年龄', '月薪', '年薪水平']\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n月薪\n年薪水平\n\n\n\n\n1\n李四\n30\n6000\n&lt;10w\n\n\n2\n王五\n35\n6000\n&lt;10w\n\n\n3\n赵钱\n28\n9000\n&gt;10w\n\n\n4\n孙李\n32\n7000\n&lt;10w\n\n\n5\n熊大\n31\n8000\n&lt;10w\n\n\n6\n熊二\n30\n10000\n&gt;10w\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\ndrop()和rename()也可以通过设置inplace=True直接修改原数据框。"
  },
  {
    "objectID": "04_05_数据的增加、删除、修改.html#按值排序",
    "href": "04_05_数据的增加、删除、修改.html#按值排序",
    "title": "11  数据的增加、删除、修改",
    "section": "按值排序",
    "text": "按值排序\n\n使用sort_values方法\ndf = df.sort_values(by='column_name', ascending=True)\n其中，column_name是你想要按其值进行排序的列名。ascending=True表示按升序——从小到大排列，若要按降序——从大到小排列，将ascending设置为False即可。\n通过sort_values方法可以根据特定列的值对DataFrame进行排序。可以选择按单个列或多个列的值排序，只需在by参数中提供相应的列名列表即可。\n\ndf = df.sort_values(by='年龄', ascending=True)\ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n月薪\n年薪水平\n\n\n\n\n3\n赵钱\n28\n9000\n&gt;10w\n\n\n1\n李四\n30\n6000\n&lt;10w\n\n\n6\n熊二\n30\n10000\n&gt;10w\n\n\n5\n熊大\n31\n8000\n&lt;10w\n\n\n4\n孙李\n32\n7000\n&lt;10w\n\n\n2\n王五\n35\n6000\n&lt;10w\n\n\n\n\n\n\n\n\n# 先按月薪降序排列，薪资相同则按年龄升序排列\ndf = df.sort_values(by=['月薪', '年龄'], ascending=[False, True]) # 如果排序方式相同，只需要一个布尔值就好 \ndf\n\n\n\n\n\n\n\n\n姓名\n年龄\n月薪\n年薪水平\n\n\n\n\n6\n熊二\n30\n10000\n&gt;10w\n\n\n3\n赵钱\n28\n9000\n&gt;10w\n\n\n5\n熊大\n31\n8000\n&lt;10w\n\n\n4\n孙李\n32\n7000\n&lt;10w\n\n\n1\n李四\n30\n6000\n&lt;10w\n\n\n2\n王五\n35\n6000\n&lt;10w"
  },
  {
    "objectID": "04_06_如何计算汇总统计.html",
    "href": "04_06_如何计算汇总统计.html",
    "title": "12  如何计算汇总统计",
    "section": "",
    "text": "如何计算汇总统计\n\n\n\n\n\n常用的汇总统计操作\n\ndescribe() 方法\ndescribe() 是 Pandas 中一个常用的基础操作，用于生成关于关于数据的基本描述统计信息。\n使用 describe() 方法，你可以获得以下统计信息：\n计数（count）：非缺失值的数量。\n均值（mean）：平均值。\n标准差（std）：标准差衡量数据的离散程度。\n最小值（min）和最大值（max）：数据列的最小和最大值。\n四分位数（25%，50%，75%）：数据的四个百分位数，用于描述数据的分布。\n示例代码：\n\nimport pandas as pd\n\ndata = {'Value': [10, 20, 15, 25, 30, 5, 12]}\ndf = pd.DataFrame(data)\n\nsummary_stats = df['Value'].describe()\nprint(summary_stats)\n\ncount     7.000000\nmean     16.714286\nstd       8.788521\nmin       5.000000\n25%      11.000000\n50%      15.000000\n75%      22.500000\nmax      30.000000\nName: Value, dtype: float64\n\n\n\n\n平均值、中位数、标准差、方差\n在 Pandas 中，我们也可以使用单独的函数来计算特定统计量，如平均值、中位数、标准差等，而非获取数据的所有统计信息，其方法如下：\n\n.mean() 方法：计算数值型列的平均值\n.median() 方法：计算数值型列的中位数\n.std() 方法：计算数值型列的标准差\nvar()方法：计算数值型列的方差\n\n\n# 计算数值型列的平均值\nmean_value = df['Value'].mean()\n# 计算数值型列的中位数\nmedian_value = df['Value'].median()\n# 计算数值型列的标准差\nstd_deviation = df['Value'].std()\n# 计算数值型列的方差\nvariance = df['Value'].var()\n\nprint(\"Mean:\", mean_value)\nprint(\"Median:\", median_value)\nprint(\"Standard Deviation:\", std_deviation)\nprint(\"Variance\", variance)\n\nMean: 16.714285714285715\nMedian: 15.0\nStandard Deviation: 8.788520651286838\nVar Deviation 77.23809523809523\n\n\n\n\n最大值、最小值、总和\n要单独查看数据列的最大值、最小值、总和，我们可以使用如下函数：\n\nmin()方法：计算数值型列的最小值\nmax()方法：计算数值型列的最大值\nsum()方法：计算数值型列的总和\n\n\ntotal_sum = df['Value'].sum()\nminimum_value = df['Value'].min()\nmaximum_value = df['Value'].max()\n\nprint(\"Total Sum:\", total_sum)\nprint(\"Minimum Value:\", minimum_value)\nprint(\"Maximum Value:\", maximum_value)\n\n\n\n分位数\n通过 quantile() 函数，我们可以计算任意分位数。\n\nquantile_25 = df['Value'].quantile(0.25)\nquantile_75 = df['Value'].quantile(0.75)\n\nprint(\"25th Percentile:\", quantile_25)\nprint(\"75th Percentile:\", quantile_75)\n\n25th Percentile: 11.0\n75th Percentile: 22.5\n\n\n通过查看数值型列的汇总统计，可以快速了解数据的整体分布和统计特征，有助于进行数据分析和洞察。\n\n\n\ngroupby()的用法\n在 Pandas 数据处理中，groupby() 是一项关键操作，广泛用于数据分析、摘要统计以及数据处理等领域。借助 groupby()，我们能够便捷地将数据按照指定列的值进行分类分组，然后对每个分组进行聚合分析。\n通过 groupby() 方法，我们可以根据单个或多个列的值对数据进行智能分组，然后运用聚合函数来生成汇总结果。以下是基本用法的示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {'Category': ['A', 'B', 'A', 'B', 'A', 'A', 'B'],\n        'Value': [10, 20, 15, 25, 30, 5, 12]}\ndf = pd.DataFrame(data)\n\n# 按照 Category 列进行分组，并计算每个分组的平均值\ngrouped = df.groupby('Category')\ngrouped_mean = grouped.mean()\n\nprint(grouped_mean)\n\n          Value\nCategory       \nA          15.0\nB          19.0\n\n\ngroupby() 通常与其他汇总、统计、聚合函数一起使用，例如 sum()、mean()、max()、min() 等。\n\n# 对分组计算总和、平均值、最大值、最小值\ngrouped_sum = grouped['Value'].sum()\ngrouped_mean = grouped['Value'].mean()\ngrouped_max = grouped['Value'].max()\ngrouped_min = grouped['Value'].min()\n\nprint(grouped_sum)\nprint(grouped_mean)\nprint(grouped_max)\nprint(grouped_min)\n\nCategory\nA    60\nB    57\nName: Value, dtype: int64\nCategory\nA    15.0\nB    19.0\nName: Value, dtype: float64\nCategory\nA    30\nB    25\nName: Value, dtype: int64\nCategory\nA     5\nB    12\nName: Value, dtype: int64\n\n\n另外，我们还可以根据多列的值来分组，只需要在 groupby() 方法中传递一个包含列名的列表即可。\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {'Category': ['A', 'B', 'A', 'B', 'A', 'A', 'B'],\n        'Subcategory': ['X', 'Y', 'X', 'Y', 'X', 'Y', 'X'],\n        'Value': [10, 20, 15, 25, 30, 5, 12]}\ndf = pd.DataFrame(data)\n\n# 按照 Category 和 Subcategory 列进行分组，并计算每个分组的平均值\ngrouped = df.groupby(['Category', 'Subcategory'])\ngrouped_mean = grouped.mean()\n\nprint(grouped_mean)\n\n                          Value\nCategory Subcategory           \nA        X            18.333333\n         Y             5.000000\nB        X            12.000000\n         Y            22.500000\n\n\n在使用 groupby() 时，我们除了可以使用 Pandas 内置的聚合函数对分组数据进行操作，还可以自定义聚合函数来实现我们需要的功能。\n\n# 自定义聚合函数，计算最大值和最小值之差\ndef custom_agg(x):\n    return x.max() - x.min()\n\ngrouped_custom = df.groupby('Category')['Value'].agg(custom_agg)\n\nprint(grouped_custom)\n\nCategory\nA    25\nB    13\nName: Value, dtype: int64\n\n\n\n\nsize和count\n在Pandas中，size和count是用于计算分组数据的两个方法，常常与groupby一起使用。它们可以提供关于每个分组的计数信息，但在计算方式和返回结果上有一些区别。\nsize方法：\n\nsize方法用于计算每个分组中的元素数量，包括缺失值。\n返回的结果是一个Series，其索引是分组键，值是每个分组中的元素数量。\nsize方法不考虑缺失值，即使某个分组中存在缺失值，它也会将其计算为有效元素。\n\ncount方法：\n\ncount方法用于计算每个分组中非缺失值的数量。\n返回的结果是一个Series，其索引是分组键，值是每个分组中的非缺失值的数量。\ncount方法排除了缺失值，只计算非缺失值的数量。\n\n\n\n\n\n\n\nNote\n\n\n\nisna() 方法 如果要检测数据中缺失值的数量，可以使用 isna() 方法，该方法会返回一个布尔值的 DataFrame，用于指示每个元素是否为缺失值（True表示缺失值，False表示非缺失值）。这个方法通常用于数据清洗、预处理以及数据的初步探索。通常情况下，这个方法可以与 sum() 方法一起使用，以达到检测缺失值数量的目的。\n你可以尝试下面的代码，试试看如何统计缺失值的数量。\nimport pandas as pd\n\n# 创建一个包含缺失值的DataFrame\ndata = {'A': [1, 2, None, 4],\n        'B': [None, 5, 6, 7],\n        'C': [10, 20, 30, 40]}\ndf = pd.DataFrame(data)\n\n# 使用.isna().sum()统计每列的缺失值数量\nmissing_values_count = df.isna().sum()\n\nprint(missing_values_count)\n\n\n\n示例，演示如何使用size和count方法结合groupby对数据进行计数：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {'Group': ['A', 'A', 'B', 'B', 'B'],\n        'Value': [1, 2, 3, None, 5]}\ndf = pd.DataFrame(data)\n\n# 使用groupby和size计算每个分组的元素数量\nsize_result = df.groupby('Group').size()\n\n# 使用groupby和count计算每个分组的非缺失值数量\ncount_result = df.groupby('Group').count()\n\nprint(\"Size结果:\")\nprint(size_result)\nprint(\"\\nCount结果:\")\nprint(count_result)\n\n在上述示例中，我们创建了一个DataFrame，并使用Group列进行分组。然后，我们分别使用size和count方法对分组后的数据进行计数。可以看到，size方法返回了每个分组的元素数量，而count方法返回了每个分组的非缺失值数量。在分组B中，有一个缺失值，因此size方法返回3，而count方法返回2。\n这两个方法的使用可以根据具体需求来选择。如果需要考虑缺失值并计算所有元素的数量，可以使用size方法；如果只关心非缺失值的数量，可以使用count方法。\n\n\n\n如何重塑表格布局\n\nsort的用法\n在Pandas中，sort_values和sort_index是用于对DataFrame或Series进行排序的两个常用方法。\nsort_values方法：\n\nsort_values方法用于按照指定的列或多个列的值对DataFrame或Series进行排序。\n可以通过by参数指定要排序的列或多个列，以列表形式提供。\n可以使用ascending参数来控制排序的升序或降序，默认为True（升序）。\n可以使用inplace参数来指定是否原地修改DataFrame或Series，默认为False，即返回排序后的副本。\n示例：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [3, 2, 1], 'B': [1, 3, 2]})\nsorted_df = df.sort_values(by='A', ascending=True)\n\n\n上述代码将按照’A’列的值对DataFrame df 进行升序排序，并将结果存储在sorted_df中。\n\nsort_index方法：\n\nsort_index方法用于根据索引对DataFrame或Series进行排序。\n可以使用axis参数指定要排序的轴，axis=0表示按行索引排序，axis=1表示按列索引排序。\n可以使用ascending参数来控制排序的升序或降序，默认为True（升序）。\n可以使用inplace参数来指定是否原地修改DataFrame或Series，默认为False，即返回排序后的副本。\n示例：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [3, 2, 1], 'B': [1, 3, 2]}, index=[2, 1, 3])\nsorted_df = df.sort_index(axis=0, ascending=True)\n\n\n上述代码将按照行索引对DataFrame df 进行升序排序，并将结果存储在sorted_df中。\n\n排序操作可以根据具体需求来选择使用sort_values还是sort_index。如果希望根据列的值进行排序，使用sort_values方法；如果希望根据索引进行排序，使用sort_index方法。\n\n在Pandas中，可以使用不同的方法来重新塑造（reshape）表格布局，以满足特定的数据分析和处理需求。以下是一些常用的重塑表格布局的方法：\n\n\npivot()方法\npivot()方法：用于将长格式（long format）的数据转换为宽格式（wide format），根据指定的列创建新的列，并使用列值进行填充。\n示例，展示如何使用pivot()方法将数据从长格式转换为宽格式：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndata = {'Name': ['John', 'John', 'Emma', 'Emma', 'Alex', 'Alex'],\n        'Subject': ['Math', 'Science', 'Math', 'Science', 'Math', 'Science'],\n        'Score': [85, 92, 78, 88, 90, 85]}\ndf = pd.DataFrame(data)\n\n# 使用pivot方法重塑表格布局\npivot_df = df.pivot(index='Name', columns='Subject', values='Score')\npivot_df\n\n\n\nmelt()方法\n在Pandas中，melt()是一个用于将宽格式（wide format）的数据转换为长格式（long format）的方法。它将数据从列中展开成为更长的格式，使得数据更适合进行分析和可视化。\nmelt()方法的语法如下：\nDataFrame.melt(id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None)\n参数说明：\n\nid_vars：可选参数，指定要保留的列名，不进行展开操作。\nvalue_vars：可选参数，指定要进行展开操作的列名。如果未指定，则默认展开所有未指定为id_vars的列。\nvar_name：可选参数，指定展开后的列名的名称。\nvalue_name：可选参数，指定展开后的值的列名的名称，默认为value。\ncol_level：可选参数，用于多层索引列的级别。\n\n下面是一个示例，演示如何使用melt()方法将宽格式的数据转换为长格式：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Math': [90, 80, 70],\n    'Science': [95, 85, 75],\n    'History': [92, 82, 72]\n}\ndf = pd.DataFrame(data)\n\n# 使用melt()方法进行数据转换\nmelted_df = df.melt(id_vars='Name', value_vars=['Math', 'Science', 'History'], var_name='Subject', value_name='Score')\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n转换后的DataFrame:\")\nmelted_df\n\n\n\nstack()方法\nstack()方法：\n在Pandas中，stack()是一个用于对DataFrame进行堆叠操作的方法。它将列标签（Column labels）转换为行索引（Row index），将数据从宽格式转换为长格式，从而生成一个更紧凑的DataFrame。\nstack()方法的语法如下：\nDataFrame.stack(level=-1, dropna=True)\n参数说明：\n\nlevel：可选参数，用于多层索引列的级别。默认值为-1，表示堆叠所有列。\ndropna：可选参数，指定是否删除包含缺失值的行，默认为True。\n\n示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob'],\n    'Math': [90, 80],\n    'Science': [95, 85],\n    'History': [92, 82]\n}\ndf = pd.DataFrame(data)\n\n# 使用stack()方法进行堆叠操作\nstacked_df = df.set_index('Name').stack().reset_index()\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n堆叠后的DataFrame:\")\nstacked_df\n\n\n\nunstack()方法\n在Pandas中，unstack()是用于将表格中的行索引转换为列索引，将数据从长格式转换为宽格式。\nunstack()方法的语法如下：\nDataFrame.unstack(level=-1, fill_value=None)\n参数说明：\n\nlevel：可选参数，用于指定要展开的层次化索引的级别。默认值为-1，表示展开最内层索引。\nfill_value：可选参数，用于指定填充缺失值的值。\n\n示例：\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndata = {\n    'Name': ['Alice', 'Bob'],\n    'Subject': ['Math', 'Science'],\n    'Score': [90, 80]\n}\ndf = pd.DataFrame(data)\n\n# 将DataFrame进行设置层次化索引\nindexed_df = df.set_index(['Name', 'Subject'])\n\n# 使用unstack()方法进行展开操作\nunstacked_df = indexed_df.unstack()\n\nprint(\"原始DataFrame:\")\nprint(df)\nprint(\"\\n展开后的DataFrame:\")\nunstacked_df\n\n在上述示例中，原始数据包含学生的姓名、科目和分数。通过使用pivot()方法，将姓名作为行索引，科目作为列索引，并将分数填充到相应的单元格中，得到了以学生姓名为行、科目为列的宽格式表格布局。\n\n长、宽格式转换与转置的区别\n在Python中，长格式（Long Format）和宽格式（Wide Format）是数据集的两种常见表示方式，通常用于数据分析和处理。这两种格式在转换和转置时有一些区别。\n长格式（Long Format）：\n\n长格式也称为“堆叠”或“纵向”格式，它将数据以多行的形式呈现，每一行表示一个观察值，每一列包含一个变量。\n长格式通常用于处理时间序列数据或实验数据，其中每个实验单位可以有多个测量值。\n在长格式中，通常会有一个或多个列用于标识不同的变量，以及一个列用于存储对应的值。\n适用于需要对数据进行聚合、分组和透视的操作。\n\n长格式表格示例\n\n\n\n城市\n月份\n温度\n\n\n\n\n北京\n1月\n0°C\n\n\n北京\n2月\n3°C\n\n\n北京\n3月\n10°C\n\n\n上海\n1月\n5°C\n\n\n上海\n2月\n8°C\n\n\n上海\n3月\n15°C\n\n\n\n宽格式（Wide Format）：\n\n宽格式也称为“透视”或“横向”格式，它将数据以多列的形式呈现，每一行表示一个观察值，每一列包含一个变量。\n宽格式通常用于简化数据结构，将不同的变量作为独立的列存储，方便直观地查看变量之间的关系。\n在宽格式中，每列可能代表不同的变量，每行可能代表不同的观察值。\n适用于需要直接查看变量之间关系的情况。\n\n宽格式表格示例：\n\n\n\n城市\n1月\n2月\n3月\n\n\n\n\n北京\n0°C\n3°C\n10°C\n\n\n上海\n5°C\n8°C\n15°C\n\n\n\n转换与转置的区别：\n\n转换：指的是将数据从一种格式转换为另一种格式，通常涉及重新组&gt; 织数据以满足特定的分析或可视化需求。例如，从长格式转换为宽格式，或&gt; 者从宽格式转换为长格式。\n转置：指的是在数据集中对行和列进行互换。对于二维数据，转置就&gt; 是将行变为列，列变为行。转置不涉及数据的重新排列，只是改变了数据的&gt; 布局。\n\n对上面的宽表格进行专职操作，得到如下表：\n转置表格示例：\n\n\n\n城市\n北京\n上海\n\n\n\n\n1月\n0°C\n5°C\n\n\n2月\n3°C\n8°C\n\n\n3月\n10°C\n15°C\n\n\n\n在Python中，你可以使用不同的库和工具来进行长、宽格式之间的转换和转&gt; 置操作。例如，Pandas库提供了丰富的功能来处理和转换数据集的不同格&gt; &gt; 式。使用melt()函数可以将宽格式转换为长格式，而使用pivot()函数可&gt; 以将长格式转换为宽格式。至于转置，你可以使用Numpy库的transpose() 函数或者Pandas库的.T`属性来实现。\n总之，长、宽格式之间的转换和转置操作取决于你的数据分析需求以及数据集的结构。\n\n\n\n\n如何合并多个表中的数据\n在Pandas中，可以使用不同的方法来合并（merge）多个表中的数据。以下是一些常用的合并数据的方法：\n\nconcat()方法\n在Pandas中，concat()是一个用于沿指定轴（行或列）将多个DataFrame对象进行合并的方法。它可以将多个DataFrame对象按照指定的方式进行连接，并返回一个合并后的DataFrame。以下是关于concat()方法的解释和示例说明：\nconcat()方法的语法如下：\npd.concat(objs, axis=0, join='outer', ignore_index=False)\n参数说明：\n\nobjs：要合并的DataFrame对象列表或字典。\naxis：可选参数，指定合并的轴。默认为0，表示按行合并；1表示按列合并。\njoin：可选参数，指定连接的方式。默认为'outer'，表示按照并集进行连接；'inner'表示按照交集进行连接。\nignore_index：可选参数，指定是否忽略合并后的索引。默认为False，表示保留原始索引。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ndf2 = pd.DataFrame({'A': [7, 8, 9], 'B': [10, 11, 12]})\n\n# 使用concat()方法进行合并操作\nmerged_df = pd.concat([df1, df2])\n\nprint(\"合并后的DataFrame:\")\nmerged_df\n\n\n\nmerge()方法\n在Pandas中，merge()是一个用于合并（或连接）多个DataFrame对象的方法。它基于指定的键（或多个键）将多个DataFrame按照指定的方式进行连接，并返回一个合并后的DataFrame。\nmerge()方法的语法如下：\npd.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True)\n参数说明：\n\nleft：左侧的DataFrame对象。\nright：右侧的DataFrame对象。\nhow：可选参数，指定连接方式。默认为'inner'，表示按照键的交集进行连接；'outer'表示按照键的并集进行连接；'left'表示按照左侧DataFrame的键进行连接；'right'表示按照右侧DataFrame的键进行连接。\non：可选参数，用于指定连接的键。可以是一个列名的字符串，或多个列名组成的列表。\nleft_on：可选参数，用于指定左侧DataFrame连接键的列名或列名列表。\nright_on：可选参数，用于指定右侧DataFrame连接键的列名或列名列表。\nleft_index：可选参数，指定是否使用左侧DataFrame的索引作为连接键。\nright_index：可选参数，指定是否使用右侧DataFrame的索引作为连接键。\nsort：可选参数，指定是否按照连接键进行排序。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6], 'Key': ['K1', 'K2', 'K3']})\ndf2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12], 'Key': ['K2', 'K3', 'K4']})\n\n# 使用merge()方法进行合并操作\nmerged_df = pd.merge(df1, df2, on='Key')\n\nprint(\"合并后的DataFrame:\")\nmerged_df\n\n\n\njoin()方法\n在Pandas中，join()是一个用于基于索引或列之间的关系将两个DataFrame对象进行连接的方法。它类似于SQL中的JOIN操作，可以根据指定的连接键将两个DataFrame进行合并，并返回一个合并后的DataFrame。\njoin()方法的语法如下：\nDataFrame.join(other, on=None, how='left', lsuffix='', rsuffix='', sort=False)\n参数说明：\n\nother：要连接的另一个DataFrame对象。\non：可选参数，用于指定连接键。可以是一个列名的字符串，或多个列名组成的列表。如果未指定，则根据索引进行连接。\nhow：可选参数，指定连接方式。默认为'left'，表示按照左侧DataFrame的索引或列进行连接；'right'表示按照右侧DataFrame的索引或列进行连接；'inner'表示按照两个DataFrame共有的索引或列进行连接；'outer'表示按照两个DataFrame的并集进行连接。\nlsuffix：可选参数，用于处理连接时重叠列名的后缀（左侧DataFrame）。\nrsuffix：可选参数，用于处理连接时重叠列名的后缀（右侧DataFrame）。\nsort：可选参数，指定是否按照连接键进行排序。\n\n示例：\n\nimport pandas as pd\n\n# 创建示例DataFrame\ndf1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}, index=['K1', 'K2', 'K3'])\ndf2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12]}, index=['K2', 'K3', 'K4'])\n\n# 使用join()方法进行连接操作\njoined_df = df1.join(df2)\n\nprint(\"连接后的DataFrame:\")\njoined_df\n\n\n\n补充：T（Transpose）转置\n在Pandas中，T（Transpose）是一个用于转置数据的方法。转置操作会将DataFrame或Series的行和列进行交换，从而生成一个新的转置后的数据结构。以下是关于Pandas中的T转置的一些知识点：\n\nDataFrame的转置： 转置DataFrame时，行索引将会变成转置前的列索引，列索引将会变成转置前的行索引。可以使用T方法来执行转置操作，例如：\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ntransposed_df = df.T\n\n上述代码将创建一个DataFrame df，然后使用T方法将其转置，结果将会存储在transposed_df中。\n\nSeries的转置： 转置一个Series对象会生成一个具有单一列的DataFrame，行索引将会保持不变，而列索引将会变为转置前的索引值。可以使用T方法对Series进行转置，例如：\n\n\nimport pandas as pd\n\nseries = pd.Series([1, 2, 3, 4], index=['A', 'B', 'C', 'D'])\ntransposed_series = series.T\n\n上述代码将创建一个Series series，然后使用T方法将其转置，结果将会存储在transposed_series中。\n\n转置对数据结构的影响： 转置操作不会改变原始数据结构，而是生成一个新的转置后的数据结构。原始数据结构保持不变，只是行和列的排列顺序发生了变化。\n转置的应用： 转置操作常用于需要改变数据结构的情况，例如在数据分析和处理过程中，可以使用转置来更改数据的布局以满足特定的分析需求。\n\n需要注意的是，转置操作可能会导致数据结构的变化，因此在进行转置操作之后，索引和列名可能需要进行调整以适应新的结构。"
  },
  {
    "objectID": "04_07_时间序列数据.html",
    "href": "04_07_时间序列数据.html",
    "title": "13  Pandas处理时间序列数据",
    "section": "",
    "text": "Pandas处理时间序列数据"
  },
  {
    "objectID": "04_07_时间序列数据.html#一日期和时间数据类型",
    "href": "04_07_时间序列数据.html#一日期和时间数据类型",
    "title": "13  Pandas处理时间序列数据",
    "section": "一、日期和时间数据类型",
    "text": "一、日期和时间数据类型\n\n1. Timestamp对象\nTimestamp对象是Pandas中用于表示日期和时间的单个时间点的数据类型，是Pandas处理时间序列数据的基本数据类型之一，其精度达到纳秒(0.000000001秒)级别。\n在Pandas中，通常使用pandas.Timestamp来表示Timestamp对象。\n\n(1) 创建Timestamp对象\n在Pandas中，Timestamp对象的值包括日期和时间信息，创建Timestamp对象的方法共有三种：\n\nimport pandas as pd\nimport datetime\n\n# 从字符串创建\npd.Timestamp('2023-07-20')\n\n# 从Python的datetime对象创建\npd.Timestamp(datetime.datetime(2023, 7, 21))\n\n# 从时间戳创建\npd.Timestamp(1612060800)    # 时间戳1612060800代表从UNIX纪元开始经过的秒数，具体日期和时间取决于该时间戳对应的具体时区和时刻。\n\nTimestamp('1970-01-01 00:00:01.612060800')\n\n\n\n\n\n拓展：属性与方法\n\n\n\n属性（Attributes）是对象的特征或状态，用于描述对象的数据。在Python中，对象的属性可以是对象的实例变量（instance variable），也可以是类变量（class variable），用于存储对象的数据。\n\n\n方法（Methods）是对象可以执行的操作或行为，用于描述对象的功能和行为。在Python中，方法是定义在类中的函数，通过访问对象的方法，我们可以执行特定的操作或实现对象的功能。\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n注意，这部分是可选的，大家可以根据自己的需要阅读。\n\nTimestamp对象具有多个属性和方法，用于获取和操作日期时间信息。通过使用属性和方法可以对时间和日期进行提取或格式化等操作。对Timestamp对象常用的属性和方法有： ##### 属性：\n\nyear、month、day：返回Timestamp对象的年份、月份和日期。\nhour、minute、second：返回Timestamp对象的小时、分钟和秒。\nmicrosecond、nanosecond：获取Timestamp对象的微秒数和纳秒数。\ndayofweek：获取Timestamp对象所表示的星期几，返回一个整数（0代表星期一，6代表星期日）。\nweekday_name：返回星期几的名称。\nweek：获取Timestamp对象所在年份的周数。\ndayofyear：获取Timestamp对象在所在年份中的第几天。\n\n\n方法：\n\ndate()：获取Timestamp对象的日期部分，返回一个日期对象。\ntime()：获取Timestamp对象的时间部分，返回一个时间对象。\nstrftime(format)：将Timestamp对象格式化为指定的字符串格式。format参数是一个字符串，用于指定输出的日期时间格式，如”%Y-%m-%d %H:%M:%S”。\n\n\n\n\n\n\n(2) 比较和运算\nTimestamp对象在Pandas中支持比较运算符和算术运算符，可以用于进行日期和时间的比较和计算。\n\n比较运算符\n\n相等性比较：使用==运算符检查两个Timestamp对象是否相等。\n不等性比较：使用!=运算符检查两个Timestamp对象是否不相等。\n大小比较：使用&lt;、&lt;=、&gt;、&gt;=运算符进行Timestamp对象之间的大小比较。\n\n\n\n算术运算符\n\n加法和减法运算：可以使用+和-运算符对Timestamp对象进行加法和减法运算。加法运算可以用于将一个Timestamp对象与时间差（Timedelta对象）相加，得到一个新的Timestamp对象。减法运算可以用于计算两个Timestamp对象之间的时间差，得到一个Timedelta对象。\n时间偏移运算：可以使用+和-运算符对Timestamp对象进行时间偏移运算。通过给Timestamp对象加上或减去一个时间差（Timedelta对象），可以得到一个新的Timestamp对象。\n\n\n在Pandas中，datetime和timedelta是Python标准库中的对象，而不是Pandas特有的对象。Pandas使用这些对象来处理日期和时间序列数据。\n具体来说：\n\ndatetime是Python标准库中的模块，用于处理日期和时间相关的操作。Pandas通过使用datetime模块中的类，如datetime.datetime，来表示日期和时间点。在Pandas中，datetime对象通常用于创建时间戳（Timestamp）或时间序列的索引（DatetimeIndex）。\ntimedelta也是Python标准库中的模块，用于表示时间间隔。timedelta对象表示两个日期或时间点之间的差异。在Pandas中，timedelta对象通常用于执行时间偏移或计算时间差。\n\nPandas通过将这些Python标准库中的对象与其自己的数据结构和函数结合使用，提供了更高级和便捷的功能来处理时间序列数据。例如，Pandas的Timestamp对象是基于Python的datetime.datetime进行了封装和扩展，提供了更多的时间序列操作和处理方法。\n因此，虽然datetime和timedelta不是Pandas特有的对象，但它们在Pandas中被广泛使用，用于处理时间序列数据的表示、操作和计算。\n\n\n\n\n\n2. DatetimeIndex对象\nDatetimeIndex对象是由一组Timestamp对象构成的时间序列索引对象，用于对时间序列数据进行索引、切片和筛选操作。DatetimeIndex对象以时间点的形式对数据进行索引和标记，用于表示时间序列数据的时间维度。\n在Pandas中，DatetimeIndex对象可以作为DataFrame或Series的索引，或作为时间序列数据的标签。\n\n(1) 创建DatetimeIndex对象\n创建DatetimeIndex对象的方式一共有三种：\n\n# 从Python的datetime对象列表或数组创建\npd.DatetimeIndex([datetime1, datetime2, ...])\n\n# 通过日期字符串列表或数组创建\npd.DatetimeIndex(['2023-07-20', '2023-07-21', ...])\n\n# 通过日期范围创建\npd.date_range(start, end, freq) # start和end是起始和结束日期，freq是时间间隔。\n\n\n\n\n\n\n\nNote\n\n\n\n\n注意，这部分是可选的，大家可以根据自己的需要阅读。\n\nDatetimeIndex对象具有多个属性和方法，如下是对其常用的属性和方法。\n\n属性\n\nyear、month、day：返回DatetimeIndex对象中所有时间点的年份、月份和日期。\nhour、minute、second：返回DatetimeIndex对象中所有时间点的小时、分钟和秒。\nmicrosecond、nanosecond：获取DatetimeIndex对象中所有时间点的微秒数和纳秒数。\ndayofweek：获取DatetimeIndex对象中所有时间点所表示的星期几，返回一个整数（0代表星期一，6代表星期日）。\nweekday_name：返回DatetimeIndex对象中所有时间点所表示的星期几的名称。\ndate：返回DatetimeIndex对象中所有时间点的日期部分（日期对象）。\ntime：返回DatetimeIndex对象中所有时间点的时间部分（时间对象）。\n\n\n\n方法\n\nstrftime(format)：将DatetimeIndex对象中的时间点格式化为指定的字符串格式。\nresample(rule)：对DatetimeIndex对象进行重采样，将时间序列数据的频率转换为指定的频率规则。\n\nDatetimeIndex对象常用于对时间序列数据进行索引和切片操作，实现对时间序列数据的筛选、聚合和分析，还可以用于时间序列数据的重采样和频率转换操作，对时间序列数据进行降采样或升采样。另外，DatetimeIndex对象也可以用在时间序列数据的可视化中，将时间轴作为横坐标，方便观察和分析时间趋势。\n\n\n\n\n\n\n3. Period对象\n在Pandas中，Period对象用于表示时间段，表示在某个特定的时间单位内，如年、季度、月、周或天。它由一个起始时间点和一个结束时间点组成。\n\n(1) 创建Period对象\n在Pandas中，创建Period对象的方式有很多种，主要取决于时间段的起始点和频率\n\n# 使用日期字符串创建\npd.Period('2023-07', freq='M')  # 表示以2023年7月1日为起始点的一个月时间段，即从2023年7月1日到2023年7月31日\n\n# 使用整数值创建\npd.Period(2023, freq='A-DEC')   #表示以2023为起始点的一个年度的时间段，即从2023年1月1日开始，2023年12月31日结束，\n\n# 使用时间戳创建\npd.Period(pd.Timestamp('2023-07-21'), freq='D') #表示一个天的时间段，从2023年7月21日开始，为期1天的时间段\n\nPeriod('2023-07-21', 'D')\n\n\n\n起始点可以是日期字符串、整数或时间戳，而频率由频率字符串表示，如年度（‘A’）、季度（Q）、月度（M）、周度（W）或日（D）等。\n使用日期字符串和使用时间戳创建Period对象的区别\n\n使用日期字符串\n\n起始点使用的是日期字符串，表示了时间段的起始日期。\n在创建Period对象时，Pandas会根据传递的日期字符串进行解析和转换，将其转换为相应的时间点。\n\n使用时间戳\n\n起始点使用的是时间戳，表示了具体的时间点。\n时间戳是一个精确到纳秒级别的时间值，包含日期和时间信息。\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n注意，这部分是可选的，大家可以根据自己的需要阅读\n\n\n属性\n\nstart_time：返回时间段的起始时间点，表示为时间戳（Timestamp）对象。\nend_time：返回时间段的结束时间点，表示为时间戳（Timestamp）对象。\nfreq：返回时间段的频率，表示为频率字符串。\n\n\n\n方法\n\nto_timestamp(how='start')：将时间段转换为时间戳(Timestamp)对象，其中how为可选参数，可选的值包括start、end、nearest。\nto_period(freq)：将时间段转换为指定频率的时间段对象。\nstrftime(format)：将时间段格式化为指定的字符串表示形式。"
  },
  {
    "objectID": "04_07_时间序列数据.html#二创建时间序列数据",
    "href": "04_07_时间序列数据.html#二创建时间序列数据",
    "title": "13  Pandas处理时间序列数据",
    "section": "二、创建时间序列数据",
    "text": "二、创建时间序列数据\n在使用Pandas处理时间序列数据时，我们常常需要自己创建这些数据。下面，我们将采用示例的形式，向你展示Pandas中创建时间序列数据的方法。\n\n1. 从Python的datetime对象创建时间序列\n这种方法涉及在Python中使用datetime模块创建datetime对象，然后将其转换为Pandas的时间序列数据。需要预先定义和创建datetime对象，然后将其转换为时间序列。\n\n\"\"\"\n从Python的datetime对象创建时间序列\n1. 创建一个包含Python的datetime对象的列表或数组\n2. 使用pd.Series()函数将其转换为时间序列数据\n\"\"\"\n\nimport pandas as pd\nfrom datetime import datetime\n\ndates_1 = [datetime(2023, 7, 21), datetime(2023, 7, 22), datetime(2023, 7, 23)]\nts_1 = pd.Series(dates_1)\n\nprint(ts_1)\n\n0   2023-07-21\n1   2023-07-22\n2   2023-07-23\ndtype: datetime64[ns]\n\n\n\n\n2. 从字符串创建时间序列\n这种方法接受包含日期时间信息的字符串，并使用pd.to_datetime()函数将其转换为时间序列数据。它能够直接从日期时间字符串中解析和转换。\n\n\"\"\"\n从字符串创建时间序列\n1. 创建一个包含日期字符串的列表或数组\n2. 使用pd.to_datetime()函数将其转换为时间序列数据\n\"\"\"\n\nimport pandas as pd\n\ndates_2 = ['2023-07-24', '2023-07-25', '2023-07-26']\nts_2 = pd.to_datetime(dates_2)\n\nprint(ts_2)\n\nDatetimeIndex(['2023-07-24', '2023-07-25', '2023-07-26'], dtype='datetime64[ns]', freq=None)\n\n\n\n\n3. 使用日期范围创建\n这种方法使用pd.date_range()函数生成指定范围内的连续日期时间序列。需要指定起始日期、结束日期和频率等参数来定义范围和间隔。\n\n\"\"\"\n使用日期范围创建时间序列\n1. 使用start和end参数指定日期范围的其实和结束\n2. 使用freq参数指定日期的频率，例如天(D)、月(M)等\n\"\"\"\n\nimport pandas as pd\n\nts_3 = pd.date_range(start='2023-07-27', end='2023-07-29', freq='D')\n\nprint(ts_3)\n\nDatetimeIndex(['2023-07-27', '2023-07-28', '2023-07-29'], dtype='datetime64[ns]', freq='D')\n\n\n\n\n4. 从时间戳创建\n这种方法使用pd.Timestamp()函数从单个时间戳创建时间序列。需要提供一个日期时间的字符串或Python的datetime对象作为参数。\n\n\"\"\"\n从时间戳创建时间序列\n1. 使用pd.Timestamp函数，将单个时间戳转换为时间序列数据\n\"\"\"\n\nimport pandas as pd\n\nts_4 = pd.Timestamp('2022-07-30')\n\nts_4\n\nTimestamp('2022-07-30 00:00:00')\n\n\n\n\n5. 从时间偏移创建\n这种方法使用pd.date_range()函数结合相对时间偏移（DateOffset）对象，生成具有特定规则的时间序列。需要指定起始日期、时间序列长度和相对时间偏移对象等参数。\n\n\"\"\"\n从时间偏移创建时间序列\n1. 使用start和periods参数指定起始日期和时间序列的长度\n2. 使用freq参数指定日期的频率，并将相对时间偏移对象做为参数传递给freq参数\n\"\"\"\nimport pandas as pd\nfrom pandas.tseries.offsets import DateOffset\n\nts_5 = pd.date_range(start='2023-07-31', periods=10, freq=DateOffset(days=1))\nts_5\n\nDatetimeIndex(['2023-07-31', '2023-08-01', '2023-08-02', '2023-08-03',\n               '2023-08-04', '2023-08-05', '2023-08-06', '2023-08-07',\n               '2023-08-08', '2023-08-09'],\n              dtype='datetime64[ns]', freq='&lt;DateOffset: days=1&gt;')\n\n\n\nDateOffset是Pandas中的一个类，用于表示相对时间偏移量。它可以与日期时间对象一起使用，用于执行日期时间的偏移和调整。"
  },
  {
    "objectID": "04_07_时间序列数据.html#三时间序列的索引和切片",
    "href": "04_07_时间序列数据.html#三时间序列的索引和切片",
    "title": "13  Pandas处理时间序列数据",
    "section": "三、时间序列的索引和切片",
    "text": "三、时间序列的索引和切片\n\n1. 时间序列索引\n\n\n\n拓展：时间序列索引的特性和功能\n\n\n\n时间序列索引的特性\n\n\n\n时间序列索引具有排序的特性，它将时间点按照从早到晚的顺序进行排序。\n\n\n时间序列索引还可以具有重复的时间点，这意味着在同一个时间点上可能有多个数据点。\n\n\n\n时间序列索引的功能\n\n\n\n时间序列索引提供了一种灵活的方式来访问和处理时间序列数据。\n\n\n可以使用时间序列索引来选择特定日期或时间范围的数据点。\n\n\n时间序列索引支持基于标签的索引和切片操作，可以使用日期时间对象、日期时间字符串或日期时间范围来选择数据。\n\n\n时间序列索引还支持根据时间点进行数据的重采样、聚合和频率转换等操作。\n\n\n\n\nPandas提供了多种类型的时间序列索引，其中最常用的时DatetimeIndex，除了DatetimeIndex以外，还有其他的时间序列索引类型，如PeriodIndex用于表示时间段的索引、TimedeltaIndex用于表示时间间隔索引等。\n\nimport pandas as pd\n\n# 创建时间序列索引\nnew_dates = pd.to_datetime(['2023-07-21', '2023-07-22', '2023-07-23', '2023-07-24', '2023-07-25'])\nvalue_list = [\"新手\", \"程序员\", 3.14, 666, (5, 3, 4, 2, 8)]\n\nnew_ts_1 = pd.Series(value_list, index=new_dates)\n\nprint(new_ts_1['2023-07-21'])\n\n新手\n\n\n时间序列索引是由日期时间对象组成的，用于标识时间序列的各个数据点。时间序列索引可以是单个日期时间对象，也可以是包含多个日期对象的索引的对象。\n\n可以将时间序列索引分配给DataFrame或Series的索引，或者在创建DataFrame或Series时指定时间序列索引。\n\n使用单个日期时间对象作为时间序列索引\n\nimport pandas as pd\nimport datetime\n\n# 创建时间序列\ndt1 = datetime.datetime(2023, 7, 21)\ndt2 = datetime.datetime(2023, 7, 22)\ndt3 = datetime.datetime(2023, 7, 23)\n\nnew_ts_2 = pd.Series([\"name\", \"is\", \"新手程序员\"], index=[dt1, dt2, dt3])\n\n# 使用时间序列索引访问数据\nnum = new_ts_2[dt2]\nprint(num)\n\nis\n\n\n使用日期时间对象列表作为时间序列索引\n\nimport pandas as pd\nimport datetime\n\n# 创建时间序列\nnew_dates_2 = [datetime.datetime(2023, 7, 21), datetime.datetime(2023, 7, 22), datetime.datetime(2023, 7, 23)]\nvalue_list_2 = [\"我想说\", \"Hello\", \"World\"]\n\nnew_ts_3 = pd.Series(value_list_2, index=new_dates_2)\n\n# 使用时间序列索引访问数据\nvalue = new_ts_3[datetime.datetime(2023, 7, 21)]\n\nprint(value)\n\n我想说\n\n\n\n\n2. 时间序列切片\nPandas中用于处理时间序列的主要数据结构是Timestamp、DatetimeIndex和Period。Timestamp表示一个具体的时间点，DatetimeIndex是由Timestamp组成的索引，用于索引时间序列数据，而Period表示一个时间段。在Pandas包中，可以使用时间序列切片来选择和处理时间序列数据。\n时间切片是指在时间序列数据中选择特定的时间范围或时间点的操作。时间切片允许我们根据时间来选择数据，以进行分析、可视化或其他处理。\n在时间序列数据中，时间切片可以根据日期、时间范围或时间段来选择数据。例如，可以选择某一天、某个时间段内的数据，或者选择特定的月份、季度或年份的数据。\n在Pandas中，有如下常用的时间序列切片操作：\n\n(1) 根据日期索引选择数据\n在Pandas中，我们可以使用日期索引来选择特定日期或日期范围的数据。\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据，每日气温\ntemperatures = pd.Series([23, 25, 21, 19, 20, 22, 24], \n                        index=pd.date_range('2023-07-01', periods=7, freq='D'))\n\n# 选择7月3日的气温数据\nsliced_temperatures = temperatures['2023-07-03']\nprint(sliced_temperatures)\n\n21\n\n\n\n\n(2) 根据时间范围选择数据\n除了根据日期索引选择数据外，我们还可以根据特定的时间范围来选择数据。\n\nimport pandas as pd\nfrom datetime import time\n\n# 创建一个示例时间序列数据，每小时交通流量\ntraffic = pd.Series([120, 160, 180, 200, 220, 210, 190, 150, 130, 110, 100, 90],\n                    index=pd.date_range('2023-07-01', periods=12, freq='H'))\n\n# 选择在早上8点到上午10点之间的交通流量数据\nsliced_traffic = traffic.between_time(time(8, 0), time(10, 0))\nprint(sliced_traffic)\n\n2023-07-01 08:00:00    130\n2023-07-01 09:00:00    110\n2023-07-01 10:00:00    100\nFreq: H, dtype: int64\n\n\n除了使用between_time()方法，我们还可以使用布尔索引来选择特定时间范围内的数据。我们可以创造一个布尔条件，指定时间范围，并应用于时间序列数据。\n\n# 创建一个布尔条件，选择早上8点到下午3点之间的数据\ncondition = (traffic.index.hour &gt;= 8) & (traffic.index.hour &lt;= 15)\n\n# 应用布尔条件进行筛选\nsliced_data = traffic[condition]\nprint(sliced_data)\n\n2023-07-01 08:00:00    130\n2023-07-01 09:00:00    110\n2023-07-01 10:00:00    100\n2023-07-01 11:00:00     90\nFreq: H, dtype: int64\n\n\n\n\n(3) 根据时间段选择数据\n在Pandas中，我们还可以使用时间段来选择数据。\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据，每月销售额\nsales = pd.Series([1000, 1200, 900, 1100, 1300, 1400],\n                  index=pd.period_range('2023-01', periods=6, freq='M'))\n\n# 选择2023年第一季度的销售额数据\nsliced_sales = sales['2023Q1']\nprint(sliced_sales)\n\n2023-01    1000\n2023-02    1200\n2023-03     900\nFreq: M, dtype: int64"
  },
  {
    "objectID": "04_07_时间序列数据.html#四时间重采样和频率转换",
    "href": "04_07_时间序列数据.html#四时间重采样和频率转换",
    "title": "13  Pandas处理时间序列数据",
    "section": "四、时间重采样和频率转换",
    "text": "四、时间重采样和频率转换\n在Pandas中，时间重采样和频率转换是对时间序列数据进行重新采样和转换的操作。这些操作可以帮助我们更好地理解和分析时间序列数据，使其适应不同的时间尺度和分析需求。\n\n1. 序列的时间重采样\n时间重采样是指将时间序列数据从一个时间频率转换为另一个时间频率的过程。它可以将高频率的数据降采样为低频率，或将低频率的数据升采样为高频率。\n\n降采样（Downsampling）：将数据从高频率转换为低频率，例如从每分钟数据转换为每小时数据。在降采样中，多个原始数据点被合并为一个单独的数据点，通常通过聚合函数进行汇总。\n\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据，每秒钟的交易量数据\ntrade_volume = pd.Series([100, 150, 120, 80, 90, 110, 130, 140, 160, 120],\n                         index=pd.date_range('2023-07-01 09:30:00', periods=10, freq='S'))\n\n# 将数据降采样为每分钟，并计算每分钟的交易量\ndownsampled_trade_volume = trade_volume.resample('1min').sum()\nprint(downsampled_trade_volume)\n\n2023-07-01 09:30:00    1200\nFreq: T, dtype: int64\n\n\n\n升采样（Upsampling）：将数据从低频率转换为高频率，例如从每天数据转换为每小时数据。在升采样中，单个原始数据点被扩展为一个或多个更细粒度的数据点，通常使用插值方法来填充新生成的数据点。\n\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据，每月的销售额数据\nsales = pd.Series([1000, 1200, 900],\n                  index=pd.date_range('2023-01-01', periods=3, freq='M'))\n\n# 将数据升采样为每天，并使用线性插值方式填充新生成的数据点\nupsampled_sales = sales.resample('D').interpolate(method='linear')\nprint(upsampled_sales)\n\n2023-01-31    1000.000000\n2023-02-01    1007.142857\n2023-02-02    1014.285714\n2023-02-03    1021.428571\n2023-02-04    1028.571429\n2023-02-05    1035.714286\n2023-02-06    1042.857143\n2023-02-07    1050.000000\n2023-02-08    1057.142857\n2023-02-09    1064.285714\n2023-02-10    1071.428571\n2023-02-11    1078.571429\n2023-02-12    1085.714286\n2023-02-13    1092.857143\n2023-02-14    1100.000000\n2023-02-15    1107.142857\n2023-02-16    1114.285714\n2023-02-17    1121.428571\n2023-02-18    1128.571429\n2023-02-19    1135.714286\n2023-02-20    1142.857143\n2023-02-21    1150.000000\n2023-02-22    1157.142857\n2023-02-23    1164.285714\n2023-02-24    1171.428571\n2023-02-25    1178.571429\n2023-02-26    1185.714286\n2023-02-27    1192.857143\n2023-02-28    1200.000000\n2023-03-01    1190.322581\n2023-03-02    1180.645161\n2023-03-03    1170.967742\n2023-03-04    1161.290323\n2023-03-05    1151.612903\n2023-03-06    1141.935484\n2023-03-07    1132.258065\n2023-03-08    1122.580645\n2023-03-09    1112.903226\n2023-03-10    1103.225806\n2023-03-11    1093.548387\n2023-03-12    1083.870968\n2023-03-13    1074.193548\n2023-03-14    1064.516129\n2023-03-15    1054.838710\n2023-03-16    1045.161290\n2023-03-17    1035.483871\n2023-03-18    1025.806452\n2023-03-19    1016.129032\n2023-03-20    1006.451613\n2023-03-21     996.774194\n2023-03-22     987.096774\n2023-03-23     977.419355\n2023-03-24     967.741935\n2023-03-25     958.064516\n2023-03-26     948.387097\n2023-03-27     938.709677\n2023-03-28     929.032258\n2023-03-29     919.354839\n2023-03-30     909.677419\n2023-03-31     900.000000\nFreq: D, dtype: float64\n\n\n在Pandas中，可以使用.resample()方法来执行时间重采样操作，并根据需要应用聚合函数（如求和、平均值等）来处理生成的时间段内的数据。\n\n\n2. 数据框的时间重采样\n\nimport pandas as pd\nsales = pd.DataFrame({'Sales': [1000, 1200, 900, 800, 900, 1000, 800, 1100, 1000],\n                      'Date': pd.date_range('2023-01-01', periods=9, freq='D')})\n\n# 将数据升采样为每7天，并使用reset_index()重置索引\nweekly_sales = sales.resample('7D', on='Date')['Sales'].sum().reset_index()\nweekly_sales\n\n\n\n\n\n\n\n\nDate\nSales\n\n\n\n\n0\n2023-01-01\n6600\n\n\n1\n2023-01-08\n2100\n\n\n\n\n\n\n\n对于数据框的时间重采样，需要指明on参数为日期列，以及用中括号引用需要聚合的列，建议使用reset_index()重置索引，否则会默认将日期当作新的索引。\n\n\n3. 频率转换\n频率转换是指将时间序列数据从一个频率转换为另一个频率的过程。它可以根据需要将数据聚合到更高频率或更低频率，或者将数据按照自定义的频率进行转换。\n在Pandas中，可以使用.asfreq()方法来执行频率转换操作。它可以根据指定的频率将数据重新采样，填充缺失的数据点或者删除多余的数据点。\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据，每天销售额\nsales = pd.Series([100, 200, 150, 300, 250, 180],\n                  index=pd.date_range('2023-01-01', periods=6, freq='D'))\n\n# 将数据转换为每周频率，填充缺失的数据点为0\nconverted_data = sales.asfreq('W', fill_value=0)\nprint(converted_data)\n\n2023-01-01    100\nFreq: W-SUN, dtype: int64\n\n\n\n时间重采样和频率转换都涉及将时间序列数据从一个时间频率或频率转换为另一个的操作。时间重采样更侧重于根据时间间隔进行数据汇总和处理，而频率转换更侧重于调整数据的频率，并可根据需求填充或删除缺失的数据点。尽管它们在某些方面有相似之处，但它们在Pandas中具有不同的方法和选项来执行这些操作。"
  },
  {
    "objectID": "04_07_时间序列数据.html#五对缺失值的处理",
    "href": "04_07_时间序列数据.html#五对缺失值的处理",
    "title": "13  Pandas处理时间序列数据",
    "section": "五、对缺失值的处理",
    "text": "五、对缺失值的处理\n在Pandas处理时间序列数据时，处理缺失值是一个重要的环节，因为时间序列数据中可能会存在一些缺失的观测值。缺失值可能会对数据分析和建模产生不良影响，因此需要选择合适的方法来处理它们。\n\n# 创建包含缺失值的DataFrame\nimport numpy as np\n\ndata = {\n    'Date': pd.date_range(start='2023-01-01', periods=10),\n    'Value': [10, 20, np.nan, 40, np.nan, 60, np.nan, 80, 90, np.nan]\n}\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nDate\nValue\n\n\n\n\n0\n2023-01-01\n10.0\n\n\n1\n2023-01-02\n20.0\n\n\n2\n2023-01-03\nNaN\n\n\n3\n2023-01-04\n40.0\n\n\n4\n2023-01-05\nNaN\n\n\n5\n2023-01-06\n60.0\n\n\n6\n2023-01-07\nNaN\n\n\n7\n2023-01-08\n80.0\n\n\n8\n2023-01-09\n90.0\n\n\n9\n2023-01-10\nNaN\n\n\n\n\n\n\n\n\n1. 删除缺失值\n删除缺失值是处理缺失值最简单直观的方法，其语法为.dropna()，调用该方法将直接删除包含缺失值的行和列。\n直接删除缺失值一般使用在缺失值较多，或者缺失值对数据整体影响较大的情况，且在删除缺失值后，仍然有足够的样本数据用于后续的分析和建模时。\n\n# 删除包含缺失值的行\ndf.dropna(axis=0, inplace=True)\ndf\n\n\n\n\n\n\n\n\nDate\nValue\n\n\n\n\n0\n2023-01-01\n10.0\n\n\n1\n2023-01-02\n20.0\n\n\n3\n2023-01-04\n40.0\n\n\n5\n2023-01-06\n60.0\n\n\n7\n2023-01-08\n80.0\n\n\n8\n2023-01-09\n90.0\n\n\n\n\n\n\n\n\n\n2. 填充缺失值\n填充缺失值时最常用的一种用于处理缺失值的方法，其语法为.fillna()。在调用该方法时，我们可以使用指定的值或其他有效的填充策略来替换缺失值。\n填充缺失值的方法通常适用于保留所有样本且不影响数据整体分布的情况，比如连续时间序列数据之中，相邻时间点的数据较为平滑。\n\n# 将缺失值填充为0\ndf.fillna(0, inplace=True)\n\n# 使用前向填充（使用前面的值填充）\ndf.fillna(method='ffill', inplace=True)\n\n# 使用后向填充（使用后面的值填充）\ndf.fillna(method='bfill', inplace=True)\n\n\n\n3. 使用统计值填充\n使用统计值填充通常与上面的方法结合使用。我们可以在获得已有数据的统计值(如均值、中位数)以后，使用列的统计值来填充该列的缺失值。\n使用统计值进行填充可以保持数据的整体分布特征。\n\n# 使用均值填充缺失值\nmean_value = df['Value'].mean()\ndf['Value'].fillna(mean_value, inplace=True)\n\n\n\n4. 使用插值方法进行填充\n对于连续的时间数据，我们可以尝试根据一致的数据点之间的关系来推断缺失数据点的值。这样的方法，就叫做插值填充。\n插值填充的方法适用于时间序列数据中缺失值相对较少且数据之间存在一定连续性的情况，比如在温度、股价等数据的处理中较为常用。\n\n# 使用插值方法对缺失值进行估算\ndf['Value'].interpolate(inplace=True)"
  },
  {
    "objectID": "04_07_时间序列数据.html#六时间序列的计算和操作",
    "href": "04_07_时间序列数据.html#六时间序列的计算和操作",
    "title": "13  Pandas处理时间序列数据",
    "section": "六、时间序列的计算和操作",
    "text": "六、时间序列的计算和操作\n\n1. 平移时间序列数据\n平移时间序列数据是指将时间序列沿时间轴前移或后移一定的时间单位。在Pandas中，可以使用.shift()方法来实现平移操作。通过指定正数表示向前平移，负数表示向后平移。\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据\ntemperatures = pd.Series([23, 25, 24, 22, 20],\n                         index=pd.date_range('2023-07-01', periods=5, freq='D'))\n\n# 向前平移一天\nshifted_temperatures = temperatures.shift(1)\nprint(shifted_temperatures)\n\n2023-07-01     NaN\n2023-07-02    23.0\n2023-07-03    25.0\n2023-07-04    24.0\n2023-07-05    22.0\nFreq: D, dtype: float64\n\n\n\n\n2. 计算时间差\n计算时间差是指计算两个时间点之间的时间间隔。在Pandas中，可以使用时间戳索引之间的差异来计算时间差。计算结果可以是时间间隔（Timedelta）类型。\n\n要注意，在计算时间差时，要首先将 DatetimeIndex 对象转换为 TimedeltaIndex 对象\n\n\nimport pandas as pd\n\n# 创建示例时间戳索引\ntimestamps = pd.to_datetime(['2023-07-01', '2023-07-05', '2023-07-10'])\n\n# 计算时间差\ntime_diff = timestamps.to_series().diff()\nprint(time_diff)\n\n2023-07-01      NaT\n2023-07-05   4 days\n2023-07-10   5 days\ndtype: timedelta64[ns]\n\n\n\n\n3. 统计和聚合操作\n时间序列数据常常需要进行统计和聚合操作，以了解数据的趋势、周期性和总体特征。在Pandas中，可以使用各种统计函数和聚合函数对时间序列进行操作，例如求和、平均值、最大值、最小值等。\n\nimport pandas as pd\n\n# 创建一个示例时间序列数据，表示每天的销售额\nsales = pd.Series([1000, 1200, 900, 1100, 1300],\n                  index=pd.date_range('2023-07-01', periods=5, freq='D'))\n\n# 计算销售额的总和、平均值和最大值\ntotal_sales = sales.sum()\naverage_sales = sales.mean()\nmax_sales = sales.max()\n\nprint(total_sales, average_sales, max_sales)\n\n5500 1100.0 1300"
  },
  {
    "objectID": "04_08_文本数据.html",
    "href": "04_08_文本数据.html",
    "title": "14  Pandas处理文本数据",
    "section": "",
    "text": "Pandas处理文本数据\nPandas中的文本数据对象是指包含字符串数据的Series或DataFrame中的列。可以通过指定dtype=\"string\"来创建文本数据对象，或者通过从现有的列或数据源进行转换来创建。文本数据对象具有特殊的方法和属性，可用于在文本数据上执行字符串处理操作。"
  },
  {
    "objectID": "04_08_文本数据.html#一字符串处理函数",
    "href": "04_08_文本数据.html#一字符串处理函数",
    "title": "14  Pandas处理文本数据",
    "section": "一、字符串处理函数",
    "text": "一、字符串处理函数\n\n1. 字符串拆分和连接\nPandas可以通过如下函数处理字符串的拆分与连接：\n\n.split(): 将字符串拆分为多个子字符串，并返回一个包含拆分结果的列表。\n.join(): 将字符串列表或Series中的多个字符串连接成一个字符串。\n.str.split(): 在Series或DataFrame的字符串列上进行拆分操作，并返回一个包含拆分结果的Series或DataFrame。\n\n\nimport pandas as pd\n\n# 创建一个示例字符串列\nnames = pd.Series(['John Smith', 'Jane Doe', 'Mike Johnson'])\n\n# 将字符串拆分为姓和名两列\nsplit_names = names.str.split(' ')\nprint(split_names)\n\n0      [John, Smith]\n1        [Jane, Doe]\n2    [Mike, Johnson]\ndtype: object\n\n\n\n# 将拆分后的姓和名连接为一个字符串\njoined_names = split_names.str.join('-')\nprint(joined_names)\n\n0      John-Smith\n1        Jane-Doe\n2    Mike-Johnson\ndtype: object\n\n\n\n\n2. 字符串匹配和查找\nPandas可以通过如下函数处理字符串的匹配和查找：\n\n.contains(): 检查字符串是否包含指定的子字符串，并返回布尔值。\n.match(): 使用正则表达式对字符串进行匹配，返回匹配的结果。\n.find(): 查找字符串中第一个匹配子字符串的起始位置，并返回索引。\n.findall(): 查找字符串中所有匹配的子字符串，并返回一个列表。\n\n\nimport pandas as pd\n\n# 创建一个示例字符串列\nsentences = pd.Series(['Hello, world!', 'How are you?', 'Python is great'])\n\n# 检查字符串中是否包含指定子字符串\ncontains_world = sentences.str.contains('world')\nprint(contains_world)\n\n0     True\n1    False\n2    False\ndtype: bool\n\n\n\n# 使用正则表达式匹配字符串\nmatches = sentences.str.match(r'[A-Z][a-z]+')\nprint(matches)\n\n0    True\n1    True\n2    True\ndtype: bool\n\n\n\n# 查找字符串中第一个匹配子字符串的起始位置\nfirst_index = sentences.str.find('great')\nprint(first_index)\n\n0    -1\n1    -1\n2    10\ndtype: int64\n\n\n\n# 查找字符串中所有匹配的子字符串\nall_matches = sentences.str.findall(r'\\b\\w+\\b')\nprint(all_matches)\n\n0         [Hello, world]\n1        [How, are, you]\n2    [Python, is, great]\ndtype: object\n\n\n\n\n3. 字符串替换和删除\nPandas可以通过如下函数处理字符串的替换和删除：\n\n.replace(): 替换字符串中的指定子字符串为新的子字符串。\n.str.replace(): 在Series或DataFrame的字符串列上进行替换操作。\n.strip(): 去除字符串两端的空格或指定的字符。\n.str.strip(): 在Series或DataFrame的字符串列上进行去除操作。\n.str.replace(): 删除字符串中的指定子字符串。\n.str.strip(): 在Series或DataFrame的字符串列上进行删除操作。\n\n\nimport pandas as pd\n\n# 创建一个示例字符串列\ntext = pd.Series(['  Hello,  ', '  How are you?  ', '  Python is great  '])\n\n# 去除字符串两端的空格\ntrimmed_text = text.str.strip()\nprint(trimmed_text)\n\n\n0             Hello,\n1       How are you?\n2    Python is great\ndtype: object\n\n\n\n# 替换字符串中的指定子字符串\nreplaced_text = text.str.replace('great', 'awesome')\nprint(replaced_text)\n\n0                 Hello,  \n1           How are you?  \n2      Python is awesome  \ndtype: object\n\n\n\n# 删除字符串中的指定子字符串\nremoved_text = text.str.replace(' ', '')\nprint(removed_text)\n\n0           Hello,\n1       Howareyou?\n2    Pythonisgreat\ndtype: object"
  },
  {
    "objectID": "04_08_文本数据.html#二正则表达式操作",
    "href": "04_08_文本数据.html#二正则表达式操作",
    "title": "14  Pandas处理文本数据",
    "section": "二、正则表达式操作",
    "text": "二、正则表达式操作\n\n1. 正则表达式基础知识\n在Pandas中，正则表达式（Regular Expression）是一种强大的工具，用于处理和操作文本数据。Pandas提供了多个函数和方法，可以使用正则表达式对文本数据进行匹配、查找、替换等操作。\n正则表达式（Regular Expression）是一种用于描述字符模式的表达式。它是一种强大的工具，用于在文本中搜索、匹配和处理特定模式的字符串。正则表达式由一个或多个字符和特殊符号组成，它们形成了一种规则，用于描述所需的字符串模式。\n正则表达式的工作原理是通过与输入字符串逐字符匹配，尝试找到与模式匹配的字符串。它使用不同的元字符（Metacharacters）和字符类（Character classes）来表示不同的模式。以下是一些常用的元字符和字符类：\n\n(1) 元字符：\n\n.：匹配任意单个字符，除了换行符。\n*：匹配前面的字符零次或多次。\n+：匹配前面的字符一次或多次。\n?：匹配前面的字符零次或一次。\n|：用于分隔多个模式，表示或的关系。\n()：用于分组和捕获匹配的子字符串。\n\n\n\n(2) 字符类：\n\n[abc]：匹配字符a、b或c中的任意一个。\n[a-z]：匹配任意小写字母。\n[0-9]：匹配任意数字字符。\n[^abc]：匹配除了字符a、b和c之外的任意字符。\n\n正则表达式的匹配过程是从左到右逐字符进行的。它尝试在目标字符串中找到与模式完全匹配的子字符串。如果找到匹配，就可以执行相应的操作，如提取、替换、删除等。正则表达式还支持更复杂的模式匹配，如重复次数、边界限定、转义字符等。\n在Python中，正则表达式的使用通常使用re模块。该模块提供了许多函数和方法，用于对字符串进行正则表达式的匹配和处理。\n总而言之，正则表达式是一种强大的字符串匹配和处理工具，它通过使用特定的符号和语法规则，描述所需的字符串模式，并可以在文本中进行搜索、匹配和处理。\n\n\n\n2. Pandas中的正则表达式操作\n\n(1) .str.match() 方法：\n.str.match() 方法用于对字符串列应用正则表达式进行匹配操作，返回匹配结果。只返回第一个匹配项。\n\nimport pandas as pd\n\n# 创建一个示例字符串列\nnames = pd.Series(['John', 'Jane', 'Mike'])\n\n# 使用正则表达式匹配以J开头的名字\nmatches = names.str.match(r'J\\w+')\nprint(matches)\n\n0     True\n1     True\n2    False\ndtype: bool\n\n\n\n\n(2) .str.contains() 方法：\n.str.contains() 方法用于检查字符串列中是否包含匹配正则表达式的子字符串，并返回布尔值。\n\nimport pandas as pd\n\n# 创建一个示例字符串列\nsentences = pd.Series(['Hello, world!', 'How are you?', 'Python is great'])\n\n# 检查字符串列是否包含以w结尾的单词\ncontains_w = sentences.str.contains(r'\\b\\w+w\\b')\nprint(contains_w)\n\n0    False\n1     True\n2    False\ndtype: bool\n\n\n\n\n(3).str.extract() 方法：\n.str.extract() 方法用于从字符串列中提取满足指定正则表达式模式的子字符串，并返回一个新的列或DataFrame。\n\nimport pandas as pd\n\n# 创建一个示例字符串列\nsentences = pd.Series(['John is 25 years old', 'Jane is 30 years old'])\n\n# 提取字符串中的年龄\nages = sentences.str.extract(r'(\\d+) years')\nprint(ages)\n\n    0\n0  25\n1  30\n\n\n\n\n(4).str.replace() 方法：\n.str.replace() 方法用于替换字符串列中匹配正则表达式的子字符串为指定的字符串。\n\nimport pandas as pd\n\n# 创建一个示例字符串列\nsentences = pd.Series(['Hello, world!', 'How are you?', 'Python is great'])\n\n# 将字符串中的逗号替换为空格\nreplaced = sentences.str.replace(',', ' ')\nprint(replaced)\n\n0      Hello  world!\n1       How are you?\n2    Python is great\ndtype: object"
  },
  {
    "objectID": "04_08_文本数据.html#三文本数据的分组和聚合",
    "href": "04_08_文本数据.html#三文本数据的分组和聚合",
    "title": "14  Pandas处理文本数据",
    "section": "三、文本数据的分组和聚合",
    "text": "三、文本数据的分组和聚合\n\n1. 分组操作概述\n在Pandas中，分组（Grouping）是一种常用的数据操作，用于将数据根据某个标准分成多个组，并在每个组上进行进一步的操作。分组操作可以应用于各种数据类型，包括文本数据。\n首先，让我们概述一下分组操作的基本流程：\n\n分组依据：选择一个或多个列作为分组依据。这些列的值将用于对数据进行分组。\n分组创建：根据分组依据，将数据分成多个组。每个组由具有相同值的分组依据列形成。\n分组操作：对每个组进行操作，如聚合、计算统计量、过滤数据等。\n结果合并：将每个组的结果合并为一个新的数据结构，通常是一个新的DataFrame。\n\n\n\n2. 文本数据的分组和聚合操作\n在文本数据中，分组和聚合操作可以用于计算字符串的长度、计数特定单词的出现次数、找到具有最长或最短字符串的组等。下面介绍一些常见的文本数据的分组和聚合操作：\n\n(1).groupby() 方法：\n.groupby() 方法用于按照指定的列或多个列对数据进行分组。它返回一个GroupBy对象，表示按照指定列进行分组后的数据。\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndf = pd.DataFrame({\n    'Name': ['John', 'Jane', 'Mike', 'Emily', 'John'],\n    'City': ['New York', 'Paris', 'London', 'Paris', 'London'],\n    'Age': [30, 25, 40, 35, 28]\n})\n\n# 按照City列进行分组\ngrouped = df.groupby('City')\nprint(grouped)\n\n&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001D3F4659310&gt;\n\n\n\n\n(2) 分组聚合操作\n通过GroupBy对象，可以应用各种聚合函数来对每个组的数据进行汇总。一些常用的聚合函数包括：\n\n.count()：计算每个组中的元素个数。\n.sum()：计算每个组中数值列的总和。\n.mean()：计算每个组中数值列的平均值。\n.max()、.min()：计算每个组中数值列的最大值和最小值。\n.size()：计算每个组中的元素数量\n\n\nimport pandas as pd\n\n# 创建一个示例DataFrame\ndf = pd.DataFrame({\n    'Name': ['John', 'Jane', 'Mike', 'Emily', 'John'],\n    'City': ['New York', 'Paris', 'London', 'Paris', 'London'],\n    'Age': [30, 25, 40, 35, 28]\n})\n\n# 按照City列进行分组，并计算每个城市的平均年龄和人数\ngrouped = df.groupby('City')\naverage_age = grouped['Age'].mean()\ncount = grouped['Age'].count()\n\nprint(f\"平均年龄：\")\nprint(average_age)\n\n\n平均年龄：\nCity\nLondon      34.0\nNew York    30.0\nParis       30.0\nName: Age, dtype: float64\n\n\n\nprint(f\"平均人数：\")\nprint(count)\n\n平均人数：\nCity\nLondon      2\nNew York    1\nParis       2\nName: Age, dtype: int64\n\n\n\n\n(3)其他分组操作：\n\n.apply()：在每个组上应用自定义函数。\n.filter()：根据自定义条件过滤组。\n.transform()：对每个组应用函数，并将结果返回到原始数据的相应位置。"
  },
  {
    "objectID": "05_01_爬虫基础.html",
    "href": "05_01_爬虫基础.html",
    "title": "15  爬虫基础",
    "section": "",
    "text": "爬虫基础"
  },
  {
    "objectID": "05_01_爬虫基础.html#爬虫的基本概念",
    "href": "05_01_爬虫基础.html#爬虫的基本概念",
    "title": "15  爬虫基础",
    "section": "爬虫的基本概念",
    "text": "爬虫的基本概念\n爬虫，即一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。\n根据爬虫的定义，很容易联想到各类浏览器、搜索引擎，我们日常生活中使用浏览器搜索网站，也可以看作是在使用爬虫爬取信息。只不过，浏览器的搜索结果往往是一整个网页，而我们常常只需要网页中特定的内容。比如，当我们想要获取当前电影市场上评分最高的 250 部电影，我们可以使用浏览器进行搜索。、\n爬虫，即抓取互联网信息的自动化程序。借助爬虫，我们可以从互联网上抓取对于我们有价值的信息。\n我们很容易从爬虫的定义联想到各类浏览器，似乎我们日常中使用浏览器所进行的搜索活动，与爬虫的工作差不多。这样的想法并没有错，浏览器搜索网站的过程，也可以看作是在使用爬虫获取信息。只不过，浏览器往往会将所有的网页信息都获取下来，而我们常常只需要网页中的特定内容。比如，假设我需要获取当前豆瓣电影网站上，评分最高的 250 部电影的信息，使用浏览器进行搜索时，结果常常是这样的：\n\n\n\n豆瓣电影_TOP250\n\n\n仔细观察搜索结果，我们会发现，在这个页面中，除了我们想要的电影信息，还有许多不相干的元素，比如页面右边的各种口碑榜、票房榜等等，而我们只需要电影的相关信息。因此，我们可以尝试使用爬虫来从该页面中获取到我们想要的电影信息（电影的名称、排行、评分、评价人数、影评），并且整理成为如下图所示的表格。\n\n\n\n爬取结果\n\n\n\n一、爬虫的概念\nPython 爬虫从本质上来说，就是一种自动化程序，被设计用来在互联网上获取特定的信息。它模仿人类在网页上进行浏览的行为，可以在短时间内处理大量的网页和数据。Python 爬虫通常可以用于从网页中抓取数据、分析信息、搜索特定内容等场景。\n这样一来，我们似乎整理出了爬虫程序的基本运行方式，即：\n\n请求库(HTTP 请求)：首先，爬虫使用 HTTP 请求库 requests 获取网页的 HTML 源代码。\n网页解析：接下来，使用 HTML 解析库 BeautifulSoup 对获取到的网页源代码进行解析。\n数据提取：使用标签解析、XPath、CSS 选择器来从 HTML 源代码中提取所需的数据。\n数据存储：最后，将提取到的数据存储在本地文件、数据库或其他的数据存储方式中。\n\n\n\n\n\ngraph LR\n\nid1(发送 HTTP 请求) --&gt; id2(网页解析) --&gt; id3(数据提取) --&gt; id4(数据存储)\n\n\n\n\n\n根据爬虫的基本运作方式，我们也就了解了学习爬虫的一般步骤。首先，我们要了解什么是 HTTP 请求，什么是 HTML 文档。随后，我们就可以开始学习如何使用 HTTP 请求库来获取网页的基本数据。最后，我们再掌握解析网页数据，并从中提取关键信息的方法。另外，为了更高效地获取数据，简化爬虫的开发过程，我们还将了解主流的爬虫框架，学习其构成及使用方法。\n\n\n二、爬虫伦理\n为了在使用爬虫时不触犯法律风险，我们就需要了解爬虫伦理。\n爬虫伦理是指在进行网络爬虫任务时应遵循的道德和法律规范。因为爬虫可能会对目标网站产生一定的影响，开发者应该遵循以下几个伦理原则：\n\n尊重网站规则\n避免过度请求\n尊重隐私\n遵循法律法规\n避免滥用\n保护目标网站\n\nrobots.txt 文件\nrobots.txt 文件是一个用于指导网络爬虫如何爬取以及是否允许爬取网站内容的标准文件，这个文件通常位于网站的根目录下。\n我们可以打开任意一个网站的根目录，在其域名后添加 /robots.txt 来访问。\n下面是一个简单的 robots.txt 文件示例：\n\n这个文件的结构为：\nUser-agent：这个部分指定了要针对哪个爬虫或用户代理设置规则。通常使用一个星号 * 来表示适用于所有爬虫，或者指定爬虫的名称或代号。\nDisallow：这个部分规定了爬虫不允许访问的页面或目录。例如，Disallow: /private/ 表示不允许爬虫访问以 /private/ 开头的所有页面。\nAllow：与Disallow相对应，这个部分规定了允许访问的页面或目录。通常不是所有的爬虫都支持这个指令。\nCrawl-delay：这个部分指定了爬虫爬取网站页面的延迟时间，以秒为单位。例如，Crawl-delay: 5 表示爬虫每隔5秒才能请求一个页面。"
  },
  {
    "objectID": "05_01_爬虫基础.html#链接解析",
    "href": "05_01_爬虫基础.html#链接解析",
    "title": "15  爬虫基础",
    "section": "链接解析",
    "text": "链接解析\nURL，也就是我们常说的网址，它的正式名称是“统一资源定位符”，它是互联网上的路标，指向了我们所需要的资源。因此，要学习爬虫，就要了解什么是 URL。我们把一个网址分成四个部分来说明，以 https://movie.douban.com/top250?filter=unwatched 为例，分别是：\n\n安全传输协议：https://\n主域名：movie.douban.com\n子链接：/top250\n筛选规则：?filter=unwatched\n\n\n一、传输协议\n\n1. HTTP 的概念\n首先，让我们一起来了解一下，什么是 HTTP 协议。\n在前面对爬虫的介绍中，我们讲到，爬虫程序会模拟人类的行为，向浏览器发送请求，与服务器建立连接。在这一步中，与服务器建立连接的行为，就使用到了 HTTP 协议。\nHTTP 即 Hypertext Transfer Protocol(超文本传输协议)，是一种用于在客户端与服务器之间的传输数据的请求 - 响应协议。比如，我们在浏览网页时，浏览器与服务器之间遵循的传输协议，通常就是 HTTP 协议。\nHTTP 通常会显示不安全，例如 http://www.moe.gov.cn/，如果网站受到攻击，密码容易泄露。\n\n随着互联网的不断发展，HTTP 协议正在逐渐被淘汰，HTTPS 协议已成为越来越多网站的标配，为用户提供更为安全和可靠的网络环境。\n\n\n\n\ngraph LR\nid1(客户端) -- HTTP 协议 --&gt; id2(服务器)\n\n\n\n\n\n\n\n\n2. HTTP 的请求与响应\n\n(1) HTTP 请求\n客户端要使用 HTTP 协议向服务器发送请求，就要遵循 HTTP 的请求方法。HTTP 协议支持多种请求方法以实现获取数据、创建数据、删除数据等功能。在爬虫中，最常用的就是 GET 方法。\nGET 方法主要用于获取数据，比如当我们浏览某一个网页时，浏览器就会像服务器发送 GET 请求，用以获取页面数据。\n一个 HTTP 请求通常由请求行、请求头、请求体三个部分组成，其中，请求体常常用来向服务器传输数据，因此 GET 方法，通常没有请求体。下面是一个 GET 请求的示例。\n\nGET /top250 HTTP/1.1&lt;!-- 请求行(Request Line) --&gt;\nHost: movie.douban.com&lt;!-- 请求头(Request Headers) --&gt;\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Language: en-US,en;q=0.9\nConnection: keep-alive\n&lt;!-- 空行 --&gt;\n&lt;!-- 请求体(Request Body)--&gt;\n\n在上面的例子中，HTTP 请求的结构如下：\n\n请求行(Request Line)\n\n请求方法：GET\n资源路径：/top250\n协议版本：HTTP/1.1\n\n请求头(Request Headers)\n\n主机名(Host)：movie.douban.com\nUser-Agent：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36\n可以接受的响应内容类型(Accept)：text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n语言首选项(Accept-Language)：en-US,en;q=0.9\n连接状态(Connection)：keep-alive\n\n空行(Blank Line)：空行用于分隔请求头部和请求体。\n请求体(Request Body)：GET 请求通常没有请求体，因此此处为空。\n\n\n\n\n\ngraph LR\nid1(HTTP 请求) --&gt; id2(请求行)\nid1 --&gt; id3(请求头)\nid1 --&gt; id4(请求体)\n\n\n\n\n\n\n\n\n(2) HTTP 响应\n当服务器接收到客户端发出的 HTTP 请求后，会根据请求返回 HTTP 响应。类似的，HTTP 响应也由三个部分组成：状态行、响应头、响应体。观察下面的例子，这是一个完整的 HTTP 响应。\n\nHTTP/1.1 200 OK&lt;!-- 状态行(Status Line) --&gt;\nDate: Sat, 28 Aug 2023 12:00:00 GMT&lt;!-- 响应头(Response Headers) --&gt;\nServer: Apache/2.4.41 (Unix)\nContent-Type: text/html; charset=UTF-8\nContent-Length: 1234\nConnection: keep-alive\n\n&lt;!DOCTYPE html&gt;&lt;!-- 响应体(Response Body) --&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;title&gt;Welcome to Example.com&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1&gt;Hello, World!&lt;/h1&gt;\n    &lt;p&gt;This is an example HTML page.&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n这个 HTTP 响应的结构如下：\n\n状态行(Status Line)\n\n协议版本：HTTP/1.1\n响应状态码：200 OK\n\n响应头(Response Headers)\n\n时间日期(Date)：Sat, 28 Aug 2023 12:00:00 GMT\n服务器软件信息(Server)：Apache/2.4.41 (Unix)\n响应内容类型(Content-Type)：text/html; charset=UTF-8\n响应体长度(Content-Length)：1234\n连接状态(Connection)：keep-alive\n\n空行(Blank Line)：空行用于分隔响应头和响应体。\n响应体(Response Body)：响应体包含了服务器返回的 HTML 内容，即页面的结构和内容。\n\n\n\n\n\ngraph LR\nid1(HTTP 响应) --&gt; id2(状态行)\nid1 --&gt; id3(响应头)\nid1 --&gt; id4(响应体)\n\n\n\n\n\n关于服务器返回的 HTTP 响应，需要格外注意的是状态行中的响应状态码，它代表了服务器对客户端的请求的响应状态。状态码共分为五类：\n\n1xx(信息性状态码)\n2xx(成功状态码)\n3xx(重定向状态码)\n4xx(客户端错误状态码)\n5xx(服务器错误状态码)\n\n下面的表格中给出了常见的 HTTP 状态码及其含义：\n\n\n\n状态码\n含义\n\n\n\n\n200 OK\n客户端请求成功\n\n\n201 Moved Permanently\n资源被永久移动到新地址\n\n\n400 Bad Request\n客户端不能被服务器所理解\n\n\n401 Unauthorized\n请求未经授权\n\n\n403 Forbidden\n服务器拒绝提供服务\n\n\n404 Not Found\n请求资源不存在\n\n\n500 Internal Server Error\n服务器发生不可预期的错误\n\n\n503 Service Unavailable\n服务器当前不能处理客户端的请求\n\n\n\n\n\n\n\n二、域名与资源\n前面我们已经了解到，URL 就是指向互联网资源的路标，给浏览器一个 URL 就可以定位到网络上的一个资源。刚才我们解析了网址 https://movie.douban.com/top250?filter=unwatched 开头的传输协议部分 https，现在，让我们一起来看看后面的路径部分。\n就像我们电脑上的文件地址一样，URL 的功能就是在网络上对一个资源进行定位。你可以将一个网址拆分成几部分，并且向理解电脑上的文件地址一样理解它。\n对于网址 https://movie.douban.com/top250?filter=unwatched，我们可以这样来看，比如在你的 Windows 电脑中，你的用户文件夹下，有一个名为 “MyDocuments” 的文件夹，这个文件夹下有一个名为 “report.docx” 的文件，那么它的路径就是：“C:.docx”。\n现在让我们试着类比：\n\n协议：在 URL 最前面的协议部分，可以理解为我们电脑上文件的“打开方式”，只有用文件支持的打开方式才能打开它，同理，只有遵循网址的通讯协议，才能与其建立连接。\n主域名：www.douban.com 这部分就是域名，它类似于文件的文件路径的主文件夹，就是 “C:” 部分。\n子域名：www.movie.douban.com 就是 URL 的子域名，它就像主文件夹下面的子文件夹，就是 “” 这一部分。\n资源路径：/top250 就是网络上的资源路径，它指向了网站 www.movie.douban.com 下的一个榜单：电影 TOP250，就像文件的具体位置一样 “.docx”。\n查询参数：?filter=unwatched 就是文件的查询参数，它用于筛选特定的内容，就像电脑上文件的附加信息一样。\n\n让我们一起跟着这个比喻，来看看域名与资源的关系。\n\n1. 域名\n现在，让我们以 www.movie.douban.com 为例来解释域名的结构。\n和我们日常生活中的阅读习惯不同，域名的阅读是从右到左进行的。其结构为：\n\n顶级域名：.com\n二级域名：.douban\n二级域名的子部分：.movie\n子域名：www\n\n这个网址共有以上四个组成部分。让我们一个个来看：\n\n(1) 顶级域名\n顶级域名 .com 是一个通用顶级域名，通常与商业网站相关。我们在《流浪地球 2》中看到的根服务器，就是用来存放和维护顶级域名的。顶级域名是互联网中最高层次的域名，一般位于 URL 的最右侧。顶级域名通常由国际组织、国家或地区的注册机构进行管理，并根据其用途分为不同的类别。以下是一些常见的顶级域名：\n\n通用顶级域名\n\n.com：通用商业顶级域名，用于商业网站。\n.org：通用组织顶级域名，用于非盈利组织。\n.net：通用网络顶级域名，用于与互联网和网络服务相关的机构。\n.gov：通用政府顶级域名，用于政府机构。\n.edu：通用教育顶级域名，用于教育机构\n\n国家和地区代码顶级域名\n\n.cn：中国的顶级域名\n.us：美国的顶级域名\n\n\n了解一些常见的顶级域名，可以让我们在看到一个 URL 时就大概知道其用途。\n\n\n(2) 二级域名\n在上面的示例中，.douban 就是一个二级域名。二级域名通常表示特定的组织、公司、网站或服务。例如，.douban 就由豆瓣公司掌握，.zhihu 就由中文知识社区知乎掌握。\n\n\n(3) 二级域名的子部分\n这一部分比较特殊，在上面的 URL 中，我们可以看到，除了常见的顶级域名 .com，二级域名 .douban，子域名www，还有一个部分，就是 .movie。.movie 在这里是 .douban.com 域名的一个子域名，代表了豆瓣网站中的电影板块。这样的作法可以使网站的功能划分更为明确。但是要注意，如果 .movie 在 URL 的最右侧，那么它代表的就是一个通用顶级域名，表示电影相关的网站。\n\n\n(4) 子域名\n子域名就是 URL 最左侧的部分 www，它表示世界范围内的万维网服务，是访问网站的标准方式。\n将上面的四个部分合并起来，就是主域名：www.movie.douban.com。这个 URL 告诉我们：\n\n它是一个位于 .com 顶级域名下的域名；\n它的名称是 douban，归属于一个特定的公司；\n它提供的服务是 movie，表示电影板块；\n它的访问方式是 www，属于万维网的一部分。\n\n\n\n\n2. 查询参数\n网站的查询参数是用于在 URL 中传递额外信息或数据的一种方式，通常位于 UTL 的末尾，以便向服务器发送请求时提供特定的参数或选项。上面示例中的 ?filter=unwatched，就是查询参数，表示未观看过的电影。\n要知道网站支持哪些查询参数，通常只有两种方法，一种是得到网站官方的支持，比如阅读其官方文档或联系网站支持；另一种是总结归纳，通过自己或其他开发者的归纳，来获取网站支持的查询参数。"
  },
  {
    "objectID": "05_02_HTML文档与Requests库.html#html-文档",
    "href": "05_02_HTML文档与Requests库.html#html-文档",
    "title": "16  HTML 文档与 Requests 库",
    "section": "HTML 文档",
    "text": "HTML 文档\n\n一、HTML 的概念\n一个网页通常由以下三大技术要素组成：\n\nCSS：定义网页的样式\nHTML：定义网页的结构和信息\nJavaScript：定义用户和网页的交互逻辑\n\n\n\n\n\ngraph LR\nid1(网页源代码) --&gt; id2(CSS: 网页的样式)\nid1 --&gt; id3(HTML: 网页的结构和信息)\nid1 --&gt; id4(JavaScript: 用户和网页的交互逻辑)\n\n\n\n\n\n由于我们在爬取数据时，主要关心的是网页上面的信息，我们主要学习 HTML。\nHTML(HyperText Markup Language)即超文本标记语言，是一种用于创建和组织网页内容的标记语言。它被广泛应用于 Web 开发中，是互联网上最基本的构建块之一，用于描述网页上的文本、图像、链接、表格、多媒体和其他元素的结构和外观。HTML使用标记（标签）来定义文档的结构和内容，这些标记可以通过Web浏览器解释和渲染，以便用户查看和与之交互。\n在学习 HTML 文档时，我们首先要记住的概念就是，HTML 是一种标记语言，它使用一系列的标签(由尖括号 &lt;&gt; 括起来)来标记文档的各个部分，如标题、段落、图像等。\n随机打开一个网页，在页面上单击右键，选择查看网页源代码，你就可以看到一个网页的源码是如撰写的。比如，我们打开必应 (bing.com)，在打开其网页源代码，就可以看到如下所示的界面：\n\n\n\n网页源代码\n\n\n仔细观察这个页面，你会发现其中有许许多多的标签，这些标签共同构成了这个页面，其中，网页的 HTML 通常位于 &lt;html&gt; 标签之间，包含网页的整体结构，主要有 &lt;head&gt; 和 &lt;body&gt; 部分；CSS 通常位于 &lt;style&gt; 标签内，或者作为外部样式表文件链接到 HTML 页面中；JavaScript 通常位于 &lt;script&gt; 标签内，也可以作为外部 JavaScript 文件链接到 HTML 页面之中。\n\n\n\n\n\n\nNote\n\n\n\n文本与超文本\n\n文本（Text）\n\n\n文本是一种线性的、有序的信息传递方式。它通常指代书写、打印或输入的字母、数字和符号组成的字符串。\n文本只包含基本字符，没有多样的格式或媒体元素。\n在计算机领域，文本通常指代不包含多媒体内容、链接或其他互动元素的字符数据。\n\n\n超文本（Hypertext）\n\n\n超文本是一种非线性的、互动的信息传递方式。它不仅包含文本内容，还包括可以链接到其他文档、网页、图像、视频等媒体的超链接。\n超文本具有更丰富的表现形式，可以通过链接实现跳转、导航和互动。\n在计算机领域，超文本通常指代包含超链接的内容，这些超链接可以将用户引导到相关的信息或资源。\n\n总的来说，文本强调线性、顺序式的信息传递，而超文本强调非线性、互动式的信息传递，通过链接实现了内容的关联性和丰富性。Web 中的超文本是基于 HTML 构建的，通过超链接和其他元素，使用户能够在不同的网页和资源之间进行自由导航和交互。\n\n\n让我们一起来看看一个简单的 HTML 示例：\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;简单的网页示例&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1&gt;欢迎来到我的网页&lt;/h1&gt;\n    &lt;p&gt;这是一个简单的HTML示例，用于展示基本的网页结构和元素。&lt;/p&gt;\n    &lt;p&gt;你可以点击下面的链接跳转到其他网页：&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a href=\"https://python.pypandas.com/\"&gt;示例链接1&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"https://movie.douban.com/top250\"&gt;示例链接2&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n上面的示例中，用 &lt;&gt; 括起来的内容，就是 HTML 的标签。尝试将上面的示例代码输入到记事本中保存，并将文件后缀修改为 .html，这样我们就得到了一个带有相应内容的网页，将其在浏览器中打开，观察其中的元素与代码之间的联系。你还可以尝试修改一下代码的内容，自定义你的第一个网页。\n浏览器渲染网页时，会把 HTML 源码解析成一个标签树，每个标签都是树的一个节点(node)。这种节点就称为网页元素(element)。所以，“标签”和“元素”基本上是同义词，只是使用的场合不一样：标签是从源码角度来看，元素是从编程角度来看，比如 &lt;p&gt; 标签对应网页的 p 元素。\n这个示例具有一个网页的基本结构，让我们一起来观察一下这个简单的示例代码，看看 HTML 文档的基本组成部分。\n\n&lt;!DOCTYPE&gt; 声明\n\n&lt;!DOCTYPE&gt; 声明通常是网页的第一个标签，定义文档的类型和版本，告诉浏览器如何解析网页。默认情况下，只需要简单声明 doctype 为 html 即可，浏览器会按照 HTML 5 的规则解析网页。\n\n&lt;html&gt;\n\n&lt;html&gt; 是文档的根元素，网页的顶层容器，一个网页只能有一个 &lt;html&gt; 标签，该标签包含了整个HTML文档，其他元素都是它的子元素。\n\n&lt;head&gt;\n\n&lt;head&gt; 标签包含文档的元信息，如标题、字符编码和链接到外部资源的信息，该标签的内容不会出现在网页上。&lt;head&gt; 标签是 &lt;html&gt; 标签下的第一个子元素，如果网页不包含 &lt;head&gt;，浏览器将会自动创建一个。\n\n&lt;meta&gt;\n\n用于设置或说明网页的元数据，必须放置在 &lt;head&gt; 标签里。一个 &lt;meta&gt; 标签就是一项元数据，一个网页可以有多个 &lt;meta&gt; 标签。一般来说，&lt;meta&gt; 标签放置在 &lt;head&gt; 的最前面。\n\n&lt;title&gt;\n\n&lt;title&gt; 标签定义文档的标题，显示在浏览器的标题栏或标签页上，该标签内部不能再放置其他标签，只能放置无格式的纯文本。\n\n&lt;body&gt;\n\n&lt;body&gt; 标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，如文本、图像、链接等，都放置在它的内部。它是 &lt;html&gt; 的第二个子元素，紧跟在 &lt;head&gt; 后面。\n\n\n\n\n\n\n\ngraph TD\nid1(HTML 文档) --&gt; id2(&lt !DOCTYPE &gt 声明)\nid1 --&gt; id3(&lt html &gt)\nid3 --&gt; id4(&lt head &gt)\nid4 --&gt; id5(&lt meta &gt)\nid4 --&gt; id6(&lt title &gt)\nid4 --&gt; id7(...)\nid3 --&gt; id8(&lt body &gt)\nid8 --&gt; id9(&lt h &gt)\nid8 --&gt; id10(&lt p &gt)\nid8 --&gt; id11(&lt a &gt)\nid8 --&gt; id12(&lt img &gt)\nid8 --&gt; id13(&lt ul &gt)\nid8 --&gt; id14(&lt table &gt)\nid8 --&gt; id15(&lt form &gt)\nid8 --&gt; id16(...)\n\n\n\n\n\n标签通常成对出现，包括起始标签和闭合标签。例如，&lt;p&gt; 是表示段落的起始标签，&lt;/p&gt; 是表示段落的闭合标签。\n\n\n\n\n\n\nNote\n\n\n\n在 &lt;body&gt; 标签内部，我们可以使用各种各样的标签来定义页面中的不同元素，下面是一些常见元素的表示方法：\n\n标题： 使用 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt; 等标题标签定义页面的标题，标题按重要性逐级递减。\n段落： 使用 &lt;p&gt; 标签定义段落，用于包含文本段落。\n链接： 使用 &lt;a&gt; 标签定义链接，可以链接到其他页面、文件、位置等，我们日常使用的超链接，就是通过 &lt;a&gt; 标签定义的。\n图像： 使用 &lt;img&gt; 标签插入图像，需要指定图像的来源（URL）等信息。\n列表： 使用 &lt;ul&gt;（无序列表）和 &lt;ol&gt;（有序列表）定义列表，使用 &lt;li&gt; 定义列表项。\n表格： 使用 &lt;table&gt; 定义表格，使用 &lt;tr&gt; 定义表格行，使用 &lt;td&gt; 定义单元格。\n表单： 使用 &lt;form&gt; 定义表单，用于用户输入和提交数据。包含输入字段、按钮等。\n\n另外，在 HTML 文档中，注释的写法与 Python 并不一样，HTML 代码的注释以 &lt;!-- 开头，以 --&gt; 结尾，可以换行。\n&lt;!-- 这是一个注释 --&gt;\n\n&lt;!--\n  &lt;p&gt;hello world&lt;/p&gt;\n--&gt;\n\n\n如果你使用的是 Google Chrome 浏览器，也可以打开一个新标签页，根据我们前面所学的知识观察新标签页的源代码，并且尝试拆分他们。\n\n&lt;!doctype html&gt;\n&lt;html dir=\"ltr\" lang=\"zh\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;新标签页&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            background: #3C3C3C;\n            margin: 0;\n        }\n\n        #backgroundImage {\n            border: none;\n            height: 100%;\n            pointer-events: none;\n            position: fixed;\n            top: 0;\n            visibility: hidden;\n            width: 100%;\n        }\n\n        [show-background-image] #backgroundImage {\n            visibility: visible;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;iframe id=\"backgroundImage\" src=\"\"&gt;&lt;/iframe&gt;\n    &lt;ntp-app&gt;&lt;/ntp-app&gt;\n    &lt;script type=\"module\" src=\"new_tab_page.js\"&gt;&lt;/script&gt;\n    &lt;link rel=\"stylesheet\" href=\"chrome://resources/css/text_defaults_md.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"chrome://theme/colors.css?sets=ui,chrome\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"shared_vars.css\"&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n最后我们需要注意的是各个标签之间的层级关系。\n在上面的 HTML 示例中，仔细观察标签 &lt;body&gt; 中的内容，这些就是它的子元素。在 HTML 和 CSS 中，元素之间存在多种关系，其中两个重要的关系就是“父子元素”和“兄弟元素”。\n\n父子元素关系： 父子元素关系指的是一个元素包含在另一个元素的内部，形成了层级关系。在 HTML 中，这通常表示一个元素是另一个元素的子元素。例如：\n\n\n&lt;div&gt; &lt;!-- 这是父元素 --&gt;\n    &lt;p&gt;这是子元素&lt;/p&gt; &lt;!-- 这是子元素 --&gt;\n&lt;/div&gt;\n\n在这个例子中，&lt;div&gt; 元素是 &lt;p&gt; 元素的父元素，而 &lt;p&gt; 元素是 &lt;div&gt; 元素的子元素。子元素通常位于父元素的内部，并且可以通过嵌套来创建更复杂的结构。\n\n兄弟元素关系： 兄弟元素关系指的是位于同一父元素内的元素之间的关系，它们具有相同的父元素。例如：\n\n\n&lt;ul&gt; &lt;!-- 父元素 --&gt;\n    &lt;li&gt;Item 1&lt;/li&gt; &lt;!-- 这是兄弟元素 --&gt;\n    &lt;li&gt;Item 2&lt;/li&gt; &lt;!-- 这是兄弟元素 --&gt;\n    &lt;li&gt;Item 3&lt;/li&gt; &lt;!-- 这是兄弟元素 --&gt;\n&lt;/ul&gt;\n\n在这个例子中，&lt;li&gt; 元素之间就是兄弟元素，它们都是 &lt;ul&gt; 元素的子元素，并且具有相同的父元素。兄弟元素通常位于同一层次结构中，它们可以通过 CSS 选择器和 JavaScript 来选择和操作。\n\n\n\n\ngraph LR\nid1(HTMl) --&gt; id2(\"父元素1\\n(兄弟元素1)\")\nid2 --&gt; id3(兄弟元素2)\nid2 --&gt; id4(兄弟元素2)\nid1 --&gt; id5(\"父元素2\\n(兄弟元素1)\")\n\n\n\n\n\n\n\n二、使用 XPath 选取 HTML 元素\n要编写爬虫程序，抓取网页中特定的信息，就是要从 HTML 中选取出我们所需要的元素。通过上面的学习，我们掌握了 HTML 文档的构成，接下来，我们一起来看看如何从一个 HTML 网页中选取到我们想要的元素。\n我们已经知道了，HTML 由许许多多的标签组成。因此，我们要抓取特定的内容，也就要从标签下手。要在 HTMl 文档中定位和提取数据，我们可以使用 XPath 表达式或 CSS 表达式。\n我们首先来看看 XPath 表达式。\n\n1. XPath 的概念\nXPath 是一种用于在XML文档中定位和提取数据的查询语言。它广泛用于解析和操作XML文档，同时也适用于HTML文档，特别是在Web爬虫和数据抓取中。要使用 XPath，我们可以使用 lxml 库，它是一个用于处理XML和HTML文档的强大库，支持XPath查询。使用下面的代码安装它：\n\n!pip install lxml\n\n在本次学习中，我们以下面的 HTML 文档为示例，复制下面的代码，将其保存为一个 .html 文件。\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;title&gt;一个HTML文档&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1&gt;网页抓取示例&lt;/h1&gt;\n        &lt;nav&gt;\n            &lt;ul&gt;\n                &lt;li&gt;&lt;a href=\"https://jupyter.pydatacamp.com/hub/login\"&gt;开始练习吧！&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"https://pydatacamp.com/\"&gt;记得认真阅读文档！！&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"https://docs.qq.com/doc/DS1dFSVBCcndjbXNa\"&gt;记录你的问题~&lt;/a&gt;&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    &lt;/header&gt;\n\n    &lt;section id=\"content\"&gt;\n        &lt;article&gt;\n            &lt;h2&gt;文章1&lt;/h2&gt;\n            &lt;p&gt;这是第一篇文章。📃📃📃📃📃好多字呀！🔤🔣🔤🔣🔤&lt;/p&gt;\n        &lt;/article&gt;\n\n        &lt;article&gt;\n            &lt;h2&gt;文章2&lt;/h2&gt;\n            &lt;p&gt;这是第二篇文章。😆🎮➡️🦹👉📄✏️➡️🥹➡️😭➡️📝➡️🗒️🗒️🗒️🗒️🗒️➡️😫😫➡️😭😭➡️🥱🦥➡️🫣🙈🫣➡️😆🎮&lt;/p&gt;\n        &lt;/article&gt;\n    &lt;/section&gt;\n\n    &lt;aside&gt;\n        &lt;h3&gt;相关链接&lt;/h3&gt;\n        &lt;ul&gt;\n            &lt;li&gt;&lt;a href=\"https://zty.pe/\"&gt;要不要学习打字？&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"https://weread.qq.com/\"&gt;多多读书准没错！&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"https://www.4399.com/\"&gt;或许是时候休息一会儿了😎☕&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"https://movie.douban.com/top250\"&gt;也许看看电影是个好选择🎞️&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/aside&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;&copy; 2023 网页抓取示例&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\n\n2. XPath 节点\n在 XPath 中，节点是 HTML 文档的基本构建块，用于表示文档的不同部分。你可以将节点理解为 HTML 文档中的标签。XPath 通过选择不同类型的节点来定位和访问文档中的数据。XPath 共有七种类型的节点：元素节点、属性节点、文本节点、命名空间节点、处理指令节点、注释节点以及文档(根)节点。在本次学习中，我们主要关注以下三种：\n\n元素节点\n元素节点用以表示文档中的标签，如：&lt;div&gt;、&lt;p&gt;、&lt;a&gt; 等。元素节点可以包含其他元素节点、文本节点和属性节点。\n属性节点\n属性节点用以表示元素的属性，如：&lt;a href=\"https://example.com\"&gt; 中的 href 属性。属性节点可以提供关于元素的额外信息。\n文本节点\n文本节点用以表示元素中的文本内容，如：&lt;p&gt;这是文本节点&lt;/p&gt; 中的“这是文本节点”就是一个文本节点。\n\nXPath 节点之间的关系也很重要，在 HTML 部分，我们了解了各个标签之间存在父子元素关系、兄弟元素关系，这些关系也可以用于 XPath 节点。另外，如果我们将父子元素关系推而广之，就拥有了先辈-后代元素关系。\n\n先辈节点：某节点的父节点、父节点的父节点等，都是该节点的先辈节点。\n后代节点：某节点的子节点、子节点的子节点等，都是该节点的后代节点。\n\n\n\n\n\ngraph LR\nid1(HTMl) --&gt; id2(\"先辈元素1\\n----------\\n父元素1\\n----------\\n兄弟元素1\")\nid2 --&gt; id3(\"先辈元素2\\n----------\\n父元素2\\n----------\\n兄弟元素2\\n----------\\n子元素1\\n----------\\n后代元素1\")\nid2 --&gt; id4(兄弟元素2)\nid3 --&gt; id6(\"子元素2\\n----------\\n后代元素2\")\nid1 --&gt; id5(兄弟元素1)\n\n\n\n\n\n\n\n3. XPath 语法\n了解了 XPath 节点的前置知识，我们就可以开始尝试在 JupyterLab 中开始练习了。\n首先，我们需要 lxml 库为我们提供对 HTML 文档的解析支持。\n\nfrom lxml import html\n\n随后，设置 HTML 文档字符串：\n\n# 设置 HTML 文档字符串\nhtml_string = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;title&gt;一个HTML文档&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1&gt;网页抓取示例&lt;/h1&gt;\n        &lt;nav&gt;\n            &lt;ul&gt;\n                &lt;li&gt;&lt;a href=\"https://jupyter.pydatacamp.com/hub/login\"&gt;开始练习吧！&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"https://pydatacamp.com/\"&gt;记得认真阅读文档！！&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"https://docs.qq.com/doc/DS1dFSVBCcndjbXNa\"&gt;记录你的问题~&lt;/a&gt;&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    &lt;/header&gt;\n\n    &lt;section id=\"content\"&gt;\n        &lt;article&gt;\n            &lt;h2&gt;文章1&lt;/h2&gt;\n            &lt;p&gt;这是第一篇文章。📃📃📃📃📃好多字呀！🔤🔣🔤🔣🔤&lt;/p&gt;\n        &lt;/article&gt;\n\n        &lt;article&gt;\n            &lt;h2&gt;文章2&lt;/h2&gt;\n            &lt;p&gt;这是第二篇文章。😆🎮➡️🦹👉📄✏️➡️🥹➡️😭➡️📝➡️🗒️🗒️🗒️🗒️🗒️➡️😫😫➡️😭😭➡️🥱🦥➡️🫣🙈🫣➡️😆🎮&lt;/p&gt;\n        &lt;/article&gt;\n    &lt;/section&gt;\n\n    &lt;aside&gt;\n        &lt;h3&gt;相关链接&lt;/h3&gt;\n        &lt;ul&gt;\n            &lt;li&gt;&lt;a href=\"https://zty.pe/\"&gt;要不要学习打字？&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"https://weread.qq.com/\"&gt;多多读书准没错！&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"https://www.4399.com/\"&gt;或许是时候休息一会儿了😎☕&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"https://movie.douban.com/top250\"&gt;也许看看电影是个好选择🎞️&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/aside&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;&copy; 2023 网页抓取示例&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\"\"\"\n\n# 使用lxml的html模块解析HTML\nparsed_html = html.fromstring(html_string)\n\n将 HTML 字符串准备好以后，就使用 html.fromstring() 方法来解析它。\n如果在前面你已经将这个示例文档保存为了 .html 文件，可以像下面这样，使用 html.parse() 方法来解析它：\n\n# 指定HTML文件的路径\nhtml_file_path = r'文档路径'\nparser = html.HTMLParser(encoding='utf-8')\n\n# 使用lxml的html模块解析HTML文件\nparsed_html = html.parse(html_file_path, parser=parser)\n\nhtml.fromstring() 和 html.parse() 是 lxml 库提供的两种主要的 HTML 文档解析方法。\nhtml.fromstring() 既简单又直观，它通常适用于处理内存中的单个 HTML 片段或字符串。一般情况下，从文件中加载的较大的 HTML 文档不使用该方法进行处理。\nhtml.parse() 多用于解析从本地文件或 URL 加载的 HTML 文档，这个方法适用于处理完整的 HTML 文档。\n现在我们一起来看看 XPath 是如何选取元素的。\n\n(1) 节点选取\n一个 HTML 文档中，通常会有许多相同的标签，我们通过这些标签来定位节点。但是仔细观察 HTML 文档就会发现，同一标签可能会在不同地方出现许多次，在不同的地方实现不同的功能。因此，我们就需要找到一种方法来定位我们需要的标签——利用元素关系，即根据不同先辈-后代元素之间的关系来定位元素。比如，要找到上面的 HTML 文档中 &lt;header&gt; 标签下的 &lt;h1&gt; 标签，就可以从 &lt;h1&gt; 标签出发，一个个查询其先辈元素：\n\n/html/body/header/h1\n\n\n\n\n\ngraph TD\nid(html) --&gt; id1(body) --&gt; id2(header) --&gt; id3(h1)\nid3 -- 上溯 --&gt; id2\nid2 -- 上溯 --&gt; id1\nid1 -- 上溯 --&gt; id\n\n\n\n\n\n了解了这个原则，我们就可以按照下面的规则来定位文档中的任意元素了。\n\n\n\n\n\n\n\n\n\n\n表达式\n描述\n示例\n说明\n使用示例\n\n\n\n\nnodename\n选取此节点的所有子节点\n/html\n选取根节点的所有子节点\nresult1 = parsed_html.xpath('/html')\n\n\n//\n从根节点取子节点\n//h1\n从根节点开始选取所有 &lt;h1&gt; 元素\nresult2 = parsed_html.xpath('//h1')\n\n\n/\n选取某个指定节点的子节点\n/html/body/header\n选取 &lt;header&gt; 元素的子节点\nresult3 = parsed_html.xpath('/html/body/header')\n\n\n@\n选取带有指定属性的节点\n//@id\n选取所有带有 id 属性的节点\nresult6 = parsed_html.xpath('//@id')\n\n\n.\n选取当前节点\n./header\n选取当前节点的 &lt;header&gt; 元素\nheader_element = body_element.xpath('./header')[0]\n\n\n\n现在，让我们一起看看这些表达式的实现效果如何。\n\n\n\n\n\n\nNote\n\n\n\n需要注意的是，XPath 查询返回的结果不是节点的内容，而是代表选定节点的元素对象。因此如果直接输出查询到的内容，会将这些元素对象的地址等信息输出出来，而不会直接包含节点的文本信息。\n如果想要获取节点的文本内容，就需要进一步处理元素对象，例如使用 .text 属性或 .text_content 方法来提取文本内容。\n\n使用 .text 属性：大多数 XML/HTML 解析库（包括 lxml）的元素对象都具有一个 .text 属性，它可以用来获取元素的文本内容。\n# 使用 .text 属性获取文本内容\nelement = parsed_html.xpath('//h1')[0]\ntext_content = element.text\nprint(text_content)\n使用 .text_content() 方法：lxml 库的元素对象还提供了一个 .text_content() 方法，它返回元素及其子元素的文本内容。\n# 使用 .text_content() 方法获取文本内容\nelement = parsed_html.xpath('//h1')[0]\ntext_content = element.text_content()\nprint(text_content)\n\n\n\n1. 选取根节点的所有子节点\n\nresult1 = parsed_html.xpath('/html')\nprint(\"示例1:\", result1)\n\n示例1: [&lt;Element html at 0x26a08172210&gt;]\n\n\n2. 从根节点开始选取所有 &lt;h1&gt; 元素\n\nresult2 = parsed_html.xpath('//h1')\nprint(\"示例2:\", result2)\n\n示例2: [&lt;Element h1 at 0x26a081671b0&gt;]\n\n\n3. 选取 &lt;html&gt; 下 &lt;body&gt; 标签中的 &lt;header&gt; 元素\n\nresult3 = parsed_html.xpath('/html/body/header')\nprint(\"示例3:\", result3)\n\n示例3: [&lt;Element header at 0x26a08185d60&gt;]\n\n\n4. 选取所有带有 id 属性的节点\n\nresult6 = parsed_html.xpath('//@id')\nprint(\"示例6:\", result6)\n\n5. 将当前节点移动到 &lt;body&gt; 元素下，然后选取当前节点中的 &lt;header&gt; 元素\n可能你已经注意到，最后一个表达式的使用示例与其他表达式不太一致。这是由于这个方法是用在当前节点下的，这意味着我们不能够像使用其他表达式那样，在任意位置使用这个方法。按表格中的例子来看，完整的方法应该是这样的：\n\nbody_element = parsed_html.xpath('/html/body')[0]  # 将当前节点移动到&lt;body&gt;元素\nheader_element = body_element.xpath('./header')[0]  # 使用./header来选取&lt;header&gt;元素\nprint(\"示例:\", header_element)\n\n\n\n(2) 谓词\n你可能已经注意到，在上一小节里的最后一个方法里，我们在进行元素定位时，在最后加上了 [0] 这样的代码。这些代码就是 XPath 的谓词，类似于自然语言中的谓语，谓词仿佛在给 XPath 添加一个动作，让其去定位我们所需要的特定的元素。\nXPath 谓词时一种用于在 XPath 表达式中添加条件的方式，以筛选出 HTML 文档中特定的节点。谓词可以使 XPath 表达式更具灵活性，我们可以根据节点的属性值、位置或其他条件来选择节点。\n谓词一般放在 XPath 表达式的最后，其语法如下\n\n节点选择表达式[谓词条件]\n\n其中，条件参数是一个逻辑表达式，用于过滤节点。\n\n\n\n\n\n\n\n\n表达式\n使用示例\n描述\n\n\n\n\n//p\nall_p_elements = parsed_html.xpath('//p')\n选择所有 &lt;p&gt; 元素\n\n\n//a[@href]\nhref_specified_a_elements = parsed_html.xpath('//a[@href]')\n选择具有指定href属性的 &lt;a&gt; 元素\n\n\n//h1[text()=\"网页抓取示例\"]\nh1_elements_with_title = parsed_html.xpath('//h1[text()=\"网页抓取示例\"]')\n选择所有带有”网页抓取示例”标题的 &lt;h1&gt; 元素\n\n\n//article[1]\nfirst_article = parsed_html.xpath('//article[1]')\n选择第一个 &lt;article&gt; 元素\n\n\n//aside//li[last()]\nlast_li_element = parsed_html.xpath('//aside//li[last()]')\n选取 &lt;aside&gt; 标签下的最后一个 &lt;li&gt; 元素\n\n\n//aside//li[last()-1]\nsecond_last_li_element = parsed_html.xpath('//aside//li[last()-1]')\n选取 &lt;aside&gt; 标签下的倒数第二个 &lt;li&gt; 元素\n\n\n\n你可以根据下面的代码，到 JupyterLab 中试一试：\n\n需要注意的是，当我们没有使用函数等方法获取指定元素，或者选择唯一元素进行获取，而是直接使用条件来获取元素时，XPath 获取的结果将是一个列表，而这些列表常常是不同类型的节点，直接将这些节点输出为列表可能会导致混乱。因此要输出获取到的内容，就需要用到 for 循环。\n\n1. 选择所有 &lt;p&gt; 元素\n\n# 示例1: 选择所有&lt;p&gt;元素\nall_p_elements = parsed_html.xpath('//p')\n\n# 输出示例1结果\nprint(\"示例1: 选择所有&lt;p&gt;元素的文本内容：\")\nfor p_element in all_p_elements:\n    print(p_element.text_content())\n\n示例1: 选择所有&lt;p&gt;元素的文本内容：\n这是第一篇文章。📃📃📃📃📃好多字呀！🔤🔣🔤🔣🔤\n这是第二篇文章。😆🎮➡️🦹👉📄✏️➡️🥹➡️😭➡️📝➡️🗒️🗒️🗒️🗒️🗒️➡️😫😫➡️😭😭➡️🥱🦥➡️🫣🙈🫣➡️😆🎮\n© 2023 网页抓取示例\n\n\n2. 选择具有指定href属性的 &lt;a&gt; 元素\n\n# 示例2: 选择具有指定href属性的&lt;a&gt;元素\nhref_specified_a_elements = parsed_html.xpath('//a[@href]')\n\n# 输出示例2结果\nprint(\"\\n示例2: 选择具有指定href属性的&lt;a&gt;元素：\")\nfor a_element in href_specified_a_elements:\n    print(a_element.text_content())\n\n\n示例2: 选择具有指定href属性的&lt;a&gt;元素：\n开始练习吧！\n记得认真阅读文档！！\n记录你的问题~\n要不要学习打字？\n多多读书准没错！\n或许是时候休息一会儿了😎☕\n也许看看电影是个好选择🎞️\n\n\n3. 选择所有带有”网页抓取示例”标题的 &lt;h1&gt; 元素\n\n# 示例3: 选择所有带有\"网页抓取示例\"标题的&lt;h1&gt;元素\nh1_elements_with_title = parsed_html.xpath('//h1[text()=\"网页抓取示例\"]')\n\n# 输出示例3结果\nprint(\"\\n示例3: 选择所有带有'网页抓取示例'标题的&lt;h1&gt;元素：\")\nfor h1_element in h1_elements_with_title:\n    print(h1_element.text_content())\n\n\n示例3: 选择所有带有'网页抓取示例'标题的&lt;h1&gt;元素：\n网页抓取示例\n\n\n4. 选择第一个 &lt;article&gt; 元素\n\n# 示例4: 选择第一个&lt;article&gt;元素\nfirst_article = parsed_html.xpath('//article[1]')\n\n# 输出示例4结果\nprint(\"\\n示例4: 选择第一个&lt;article&gt;元素的标题：\")\nprint(first_article[0].find('h2').text_content())\n\n\n示例4: 选择第一个&lt;article&gt;元素的标题：\n文章1\n\n\n5. 选取 &lt;aside&gt; 标签下的最后一个 &lt;li&gt; 元素\n\n# 示例5: 选取&lt;aside&gt;标签下的最后一个&lt;li&gt;元素\nlast_li_element = parsed_html.xpath('//aside//li[last()]')\n\n# 输出示例5结果\nprint(\"\\n示例5: 选取&lt;aside&gt;标签下的最后一个&lt;li&gt;元素：\")\nfor li_element in last_li_element:\n    print(li_element.text_content())\n\n\n示例5: 选取&lt;aside&gt;标签下的最后一个&lt;li&gt;元素：\n也许看看电影是个好选择🎞️\n\n\n6. 选取 &lt;aside&gt; 标签下的倒数第二个 &lt;li&gt; 元素\n\n# 示例6: 选取&lt;aside&gt;标签下的倒数第二个&lt;li&gt;元素\nsecond_last_li_element = parsed_html.xpath('//aside//li[last()-1]')\n\n# 输出示例6结果\nprint(\"\\n示例6: 选取倒数第二个&lt;li&gt;元素：\")\nfor li_element in second_last_li_element:\n    print(li_element.text_content())\n\n\n示例6: 选取倒数第二个&lt;li&gt;元素：\n或许是时候休息一会儿了😎☕\n\n\n\n\n(3) 通配符\n最后，我们一起来看看 XPath 通配符。你可能已经注意到，在上面的谓词小节中，有许多奇怪的符号出现，比如：//a[@href] 中的 @；又有一些出现在谓词中的表达式，例如：//h1[text()=\"网页抓取示例\"]。这些符号和表达式，就是 XPath 中的通配符。借助通配符，我们可以选取未知的 HTML 元素。\n\n\n\n\n\n\n\n\n\n通配符\n描述\n使用示例\n结果说明\n\n\n\n\n*\n匹配任何元素节点\n//*\n选取文档中的所有元素\n\n\n@\n匹配任何属性节点\n//a[@href]\n选择具有指定href属性的 &lt;a&gt; 元素\n\n\nnode()\n匹配任何类型的节点\n//h1[text()=\"网页抓取示例\n选择所有带有”网页抓取示例”标题的 &lt;h1&gt; 元素"
  },
  {
    "objectID": "05_02_HTML文档与Requests库.html#requests-库",
    "href": "05_02_HTML文档与Requests库.html#requests-库",
    "title": "16  HTML 文档与 Requests 库",
    "section": "Requests 库",
    "text": "Requests 库\n\n一、 什么是 Requests 库\n前面我们介绍过，如果要使用爬虫进行数据爬取，首先就要向服务器发送请求，以获取网页的数据源代码，即获取需要被处理的网页内容。\n在本次学习中，我们所使用的，用来向服务器发送请求的工具就是 Requests 库，它是一个 HTTP 请求库，用于发送 HTTP 请求和 Web 服务器进行通信。我们可以借助这个库，使用一种简单而优雅的方法在 Python 中进行网络通信。\n值得注意的是，requests 库并不是 Python 自带的库，而是一个第三方库，因此在使用它之前，我们需要进行安装。打开 JupyterLab，在终端中输入以下代码以安装 requests 库。\n\n!pip install requests\n\n\n\n二、Requests 库的特点和用法\n\n1. 发送 HTTP 请求\n使用 requests 库可以很方便的发送 HTTP 请求，例如，我们想要向服务器发送一个 Get 请求，就可以调用 requests 库中的 .get() 函数。这个函数只接收一个参数，就是网站的 URL。参照下面的例子，你也可以找一些网站来尝试使用 requests 库发送 HTTP 请求。\n\n\n\n\n\n\nNote\n\n\n\n在输入参数时，我们要格外注意的一点是：\n在我们的日常生活中，浏览器地址里里的网址可能是这样的：movie.douban.com/top250 或 www.movie.douban.com/top250\n\n\n\n地址1\n\n\n但是在将网址作为参数填入时，我们必须要在网址前加上传输协议，即：https://movie.douban.com/top250\n\n\n\n地址2\n\n\n\n\n\nimport requests\n\n\nresponse = requests.get(\"https://movie.douban.com/top250\")\nprint(response)\n\n&lt;Response [418]&gt;\n\n\n运行上面的代码，我们就将使用 .get 函数获取的内容输出了出来，你会发现，输出的结果就是服务器回应给我们的状态码 418。\n\n\n\n\n\n\nNote\n\n\n\n关于状态码 418：\n状态码 418 不是一个通常意义上的由服务器传递给客户端的状态码，它通常使用于愚人节或者一些轻松的场合，也有可能是服务器发现了爬虫程序，并且向使用爬虫的人开了一个小小的、善意的玩笑。它的具体描述是：\nAny attempt to brew coffee with a teapot should result in the error code “418 I’m a teapot”. The resulting entity body MAY be short and stout.\n使用中文来表达的话，大意为：\n当客户端给一个茶壶发送泡咖啡的请求时，茶壶就返回一个418错误状态码，表示“我是一个茶壶”。\n一个茶壶🫖！当然不可以用来泡咖啡☕呀！😆😆\n这个状态码诞生于1998年，作为一个愚人节玩笑来到这个世界上。详情可以参考：https://datatracker.ietf.org/doc/html/rfc2324\n你看，计算机编程并不只是冷冰冰的代码，也存在着许多多的人文关怀。在使用爬虫时，千万记得遵循爬虫伦理，设置合理的爬虫策略，小心伤了辛苦建立网站的程序员们的心！\n\n\n在使用 .get 方法发送请求以后，我们还需要判断我们的请求是否被客户端所接受了，即判断我们的请求有没有成功，此时，我们就可以使用 response.ok 属性，该属性用于检查 HTTP 请求是否成功并且返回一个布尔值，如果响应码在状态 200 到 299 的范围内，将返回 True，表示请求成功，否则将返回 False，表示请求失败。\n以上面的 HTTP 请求为示例，想要验证请求是否成功，可以这样输入：\n\nimport requests\n\n\nresponse = requests.get(\"https://movie.douban.com/top250\")\nprint(response)\n\nif response.ok:\n    print(\"请求成功\")\nelse:\n    print(\"请求失败\")\n\n&lt;Response [418]&gt;\n请求失败\n\n\n与 response.ok 方法类似的，还有如下方法，他们分别能获取到状态码、响应头以及文本内容。\n\nresponse.status_code属性包含了HTTP响应的状态码。状态码是一个三位数，表示服务器对请求的处理结果。\nresponse.headers属性是一个字典，包含了HTTP响应的头部信息。\nresponse.text属性包含了HTTP响应的文本内容。对于文本响应（如HTML页面或纯文本文档），这是服务器返回的实际文本内容。\n\n以中文知识社区 知乎https://www.zhihu.com/ 为例，我们来尝试一下上面的方法：\n\nimport requests\n\n\nresponse = requests.get(\"https://www.zhihu.com/\")\n# 获取状态码\nprint(f\"服务器返回的状态码是：{response.status_code}\")\n\n服务器返回的状态码是：200\n\n\n\n# 获取响应头\nprint(f\"服务器返回的响应头是：{response.headers}\")\n\n服务器返回的响应头是：{'Server': 'CLOUD ELB 1.0.0', 'Date': 'Thu, 14 Sep 2023 06:13:07 GMT', 'Content-Type': 'text/html; charset=utf-8', 'Vary': 'Accept-Encoding', 'content-security-policy': \"default-src * blob:; img-src * data: blob: resource: t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; connect-src * wss: blob: resource:; frame-src 'self' *.zhihu.com mailto: tel: weixin: *.vzuu.com mo.m.taobao.com getpocket.com note.youdao.com safari-extension://com.evernote.safari.clipper-Q79WDW8YH9 blob: mtt: zhihujs: captcha.guard.qcloud.com pos.baidu.com dup.baidustatic.com openapi.baidu.com wappass.baidu.com passport.baidu.com *.cme.qcloud.com vs-cdn.tencent-cloud.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; script-src 'self' blob: *.zhihu.com g.alicdn.com qzonestyle.gtimg.cn res.wx.qq.com open.mobile.qq.com 'unsafe-eval' unpkg.zhimg.com unicom.zhimg.com resource: zhihu-live.zhimg.com captcha.gtimg.com captcha.guard.qcloud.com pagead2.googlesyndication.com cpro.baidustatic.com pos.baidu.com dup.baidustatic.com i.hao61.net jsapi.qq.com 'nonce-fc6b8f49-c7d3-4a0f-adc5-0bd1c3005106' hm.baidu.com zz.bdstatic.com b.bdstatic.com imgcache.qq.com vs-cdn.tencent-cloud.com www.mangren.com www.yunmd.net zhihu.govwza.cn p.cnwza.cn gw.alipayobjects.com ssl.captcha.qq.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; style-src 'self' 'unsafe-inline' *.zhihu.com unicom.zhimg.com resource: captcha.gtimg.com www.mangren.com ssl.captcha.qq.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; font-src * data:; frame-ancestors *.zhihu.com\", 'x-content-security-policy': \"default-src * blob:; img-src * data: blob: resource: t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; connect-src * wss: blob: resource:; frame-src 'self' *.zhihu.com mailto: tel: weixin: *.vzuu.com mo.m.taobao.com getpocket.com note.youdao.com safari-extension://com.evernote.safari.clipper-Q79WDW8YH9 blob: mtt: zhihujs: captcha.guard.qcloud.com pos.baidu.com dup.baidustatic.com openapi.baidu.com wappass.baidu.com passport.baidu.com *.cme.qcloud.com vs-cdn.tencent-cloud.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; script-src 'self' blob: *.zhihu.com g.alicdn.com qzonestyle.gtimg.cn res.wx.qq.com open.mobile.qq.com 'unsafe-eval' unpkg.zhimg.com unicom.zhimg.com resource: zhihu-live.zhimg.com captcha.gtimg.com captcha.guard.qcloud.com pagead2.googlesyndication.com cpro.baidustatic.com pos.baidu.com dup.baidustatic.com i.hao61.net jsapi.qq.com 'nonce-fc6b8f49-c7d3-4a0f-adc5-0bd1c3005106' hm.baidu.com zz.bdstatic.com b.bdstatic.com imgcache.qq.com vs-cdn.tencent-cloud.com www.mangren.com www.yunmd.net zhihu.govwza.cn p.cnwza.cn gw.alipayobjects.com ssl.captcha.qq.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; style-src 'self' 'unsafe-inline' *.zhihu.com unicom.zhimg.com resource: captcha.gtimg.com www.mangren.com ssl.captcha.qq.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; font-src * data:; frame-ancestors *.zhihu.com\", 'x-webkit-csp': \"default-src * blob:; img-src * data: blob: resource: t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; connect-src * wss: blob: resource:; frame-src 'self' *.zhihu.com mailto: tel: weixin: *.vzuu.com mo.m.taobao.com getpocket.com note.youdao.com safari-extension://com.evernote.safari.clipper-Q79WDW8YH9 blob: mtt: zhihujs: captcha.guard.qcloud.com pos.baidu.com dup.baidustatic.com openapi.baidu.com wappass.baidu.com passport.baidu.com *.cme.qcloud.com vs-cdn.tencent-cloud.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; script-src 'self' blob: *.zhihu.com g.alicdn.com qzonestyle.gtimg.cn res.wx.qq.com open.mobile.qq.com 'unsafe-eval' unpkg.zhimg.com unicom.zhimg.com resource: zhihu-live.zhimg.com captcha.gtimg.com captcha.guard.qcloud.com pagead2.googlesyndication.com cpro.baidustatic.com pos.baidu.com dup.baidustatic.com i.hao61.net jsapi.qq.com 'nonce-fc6b8f49-c7d3-4a0f-adc5-0bd1c3005106' hm.baidu.com zz.bdstatic.com b.bdstatic.com imgcache.qq.com vs-cdn.tencent-cloud.com www.mangren.com www.yunmd.net zhihu.govwza.cn p.cnwza.cn gw.alipayobjects.com ssl.captcha.qq.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; style-src 'self' 'unsafe-inline' *.zhihu.com unicom.zhimg.com resource: captcha.gtimg.com www.mangren.com ssl.captcha.qq.com t.captcha.qq.com *.dun.163yun.com *.dun.163.com *.126.net *.nosdn.127.net nos.netease.com; font-src * data:; frame-ancestors *.zhihu.com\", 'x-frame-options': 'SAMEORIGIN', 'strict-transport-security': 'max-age=15552000; includeSubDomains', 'surrogate-control': 'no-store', 'pragma': 'no-cache', 'expires': '0', 'x-content-type-options': 'nosniff', 'x-xss-protection': '1; mode=block', 'X-Backend-Response': '0.046', 'Content-Encoding': 'br', 'Referrer-Policy': 'no-referrer-when-downgrade', 'X-SecNG-Response': '0.051000118255615', 'x-lb-timing': '0.052', 'x-idc-id': '2', 'Set-Cookie': 'KLBRSID=76ae5fb4fba0f519d97e594f1cef9fab|1694671987|1694671987; Path=/', 'Cache-Control': 'private, must-revalidate, no-cache, no-store, max-age=0', 'Transfer-Encoding': 'chunked', 'X-NWS-LOG-UUID': '12105456813897693910', 'Connection': 'keep-alive', 'X-Cache-Lookup': 'Cache Miss', 'x-edge-timing': '0.100', 'x-cdn-provider': 'tencent'}\n\n\n\n# 获取文本内容\nprint(f\"服务器返回的文本内容是：{response.text}\")\n\n服务器返回的文本内容是：&lt;!doctype html&gt;\n&lt;html lang=\"zh\" data-hairline=\"true\" class=\"itcauecng\" data-theme=\"light\"&gt;&lt;head&gt;&lt;meta charSet=\"utf-8\"/&gt;&lt;title data-rh=\"true\"&gt;知乎 - 有问题，就会有答案&lt;/title&gt;&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\"/&gt;&lt;meta name=\"renderer\" content=\"webkit\"/&gt;&lt;meta name=\"force-rendering\" content=\"webkit\"/&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt;&lt;meta name=\"google-site-verification\" content=\"FTeR0c8arOPKh8c5DYh_9uu98_zJbaWw53J-Sch9MTg\"/&gt;&lt;meta name=\"description\" property=\"og:description\" content=\"知乎，中文互联网高质量的问答社区和创作者聚集的原创内容平台，于 2011 年 1 月正式上线，以「让人们更好的分享知识、经验和见解，找到自己的解答」为品牌使命。知乎凭借认真、专业、友善的社区氛围、独特的产品机制以及结构化和易获得的优质内容，聚集了中文互联网科技、商业、影视、时尚、文化等领域最具创造力的人群，已成为综合性、全品类、在诸多领域具有关键影响力的知识分享社区和创作者聚集的原创内容平台，建立起了以社区驱动的内容变现商业模式。\"/&gt;&lt;link data-rh=\"true\" rel=\"apple-touch-icon\" href=\"https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png\"/&gt;&lt;link data-rh=\"true\" rel=\"apple-touch-icon\" href=\"https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png\" sizes=\"152x152\"/&gt;&lt;link data-rh=\"true\" rel=\"apple-touch-icon\" href=\"https://static.zhihu.com/heifetz/assets/apple-touch-icon-120.d5793cac.png\" sizes=\"120x120\"/&gt;&lt;link data-rh=\"true\" rel=\"apple-touch-icon\" href=\"https://static.zhihu.com/heifetz/assets/apple-touch-icon-76.7abf3393.png\" sizes=\"76x76\"/&gt;&lt;link data-rh=\"true\" rel=\"apple-touch-icon\" href=\"https://static.zhihu.com/heifetz/assets/apple-touch-icon-60.362a8eac.png\" sizes=\"60x60\"/&gt;&lt;link crossorigin=\"\" rel=\"shortcut icon\" type=\"image/x-icon\" href=\"https://static.zhihu.com/heifetz/favicon.ico\"/&gt;&lt;link crossorigin=\"\" rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"https://static.zhihu.com/heifetz/search.xml\" title=\"知乎\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//static.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//pica.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//picx.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//pic1.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//pic2.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//pic3.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//pic4.zhimg.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//static.zhihu.com\"/&gt;&lt;script nonce=\"fc6b8f49-c7d3-4a0f-adc5-0bd1c3005106\" data-web-reporter-config=\"{&quot;platform&quot;:&quot;web&quot;,&quot;project&quot;:&quot;heifetz&quot;}\"&gt;!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=e||self).webReporter={})}(this,function(e){\"use strict\";var t={},n=!1,o=function(){var e,o,r,a,i;return n||(e=document.querySelector(\"script[data-web-reporter-config]\"),o=e&&e.dataset.webReporterConfig||\"{}\",r=JSON.parse(o),a=r.platform,i=r.project,t={platform:a,project:i},n=!0),t};function r(e){return a(function(){return localStorage.getItem(e)})()}function a(e){return function(){try{return e.apply(void 0,arguments)}catch(e){}}}var i=a(function(e,t){var n={platform:\"web\",project:o().project,clientTimestamp:+new Date};!function(e,t,n){\"1\"===r(\"weber:logenabled\")&&console.log(\"[web-reporter]%o\",{type:e,base:t,data:n})}(e,n,t),function(e,t){var n=btoa(JSON.stringify(t));if(\"undefined\"!=typeof Blob&&window.navigator&&window.navigator.sendBeacon){var o=new Blob([n],{type:\"text/plain\"});navigator.sendBeacon(e,o)}else{var r=new XMLHttpRequest;r.open(\"POST\",e),r.withCredentials=!1,r.setRequestHeader(\"Content-Type\",\"text/plain;charset=UTF-8\"),r.send(n)}}(r(\"weber:api\")||\"https://apm.zhihu.com/collector/web_json\",{type:e,base:n,data:t})});e.report=i,Object.defineProperty(e,\"__esModule\",{value:!0})});\n&lt;/script&gt;&lt;link href=\"https://static.zhihu.com/heifetz/4929.216a26f4.a7525b069c7aa6ab160f.css\" crossorigin=\"\" rel=\"stylesheet\"/&gt;&lt;link href=\"https://static.zhihu.com/heifetz/main.216a26f4.a33d15462b94f00e8222.css\" crossorigin=\"\" rel=\"stylesheet\"/&gt;&lt;link href=\"https://static.zhihu.com/heifetz/main-signin-routes.216a26f4.8dc91cfc5b59704edbde.css\" crossorigin=\"\" rel=\"stylesheet\"/&gt;&lt;script nonce=\"fc6b8f49-c7d3-4a0f-adc5-0bd1c3005106\"&gt;!function(){\"use strict\";!function(e,n){var r=[];function t(e){return function(){r.push([e,arguments])}}n.Raven={captureException:t(\"captureException\"),captureMessage:t(\"captureMessage\"),captureBreadcrumb:t(\"captureBreadcrumb\")};var a,o,c,i,s,u=\"undefined\"!=typeof DOMError;function d(e){var n=e instanceof Error||e instanceof ErrorEvent||u&&e instanceof DOMError||e instanceof DOMException;Raven.captureException(n?e:new Error(e.message||e.reason))}n.addEventListener(\"unhandledrejection\",d),n.addEventListener(\"error\",d,!0),a=e.src,o=e,c=function(){r.forEach(function(e){var n;(n=Raven)[e[0]].apply(n,e[1])}),n.removeEventListener(\"unhandledrejection\",d),n.removeEventListener(\"error\",d,!0)},i=document.head||document.getElementsByTagName(\"head\")[0],(s=document.createElement(\"script\")).crossOrigin=o.crossOrigin,s.dataset.sentryConfig=o[\"data-sentry-config\"],s.onload=c,s.src=a,i.appendChild(s)}({\"defer\":true,\"crossOrigin\":\"anonymous\",\"src\":\"https://unpkg.zhimg.com/@cfe/sentry-script@1.3.1/dist/init.js\",\"data-sentry-config\":\"{\\\"dsn\\\":\\\"https://2d8d764432cc4f6fb3bc78ab9528299d@crash2.zhihu.com/1224\\\",\\\"sampleRate\\\":0.1,\\\"release\\\":\\\"984-182b91f6\\\",\\\"ignoreErrorNames\\\":[\\\"NetworkError\\\",\\\"SecurityError\\\"],\\\"ignoreErrorsPreset\\\":\\\"ReactApp\\\",\\\"tags\\\":{\\\"app_name\\\":\\\"heifetz\\\"}}\"},window)}();\n&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"root\"&gt;&lt;div&gt;&lt;style data-emotion-css=\"uzm3ri\"&gt;.css-uzm3ri{position:fixed;top:0;right:0;left:0;z-index:101;display:none;height:2px;pointer-events:none;background:#056DE8;-webkit-transform:translateX(-100%);-ms-transform:translateX(-100%);transform:translateX(-100%);}&lt;/style&gt;&lt;div class=\"LoadingBar  css-uzm3ri\"&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=\"position:absolute;top:-10000px;left:-10000px\" role=\"log\" aria-live=\"assertive\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;main role=\"main\" class=\"App-main\"&gt;&lt;div&gt;&lt;div class=\"SignFlowHomepage\"&gt;&lt;div class=\"SignFlowHomepage-content\"&gt;&lt;img alt=\"知乎 LOGO\" class=\"SignFlowHomepage-logo\" src=\"https://pic2.zhimg.com/80/v2-f6b1f64a098b891b4ea1e3104b5b71f6_720w.png\"/&gt;&lt;div class=\"signQr-container\"&gt;&lt;div class=\"signQr-leftContainer\"&gt;&lt;div class=\"Qrcode-container smallVersion\"&gt;&lt;style data-emotion-css=\"k49mnn\"&gt;.css-k49mnn{box-sizing:border-box;margin:0;min-width:0;color:#444444;font-size:16px;font-weight:600;line-height:23px;}&lt;/style&gt;&lt;div class=\"css-k49mnn\"&gt;打开知乎App&lt;/div&gt;&lt;style data-emotion-css=\"qj3urb\"&gt;.css-qj3urb{box-sizing:border-box;margin:0;min-width:0;margin-top:8px;margin-bottom:24px;color:#444444;font-size:14px;line-height:20px;}&lt;/style&gt;&lt;div class=\"css-qj3urb\"&gt;在「我的页」左上角打开扫一扫&lt;/div&gt;&lt;div class=\"Qrcode-content\"&gt;&lt;div class=\"Qrcode-img\"&gt;&lt;style data-emotion-css=\"79elbk\"&gt;.css-79elbk{position:relative;}&lt;/style&gt;&lt;div class=\"BounceLoading  css-79elbk\" style=\"width:42px;height:18px\"&gt;&lt;style data-emotion-css=\"cy45qd animation-1alkx44\"&gt;.css-cy45qd{position:absolute;background-color:#056DE8;border-radius:50%;-webkit-transform-origin:center;-ms-transform-origin:center;transform-origin:center;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-name:animation-1alkx44;animation-name:animation-1alkx44;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-animation-fill-mode:both;animation-fill-mode:both;}@-webkit-keyframes animation-1alkx44{0%,100%{-webkit-transform:translateY(-100%);-ms-transform:translateY(-100%);transform:translateY(-100%);}50%{-webkit-transform:translateY(100%);-ms-transform:translateY(100%);transform:translateY(100%);}}@keyframes animation-1alkx44{0%,100%{-webkit-transform:translateY(-100%);-ms-transform:translateY(-100%);transform:translateY(-100%);}50%{-webkit-transform:translateY(100%);-ms-transform:translateY(100%);transform:translateY(100%);}}&lt;/style&gt;&lt;span class=\"BounceLoading-child css-cy45qd\" style=\"top:6px;left:0;width:6px;height:6px;animation-duration:0.8s;animation-delay:0s\"&gt;&lt;/span&gt;&lt;span class=\"BounceLoading-child css-cy45qd\" style=\"top:6px;left:18px;width:6px;height:6px;animation-duration:0.8s;animation-delay:-0.13333333333333333s\"&gt;&lt;/span&gt;&lt;span class=\"BounceLoading-child css-cy45qd\" style=\"top:6px;left:36px;width:6px;height:6px;animation-duration:0.8s;animation-delay:-0.26666666666666666s\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"Qrcode-guide-message\"&gt;&lt;style data-emotion-css=\"x9rxz4\"&gt;.css-x9rxz4{box-sizing:border-box;margin:0;min-width:0;margin-top:24px;color:#444444;font-size:14px;font-weight:600;line-height:20px;}&lt;/style&gt;&lt;div class=\"css-x9rxz4\"&gt;其他扫码方式：微信&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style data-emotion-css=\"1rjkgne\"&gt;.css-1rjkgne{box-sizing:border-box;margin:26px 0 22px;}&lt;/style&gt;&lt;style data-emotion-css=\"ousx6v\"&gt;.css-ousx6v{box-sizing:border-box;margin:0;min-width:0;font-size:14px;color:#056DE8;height:60px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;box-sizing:border-box;margin:26px 0 22px;}&lt;/style&gt;&lt;div class=\"css-ousx6v\"&gt;&lt;style data-emotion-css=\"vurnku\"&gt;.css-vurnku{box-sizing:border-box;margin:0;min-width:0;}&lt;/style&gt;&lt;div class=\"css-vurnku\"&gt;&lt;style data-emotion-css=\"sqn8ql\"&gt;.css-sqn8ql{padding:4px 10px;border:1px solid #EBEBEB;border-radius:29px;font-size:12px;color:#444444;line-height:19px;display:inline-block;}.css-sqn8ql:hover{background:#F6F6F6;}&lt;/style&gt;&lt;style data-emotion-css=\"1bdtll5\"&gt;.css-1bdtll5{box-sizing:border-box;margin:0;min-width:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:inline-block;text-align:center;line-height:inherit;-webkit-text-decoration:none;text-decoration:none;font-size:inherit;padding-left:16px;padding-right:16px;padding-top:8px;padding-bottom:8px;color:white;background-color:#056DE8;border:0;border-radius:4px;font-size:16px;font-weight:600;color:#FFFFFF;background-color:#056DE8;border-radius:4px;background-color:unset;font-weight:inherit;margin-right:8px;padding:4px 10px;border:1px solid #EBEBEB;border-radius:29px;font-size:12px;color:#444444;line-height:19px;display:inline-block;}.css-1bdtll5:hover{background:#F6F6F6;}&lt;/style&gt;&lt;button class=\"css-1bdtll5\"&gt;下载知乎App&lt;/button&gt;&lt;/div&gt;&lt;style data-emotion-css=\"epvm6\"&gt;.css-epvm6{white-space:nowrap;}&lt;/style&gt;&lt;style data-emotion-css=\"16enr5p\"&gt;.css-16enr5p{box-sizing:border-box;margin:0;min-width:0;white-space:nowrap;}&lt;/style&gt;&lt;div class=\"css-16enr5p\"&gt;&lt;style data-emotion-css=\"1iubajs\"&gt;.css-1iubajs{box-sizing:border-box;margin:0;min-width:0;color:#175199;margin-right:8px;padding:4px 10px;border:1px solid #EBEBEB;border-radius:29px;font-size:12px;color:#444444;line-height:19px;display:inline-block;}.css-1iubajs:hover{background:#F6F6F6;}&lt;/style&gt;&lt;a href=\"/org/signup\" data-za-detail-view-id=\"4943\" class=\"css-1iubajs\"&gt;开通机构号&lt;/a&gt;&lt;/div&gt;&lt;div class=\"css-16enr5p\"&gt;&lt;style data-emotion-css=\"186oz3i\"&gt;.css-186oz3i{box-sizing:border-box;margin:0;min-width:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:inline-block;text-align:center;line-height:inherit;-webkit-text-decoration:none;text-decoration:none;font-size:inherit;padding-left:16px;padding-right:16px;padding-top:8px;padding-bottom:8px;color:white;background-color:#056DE8;border:0;border-radius:4px;font-size:16px;font-weight:600;color:#FFFFFF;background-color:#056DE8;border-radius:4px;background-color:unset;font-weight:inherit;padding:4px 10px;border:1px solid #EBEBEB;border-radius:29px;font-size:12px;color:#444444;line-height:19px;display:inline-block;}.css-186oz3i:hover{background:#F6F6F6;}&lt;/style&gt;&lt;button data-za-detail-view-id=\"4943\" class=\"css-186oz3i\"&gt;无障碍模式&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"signQr-rightContainer\"&gt;&lt;style data-emotion-css=\"b1vbr6\"&gt;.css-b1vbr6{overflow:hidden;box-shadow:none;}&lt;/style&gt;&lt;style data-emotion-css=\"16h0l39\"&gt;.css-16h0l39{box-sizing:border-box;margin:0;min-width:0;padding:0;background-color:#FFFFFF;box-shadow:0 1px 3px rgba(18,18,18,0.1);border-radius:2px;background-color:#FFFFFF;width:400px;overflow:hidden;box-shadow:none;}.css-16h0l39+.css-16h0l39{margin-top:10px;}&lt;/style&gt;&lt;div class=\"css-16h0l39\"&gt;&lt;div class=\"SignContainer-content\"&gt;&lt;div class=\"SignContainer-inner\"&gt;&lt;div&gt;&lt;form novalidate=\"\" class=\"SignFlow Login-content\"&gt;&lt;div class=\"SignFlow-tabs\"&gt;&lt;div class=\"SignFlow-tab SignFlow-tab--active\" role=\"button\" tabindex=\"0\"&gt;验证码登录&lt;/div&gt;&lt;div class=\"SignFlow-tab\" role=\"button\" tabindex=\"0\"&gt;密码登录&lt;/div&gt;&lt;/div&gt;&lt;div class=\"SignFlow-account\"&gt;&lt;div class=\"SignFlowInput SignFlow-accountInputContainer\"&gt;&lt;label class=\"SignFlow-accountInput Input-wrapper\"&gt;&lt;input type=\"tel\" value=\"\" name=\"username\" class=\"Input username-input\" placeholder=\"手机号\"/&gt;&lt;/label&gt;&lt;div class=\"SignFlowInput-errorMask SignFlowInput-requiredErrorMask SignFlowInput-errorMask--hidden\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"SignFlow SignFlow-smsInputContainer\"&gt;&lt;div class=\"SignFlowInput SignFlow-smsInput\"&gt;&lt;label class=\"Input-wrapper\"&gt;&lt;input type=\"tel\" value=\"\" name=\"digits\" class=\"Input username-input\" placeholder=\"输入 6 位短信验证码\"/&gt;&lt;/label&gt;&lt;div class=\"SignFlowInput-errorMask SignFlowInput-requiredErrorMask SignFlowInput-errorMask--hidden\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button type=\"button\" class=\"Button CountingDownButton SignFlow-smsInputButton Button--plain\"&gt;获取短信验证码&lt;/button&gt;&lt;/div&gt;&lt;div class=\"Login-options\"&gt;&lt;button type=\"button\" class=\"Button Login-switchType Button--plain\"&gt;&lt;/button&gt;&lt;button type=\"button\" class=\"Button Login-cannotLogin Button--plain\"&gt;&lt;div&gt;获取&lt;!-- --&gt;语音&lt;!-- --&gt;验证码&lt;/div&gt;&lt;/button&gt;&lt;/div&gt;&lt;button type=\"submit\" class=\"Button SignFlow-submitButton Button--primary Button--blue\"&gt;登录/注册&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=\"position:absolute;top:-10000px;left:-10000px\" role=\"log\" aria-live=\"assertive\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;style data-emotion-css=\"d9yzea\"&gt;.css-d9yzea{margin:0 24px 12px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}&lt;/style&gt;&lt;style data-emotion-css=\"jr78vv\"&gt;.css-jr78vv{box-sizing:border-box;margin:0;min-width:0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;margin:0 24px 12px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}&lt;/style&gt;&lt;div class=\"css-jr78vv\"&gt;&lt;style data-emotion-css=\"t703mf\"&gt;.css-t703mf{box-sizing:border-box;margin:0;min-width:0;border-top:1px solid;border-color:#EBEBEB;width:124px;}&lt;/style&gt;&lt;div class=\"css-t703mf\"&gt;&lt;/div&gt;&lt;style data-emotion-css=\"daoszp\"&gt;.css-daoszp{box-sizing:border-box;margin:0;min-width:0;color:#999999;font-size:12px;margin-left:16px;margin-right:16px;width:72px;overflow:hidden;line-height:17px;white-space:nowrap;}&lt;/style&gt;&lt;div class=\"css-daoszp\"&gt;其他方式登录&lt;/div&gt;&lt;div class=\"css-t703mf\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"Login-socialLogin\"&gt;&lt;span class=\"Login-socialButtonGroup\"&gt;&lt;button type=\"button\" class=\"Button Login-socialButton Button--plain\"&gt;&lt;svg width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\" class=\"ZDI ZDI--Wechat24\"&gt;&lt;path fill=\"#07C160\" d=\"M20.314 18.59c1.333-.968 2.186-2.397 2.186-3.986 0-2.91-2.833-5.27-6.325-5.27-3.494 0-6.325 2.36-6.325 5.27 0 2.911 2.831 5.271 6.325 5.271.698.001 1.393-.096 2.064-.288l.186-.029c.122 0 .232.038.336.097l1.386.8.12.04a.21.21 0 0 0 .212-.211l-.034-.154-.285-1.063-.023-.135a.42.42 0 0 1 .177-.343ZM9.09 3.513C4.9 3.514 1.5 6.346 1.5 9.84c0 1.905 1.022 3.622 2.622 4.781a.505.505 0 0 1 .213.412l-.026.16-.343 1.276-.04.185c0 .14.113.254.252.254l.146-.047 1.663-.96a.793.793 0 0 1 .403-.116l.222.032c.806.231 1.64.348 2.478.348l.417-.01a4.888 4.888 0 0 1-.255-1.55c0-3.186 3.1-5.77 6.923-5.77l.411.011c-.57-3.02-3.71-5.332-7.494-5.332Zm4.976 10.248a.843.843 0 1 1 0-1.685.843.843 0 0 1 0 1.684v.001Zm4.217 0a.843.843 0 1 1 0-1.685.843.843 0 0 1 0 1.684v.001ZM6.561 8.827a1.012 1.012 0 1 1 0-2.023 1.012 1.012 0 0 1 0 2.023Zm5.061 0a1.012 1.012 0 1 1 0-2.023 1.012 1.012 0 0 1 0 2.023Z\" clip-rule=\"evenodd\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/button&gt;&lt;button type=\"button\" class=\"Button Login-socialButton Button--plain\"&gt;&lt;svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"#50C8FD\" class=\"ZDI ZDI--Qq24\"&gt;&lt;path fill-rule=\"evenodd\" d=\"M12.003 2c-2.265 0-6.29 1.364-6.29 7.325v1.195S3.55 14.96 3.55 17.474c0 .665.17 1.025.281 1.025.114 0 .902-.483 1.748-2.072 0 0-.18 2.197 1.904 3.967 0 0-1.77.495-1.77 1.182 0 .686 4.078.43 6.29 0 2.239.425 6.288.687 6.288 0 0-.688-1.77-1.182-1.77-1.182 2.086-1.77 1.906-3.967 1.906-3.967.845 1.588 1.634 2.072 1.746 2.072.111 0 .283-.36.283-1.025 0-2.514-2.165-6.954-2.165-6.954V9.325C18.29 3.364 14.268 2 12.003 2Z\" clip-rule=\"evenodd\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/button&gt;&lt;button type=\"button\" class=\"Button Login-socialButton Button--plain\"&gt;&lt;svg width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\" class=\"ZDI ZDI--Weibo24\"&gt;&lt;path fill=\"#FB6622\" d=\"M15.518 3.06c8.834-.854 7.395 7.732 7.394 7.731-.625 1.44-1.673.31-1.673.31.596-7.52-5.692-6.33-5.692-6.33-.898-1.067-.03-1.71-.03-1.71Zm4.13 6.985c-.66 1.01-1.376.126-1.375.126.205-3.179-2.396-2.598-2.396-2.598-.72-.765-.091-1.346-.091-1.346 4.882-.55 3.863 3.818 3.863 3.818ZM5.318 7.52s4.615-3.86 6.443-1.328c0 0 .662 1.08-.111 2.797.003-.003 3.723-1.96 5.408.16 0 0 .848 1.094-.191 2.648 0 0 2.918-.099 2.918 2.715 0 2.811-4.104 6.44-9.315 6.44-5.214 0-8.026-2.092-8.596-3.102 0 0-3.475-4.495 3.444-10.33Zm10.448 7.792s.232-4.41-5.71-4.207c-6.652.231-6.58 4.654-6.58 4.654.022.39.098 3.713 5.843 3.713 5.98 0 6.447-4.16 6.447-4.16Zm-9.882.86s-.06-3.632 3.804-3.56c3.412.06 3.206 3.164 3.206 3.164s-.026 2.98-3.684 2.98c-3.288 0-3.326-2.584-3.326-2.584Zm2.528 1.037c.672 0 1.212-.447 1.212-.998 0-.55-.543-.998-1.212-.998-.672 0-1.215.447-1.215.998 0 .551.546.998 1.215.998Z\" clip-rule=\"evenodd\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=\"SignContainer-tip\"&gt;未注册手机验证后自动登录，注册即代表同意&lt;a href=\"https://www.zhihu.com/term/zhihu-terms\"&gt;《知乎协议》&lt;/a&gt;&lt;a href=\"https://www.zhihu.com/term/privacy\"&gt;《隐私保护指引》&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;footer class=\"SignFlowHomepage-footer\"&gt;&lt;div class=\"ZhihuLinks\"&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://zhuanlan.zhihu.com\"&gt;知乎专栏&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/roundtable\"&gt;圆桌&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/explore\"&gt;发现&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/app\"&gt;移动应用&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/contact\"&gt;联系我们&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://app.mokahr.com/apply/zhihu\"&gt;来知乎工作&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/org/signup\"&gt;注册机构号&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"//ir.zhihu.com\"&gt;Investor Relations&lt;/a&gt;&lt;/div&gt;&lt;div class=\"ZhihuRights\"&gt;&lt;span&gt;© &lt;!-- --&gt;2023&lt;!-- --&gt; 知乎&lt;/span&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://tsm.miit.gov.cn/dxxzsp/\"&gt;京 ICP 证 110745 号&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://beian.miit.gov.cn/\"&gt;京 ICP 备 13052560 号 - 1&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802020088\"&gt;&lt;img alt=\"\" src=\"https://pic3.zhimg.com/80/v2-d0289dc0a46fc5b15b3363ffa78cf6c7.png\"/&gt;京公网安备 11010802020088 号&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://www.zhihu.com/certificates\"&gt;京网文[2022]2674-081 号&lt;/a&gt;&lt;a href=\"https://pic4.zhimg.com/v2-69619662ff377c3741d92bb6fd46b7ca.png\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;出版物经营许可证&lt;/a&gt;&lt;a href=\"https://pic3.zhimg.com/v2-c280f8bce57f9b045b83185384d86027.png\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;药品医疗器械网络信息服务备案（京）网药械信息备字（2022）第00334号&lt;/a&gt;&lt;/div&gt;&lt;div class=\"ZhihuRights\"&gt;&lt;a href=\"https://pic1.zhimg.com/v2-185764ce177e344f335363edb724f1d8.png\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;广播电视节目制作经营许可证:（京）字第06591号&lt;/a&gt;&lt;/div&gt;&lt;div class=\"ZhihuReports\"&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://zhuanlan.zhihu.com/p/28852607\"&gt;侵权举报&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"http://www.12377.cn\"&gt;网上有害信息举报专区&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/term/child-jubao\"&gt;儿童色情信息举报专区&lt;/a&gt;&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/term/algorithm-recommend-report\"&gt;互联网算法推荐举报专区&lt;/a&gt;&lt;span&gt;违法和不良信息举报：010-82716601&lt;/span&gt;&lt;a href=\"mailto:jubao@zhihu.com\"&gt;举报邮箱：jubao@zhihu.com&lt;/a&gt;&lt;/div&gt;&lt;style data-emotion-css=\"1xaekgw\"&gt;.css-1xaekgw{margin-top:20px;}&lt;/style&gt;&lt;div class=\"css-1xaekgw\"&gt;&lt;style data-emotion-css=\"1170n61\"&gt;.css-1170n61{vertical-align:bottom;}&lt;/style&gt;&lt;img loading=\"lazy\" width=\"80\" height=\"38\" src=\"https://pica.zhimg.com/80/v2-ccdb7828c12afff31a27e51593d23260_720w.png\" alt=\"本站提供适老化无障碍服务\" class=\"css-1170n61\"/&gt;&lt;/div&gt;&lt;/footer&gt;&lt;/div&gt;&lt;/div&gt;&lt;/main&gt;&lt;div data-zop-usertoken=\"{}\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script id=\"js-clientConfig\" type=\"text/json\"&gt;{\"fetchRoot\":{\"www\":\"https:\\u002F\\u002Fwww.zhihu.com\",\"api\":\"https:\\u002F\\u002Fapi.zhihu.com\",\"lens\":\"https:\\u002F\\u002Flens.zhihu.com\",\"zhuanlan\":\"https:\\u002F\\u002Fzhuanlan.zhihu.com\\u002Fapi\\u002F\",\"walletpay\":\"https:\\u002F\\u002Fwalletpay.zhihu.com\",\"captcha\":\"https:\\u002F\\u002Fcaptcha.zhihu.com\",\"vzuu\":\"https:\\u002F\\u002Fv.vzuu.com\",\"openapi\":\"https:\\u002F\\u002Fopenapi.zhihu.com\",\"svip\":\"https:\\u002F\\u002Fsvip.zhihu.com\"},\"host\":\"zhihu.com\",\"protocol\":\"https:\",\"wwwHost\":\"www.zhihu.com\",\"videoHost\":\"video.zhihu.com\",\"zhuanlanHost\":\"zhuanlan.zhihu.com\",\"allowSignUp\":true,\"refreshValidityPeriod\":\"30\",\"release\":\"984-182b91f6\",\"currentEntry\":\"main\",\"isMobileEntry\":false,\"apollo\":{\"env\":\"prod\",\"globalSilence\":\"\",\"ncgModeSign\":\"3f8e56febda4fb3bbea72e379d76de1e\",\"topstory_rec_adp\":\"1\",\"editor_adapt_native\":\"0\",\"content_publish_pin\":\"1\",\"test_canary\":\"member|0-100,1-0\",\"use_new_player\":\"member|0-0,1-100\",\"player_vendor\":\"member|0-0,1-100,2-0\",\"use_hevc\":\"member|0-0,1-100\",\"upload_use_signature\":\"member|0-0,1-100\",\"use_backdrop_blur\":\"member|0-0,1-100\",\"article_title_imagex\":\"member|0-0,1-100\",\"play_station\":\"member|0-0,1-100\",\"contentItem_cover_imagex\":\"member|0-0,1-100\"}}&lt;/script&gt;&lt;script id=\"js-initialData\" type=\"text/json\"&gt;{\"initialState\":{\"common\":{\"ask\":{},\"cities\":{\"cityData\":[]}},\"loading\":{\"global\":{\"count\":0},\"local\":{}},\"entities\":{\"users\":{},\"questions\":{},\"answers\":{},\"articles\":{},\"columns\":{},\"topics\":{},\"roundtables\":{},\"favlists\":{},\"comments\":{},\"notifications\":{},\"ebooks\":{},\"activities\":{},\"feeds\":{},\"pins\":{},\"promotions\":{},\"drafts\":{},\"chats\":{},\"posts\":{},\"zvideos\":{},\"zvideoContributions\":{},\"briefs\":{},\"eduCourses\":{}},\"currentUser\":\"\",\"account\":{\"unlockTicketStatus\":false,\"unlockTicket\":null,\"challenge\":[],\"errorStatus\":false,\"message\":\"\",\"isFetching\":false,\"accountInfo\":{},\"urlToken\":{\"loading\":false},\"cardUserInfo\":{\"vipInfo\":{}},\"handleWidget\":{},\"widgetList\":[],\"userWidgetId\":\"\"},\"settings\":{\"socialBind\":null,\"inboxMsg\":null,\"notification\":{},\"email\":{},\"privacyFlag\":null,\"blockedUsers\":{\"isFetching\":false,\"paging\":{\"pageNo\":1,\"pageSize\":6},\"data\":[]},\"blockedFollowees\":{\"isFetching\":false,\"paging\":{\"pageNo\":1,\"pageSize\":6},\"data\":[]},\"ignoredTopics\":{\"isFetching\":false,\"paging\":{\"pageNo\":1,\"pageSize\":6},\"data\":[]},\"restrictedTopics\":null,\"laboratory\":{}},\"notification\":{},\"people\":{\"profileStatus\":{},\"activitiesByUser\":{},\"answersByUser\":{},\"answersSortByVotesByUser\":{},\"answersIncludedByUser\":{},\"votedAnswersByUser\":{},\"thankedAnswersByUser\":{},\"voteAnswersByUser\":{},\"thankAnswersByUser\":{},\"topicAnswersByUser\":{},\"zvideosByUser\":{},\"articlesByUser\":{},\"articlesSortByVotesByUser\":{},\"articlesIncludedByUser\":{},\"pinsByUser\":{},\"questionsByUser\":{},\"commercialQuestionsByUser\":{},\"favlistsByUser\":{},\"followingByUser\":{},\"followersByUser\":{},\"mutualsByUser\":{},\"followingColumnsByUser\":{},\"followingQuestionsByUser\":{},\"followingFavlistsByUser\":{},\"followingTopicsByUser\":{},\"publicationsByUser\":{},\"columnsByUser\":{},\"allFavlistsByUser\":{},\"brands\":null,\"creationsByUser\":{},\"creationsSortByVotesByUser\":{},\"creationsFeed\":{},\"infinity\":{},\"batchUsers\":{},\"profileInfinity\":null},\"env\":{\"ab\":{\"config\":{\"params\":[],\"experiments\":[],\"chains\":[],\"encodedParams\":\"CgInBxIBAA==\"},\"triggers\":{}},\"abV2\":{\"config\":{\"paramMap\":{\"pc_mou_cre_remove\":{\"value\":\"0\"},\"ws_platform_new\":{\"value\":\"0\"},\"in_editor_title\":{\"value\":\"0\"},\"ws_pin_contentpub\":{\"value\":\"0\"},\"ws_pre_guess_his\":{\"value\":\"0\"}},\"abMap\":{}},\"triggers\":{}},\"userAgent\":{\"Edge\":false,\"IE\":false,\"Wechat\":false,\"Weibo\":false,\"QQ\":false,\"MQQBrowser\":false,\"Qzone\":false,\"Mobile\":false,\"Android\":false,\"iOS\":false,\"isAppleDevice\":false,\"Zhihu\":false,\"ZhihuHybrid\":false,\"isBot\":false,\"Tablet\":false,\"UC\":false,\"Quark\":false,\"Sogou\":false,\"Qihoo\":false,\"Baidu\":false,\"BaiduApp\":false,\"Safari\":false,\"GoogleBot\":false,\"AndroidDaily\":false,\"iOSDaily\":false,\"WxMiniProgram\":false,\"BaiduMiniProgram\":false,\"QQMiniProgram\":false,\"JDMiniProgram\":false,\"isWebView\":false,\"isMiniProgram\":false,\"origin\":\"python-requests\\u002F2.31.0\"},\"appViewConfig\":{},\"ctx\":{\"path\":\"\\u002Fsignin\",\"query\":{\"next\":\"\\u002F\"},\"href\":\"http:\\u002F\\u002Fwww.zhihu.com\\u002Fsignin?next=%2F\",\"host\":\"www.zhihu.com\"},\"trafficSource\":\"production\",\"edition\":{\"beijing\":false,\"baidu\":false,\"sogou\":false,\"baiduBeijing\":false,\"sogouBeijing\":false,\"sogouInput\":false,\"oppoSearch\":false,\"baiduSearch\":false,\"googleSearch\":false,\"shenma\":false,\"miniProgram\":false,\"xiaomi\":false,\"huaweiSearch\":false},\"theme\":\"light\",\"appHeaderTheme\":{\"current\":\"normal\",\"disable\":true,\"normal\":{\"bgColor\":\"GBK99A\"},\"custom\":{\"bgColor\":\"GBK99A\"}},\"enableShortcut\":true,\"referer\":\"\",\"xUDId\":\"\",\"mode\":\"ssr\",\"conf\":{},\"xTrafficFreeOrigin\":\"\",\"ipInfo\":{},\"logged\":false,\"vars\":{\"passThroughHeaders\":{}}},\"me\":{\"columnContributions\":[]},\"label\":{},\"ecommerce\":{},\"comments\":{\"pagination\":{},\"collapsed\":{},\"reverse\":{},\"reviewing\":{},\"conversation\":{},\"parent\":{}},\"commentsV2\":{\"stickers\":[],\"commentWithPicPermission\":{},\"notificationsComments\":{},\"pagination\":{},\"collapsed\":{},\"reverse\":{},\"reviewing\":{},\"conversation\":{},\"conversationMore\":{},\"parent\":{}},\"pushNotifications\":{\"default\":{\"isFetching\":false,\"isDrained\":false,\"ids\":[]},\"follow\":{\"isFetching\":false,\"isDrained\":false,\"ids\":[]},\"vote_thank\":{\"isFetching\":false,\"isDrained\":false,\"ids\":[]},\"currentTab\":\"default\",\"notificationsCount\":{\"default\":0,\"follow\":0,\"vote_thank\":0}},\"messages\":{\"data\":{},\"currentTab\":\"common\",\"messageCount\":0},\"register\":{\"registerValidateSucceeded\":null,\"registerValidateErrors\":{},\"registerConfirmError\":null,\"sendDigitsError\":null,\"registerConfirmSucceeded\":null},\"login\":{\"loginUnregisteredError\":false,\"loginBindWechatError\":false,\"loginConfirmError\":null,\"sendDigitsError\":null,\"needSMSIdentify\":false,\"validateDigitsError\":false,\"loginConfirmSucceeded\":null,\"qrcodeLoginToken\":\"\",\"qrcodeLoginScanStatus\":0,\"qrcodeLoginError\":null,\"qrcodeLoginReturnNewToken\":false},\"switches\":{},\"captcha\":{\"captchaNeeded\":false,\"captchaValidated\":false},\"sms\":{\"supportedCountries\":[]},\"chat\":{\"chats\":{},\"inbox\":{\"recents\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"strangers\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"friends\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"search\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"config\":{\"newCount\":0,\"strangerMessageSwitch\":false,\"strangerMessageUnread\":false,\"friendCount\":0}},\"global\":{\"isChatMqttExisted\":false}},\"emoticons\":{\"emoticonGroupList\":[],\"emoticonGroupDetail\":{}},\"creator\":{\"tools\":{\"question\":{\"invitationCount\":{\"questionFolloweeCount\":0,\"questionTotalCount\":0}},\"recommend\":{\"recommendTimes\":{}}},\"explore\":{},\"levelUpperLimit\":10,\"mcn\":{},\"mcnManage\":{},\"tasks\":{},\"announcement\":{},\"creatorsRecommendInfo\":{}},\"creators\":{\"common\":{\"applyStatus\":{},\"rightsStatus\":{}},\"bayesDomains\":{\"status\":{},\"options\":{\"topDomains\":null,\"allDomains\":null,\"editable\":0},\"contents\":null},\"school\":{\"tabs\":[],\"contents\":[],\"banner\":null,\"entities\":{}},\"faq\":{\"tabs\":[],\"article\":{}},\"knowledgeIncome\":{},\"safeguardRights\":{},\"analytics\":{\"all\":{},\"answer\":{},\"zvideo\":{},\"article\":{},\"pin\":{},\"singleContent\":{}},\"account\":{\"growthLevel\":{}},\"KMResource\":{},\"training\":{},\"ToolsQuestion\":{\"goodatTopics\":[]},\"ToolsHotspot\":{\"domains\":[]},\"ToolsRecommend\":{},\"ToolsCustomPromotion\":{\"itemLists\":{},\"baseInfo\":{}},\"ToolsSearchQuestion\":{},\"editorSetting\":{},\"MCNManage\":{},\"knowledgeTasks\":{},\"incomeAnalysis\":{\"income\":{\"aggregation\":{}}},\"creationManage\":{\"editModal\":{\"status\":false}},\"activity\":{},\"announcement\":{},\"home\":{\"currentCreatorUrlToken\":null,\"rights\":[],\"newRights\":[],\"scoreInfo\":{},\"menusShowControlByServer\":{\"bVipRecomend\":false,\"creationRelationship\":false},\"newTasks\":{\"creatorTask\":{\"tasks\":[],\"des\":[]}},\"bannerList\":[],\"recentlyCreated\":[],\"homecard\":{}},\"videoSupport\":{\"textBenefit\":{}},\"videoDistribution\":{},\"profilePoster\":{\"creatorPosterConfig\":{},\"creatorPosterData\":{}}},\"question\":{\"followers\":{},\"concernedFollowers\":{},\"answers\":{},\"hiddenAnswers\":{},\"updatedAnswers\":{},\"ariaAnswers\":{},\"collapsedAnswers\":{},\"notificationAnswers\":{},\"invitedQuestions\":{\"total\":{\"count\":null,\"isEnd\":false,\"isLoading\":false,\"questions\":[]},\"followees\":{\"count\":null,\"isEnd\":false,\"isLoading\":false,\"questions\":[]}},\"laterQuestions\":{\"count\":null,\"isEnd\":false,\"isLoading\":false,\"questions\":[]},\"waitingQuestions\":{\"recommend\":{\"isEnd\":false,\"isLoading\":false,\"questions\":[]},\"invite\":{\"isEnd\":false,\"isLoading\":false,\"questions\":[]},\"newest\":{\"isEnd\":false,\"isLoading\":false,\"questions\":[]},\"hot\":{\"isEnd\":false,\"isLoading\":false,\"questions\":[]}},\"invitationCandidates\":{},\"inviters\":{},\"invitees\":{},\"similarQuestions\":{},\"questionBanners\":{},\"relatedCommodities\":{},\"bio\":{},\"brand\":{},\"permission\":{},\"adverts\":{},\"advancedStyle\":{},\"commonAnswerCount\":0,\"hiddenAnswerCount\":0,\"topicMeta\":{},\"bluestarRanklist\":{},\"relatedSearch\":{},\"autoInvitation\":{},\"simpleConcernedFollowers\":{},\"draftStatus\":{},\"disclaimers\":{},\"isShowMobileSignInModal\":false},\"shareTexts\":{},\"answers\":{\"voters\":{},\"copyrightApplicants\":{},\"favlists\":{},\"newAnswer\":{},\"entityWords\":{},\"concernedUpvoters\":{},\"simpleConcernedUpvoters\":{},\"paidContent\":{},\"settings\":{}},\"banner\":{},\"topic\":{\"bios\":{},\"hot\":{},\"newest\":{},\"top\":{},\"sticky\":{},\"pin\":{},\"unanswered\":{},\"questions\":{},\"zivdeo\":{},\"zvideo-new\":{},\"followers\":{},\"contributors\":{},\"parent\":{},\"children\":{},\"bestAnswerers\":{},\"wikiMeta\":{},\"index\":{},\"intro\":{},\"meta\":{},\"schema\":{},\"creatorWall\":{},\"wikiEditInfo\":{},\"committedWiki\":{},\"landingBasicData\":{},\"landingExcellentItems\":[],\"landingExcellentEditors\":[],\"landingCatalog\":[],\"landingEntries\":{}},\"explore\":{\"recommendations\":{},\"specials\":{\"entities\":{},\"order\":[]},\"roundtables\":{\"entities\":{},\"order\":[]},\"collections\":{},\"columns\":{},\"square\":{\"hotQuestionList\":[],\"potentialList\":[]}},\"articles\":{\"voters\":{},\"concernedUpvoters\":{}},\"favlists\":{\"relations\":{}},\"pins\":{\"reviewing\":{}},\"topstory\":{\"recommend\":{\"isFetching\":false,\"isDrained\":false,\"afterId\":0,\"items\":[],\"next\":null},\"follow\":{\"isFetching\":false,\"isDrained\":false,\"afterId\":0,\"items\":[],\"next\":null},\"followWonderful\":{\"isFetching\":false,\"isDrained\":false,\"afterId\":0,\"items\":[],\"next\":null},\"sidebar\":null,\"announcement\":{},\"hotList\":[],\"hotListHeadZone\":[],\"guestFeeds\":{\"isFetching\":false,\"isDrained\":false,\"afterId\":0,\"items\":[],\"next\":null},\"followExtra\":{\"isNewUser\":null,\"isFetched\":false,\"followCount\":0,\"followers\":[]},\"hotDaily\":{\"data\":[],\"paging\":{}},\"hotHighlight\":{\"isFetching\":false,\"isDrained\":false,\"data\":[],\"paging\":{}},\"banner\":{},\"commercialBanner\":{\"show\":false,\"banner\":{},\"trackData\":{}},\"video\":{\"items\":[],\"next\":null,\"isLoading\":false,\"isDrained\":false}},\"upload\":{},\"video\":{\"data\":{},\"shareVideoDetail\":{},\"last\":{}},\"zvideos\":{\"campaignVideoList\":{},\"campaigns\":{},\"tagoreCategory\":[],\"recommendations\":{},\"insertable\":{},\"recruit\":{\"form\":{\"platform\":\"\",\"nickname\":\"\",\"followerCount\":\"\",\"domain\":\"\",\"contact\":\"\"},\"submited\":false,\"ranking\":[]},\"qyActivityData\":{},\"talkActivityData\":{},\"party2022ActivityData\":{},\"batchVideos\":{},\"contribution\":{\"selectedContribution\":null,\"campaign\":null,\"configs\":{},\"contributionLists\":{},\"recommendQuestions\":{\"isLoading\":true,\"paging\":{\"isEnd\":false,\"isStart\":true,\"totals\":0},\"data\":[]},\"questionSearchResults\":{\"isLoading\":true,\"paging\":{\"isEnd\":false,\"isStart\":true,\"totals\":0},\"data\":[]}},\"creationReferences\":{},\"zvideoCollection\":{},\"zvideoGrant\":{},\"collectData\":{\"isFetching\":false,\"list\":[]},\"videoSource\":{\"isLoaded\":false}},\"guide\":{\"guide\":{\"isFetching\":false,\"isShowGuide\":false}},\"reward\":{\"answer\":{},\"article\":{},\"question\":{}},\"search\":{\"recommendSearch\":[],\"topSearch\":{},\"searchValue\":{},\"suggestSearch\":{},\"attachedInfo\":{\"generalByQuery\":{}},\"nextOffset\":{\"generalByQuery\":{}},\"topicReview\":{},\"sidebar\":{},\"calendar\":{},\"scores\":null,\"majors\":{},\"university\":{},\"generalByQuery\":{},\"generalByQueryInADay\":{},\"generalByQueryInAWeek\":{},\"generalByQueryInThreeMonths\":{},\"peopleByQuery\":{},\"topicByQuery\":{},\"zvideoByQuery\":{},\"scholarByQuery\":{},\"columnByQuery\":{},\"liveByQuery\":{},\"albumByQuery\":{},\"eBookByQuery\":{},\"kmGeneralByQuery\":{},\"kmCourseByQuery\":{},\"customFilter\":{\"requestFinished\":false,\"keys\":[],\"tags\":[]}},\"creatorSalt\":{\"recommendQuestionList\":[],\"bannerList\":[],\"claimBannerList\":[],\"sites\":[],\"domains\":{},\"hasRecored\":false,\"hasClaim\":false,\"hasContributedList\":[],\"notContributedList\":[],\"contributesTotal\":null,\"previewPageTitle\":\"\",\"previewPageContent\":\"\",\"restContributionNumber\":\"-\"},\"publicEditPermission\":{},\"readStatus\":{},\"draftHistory\":{\"history\":{},\"drafts\":{}},\"notifications\":{\"recent\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"history\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"notificationActors\":{\"isFetching\":false,\"isDrained\":false,\"isPrevDrained\":false,\"result\":[],\"next\":null,\"key\":null},\"recentNotificationEntry\":\"all\"},\"specials\":{\"entities\":{},\"all\":{\"data\":[],\"paging\":{},\"isLoading\":false}},\"collections\":{\"hot\":{\"data\":[],\"paging\":{},\"isLoading\":false},\"collectionFeeds\":{}},\"userProfit\":{\"permission\":{\"permissionStatus\":{\"zhiZixuan\":0,\"recommend\":-1,\"task\":0,\"plugin\":0,\"infinity\":0},\"visible\":false},\"linkCardLimit\":0},\"mcn\":{\"bindInfo\":{},\"memberCategoryList\":[],\"producerList\":[],\"categoryList\":[],\"lists\":{},\"banners\":{},\"protocolStatus\":{\"isAgreedNew\":true,\"isAgreedOld\":true},\"probationCountdownDays\":0},\"mcnActivity\":{\"household\":{\"products\":{},\"rankList\":{\"total\":{},\"yesterday\":{}}}},\"brand\":{\"contentPlugin\":{}},\"host\":{\"roundtable\":{\"subjects\":{},\"applications\":{\"total\":0},\"online\":{\"total\":0},\"applies\":{},\"details\":{},\"includedResource\":{},\"hotQuestions\":{},\"warmupContents\":{},\"batchInclude\":{}},\"special\":{\"applications\":{\"total\":0,\"pages\":{},\"entities\":{}},\"censorHistory\":{},\"drafts\":{}}},\"campaign\":{\"single\":{},\"list\":{},\"videoMakerAcq\":{},\"vote\":{},\"cardCollecting\":{\"message\":null,\"profile\":{\"balance\":\"0\",\"chance\":0,\"coinNum\":0,\"gatherClose\":false,\"isGotMagicCard\":false,\"isPay\":false,\"partitionStart\":false,\"totalDone\":0,\"withdrawStart\":false},\"sharePoster\":{\"share\":\"\",\"sendCard\":\"\",\"invite\":\"\"},\"shareLink\":null,\"shareIntention\":\"share\",\"shareKey\":null,\"shareCardId\":null,\"inviterInfo\":null,\"giverInfo\":null,\"prize\":null,\"receivedCard\":null,\"newCoinCount\":null,\"newCardList\":[],\"newUserCardCount\":1,\"taskList\":[],\"prizeList\":null,\"cardList\":null,\"panel\":{\"showTaskPanel\":false,\"showRewardPanel\":false},\"modal\":{\"showWelcomeModal\":false,\"showFusionModal\":false,\"showFusionPromptModal\":false,\"showShareModal\":false,\"showBackModal\":false}},\"zhiboPandian2020\":null,\"boarding\":{},\"searchGaokaoSubPage\":{},\"searchHealth\":{}},\"knowledgePlan\":{\"lists\":{},\"allCreationRankList\":{},\"featuredQuestions\":{}},\"wallE\":{\"protectHistory\":{\"total\":0,\"pages\":{},\"entities\":{}}},\"roundtables\":{\"hotQuestions\":{},\"warmupContents\":{},\"hotDiscussions\":{},\"selectedContents\":{},\"roundtables\":{}},\"helpCenter\":{\"entities\":{\"question\":{},\"category\":{}},\"categories\":[],\"commonQuestions\":[],\"relatedQuestions\":{},\"faqTypes\":[]},\"republish\":{},\"commercialReport\":{\"commercialTypes\":[]},\"creatorMCN\":{\"mcn\":{},\"mcnStatistics\":{},\"mcnRight\":{\"bind\":false,\"coupon\":false},\"isNoAuth\":false,\"creatorManageData\":[],\"creatorManageDataTotal\":1,\"mcnDomains\":[],\"bill\":{\"list\":{},\"detail\":{}},\"healthScore\":{\"healthScore\":\"0\",\"updateTime\":\"\",\"evaluate\":\"\"},\"healthScoreRecordInfo\":{},\"statisticHealthScoreData\":{},\"beforeDownloadCheckResult\":{}},\"commentManage\":{\"commentList\":{\"ids\":[],\"entities\":{},\"nextOffset\":0,\"urlToken\":\"\"},\"subCommentList\":{\"ids\":[],\"entities\":{},\"paging\":{\"next\":\"\",\"isEnd\":false}}},\"commentPermission\":{},\"creatorRightStatus\":{\"list\":[]},\"zhiPlus\":{\"permissionStatus\":9999},\"streaming\":{},\"creationRanking\":{},\"eduSections\":{\"eduSectionState\":{}},\"adPromotion\":{\"answer\":{},\"article\":{}},\"editVideo\":{\"editVideoEnabled\":false}},\"subAppName\":\"main\",\"spanName\":\"SignInHomepage\",\"canaryConfig\":{\"test_canary\":\"0\",\"use_new_player\":\"0\",\"player_vendor\":\"0\",\"use_hevc\":\"0\",\"upload_use_signature\":\"0\",\"use_backdrop_blur\":\"0\",\"article_title_imagex\":\"0\",\"play_station\":\"0\"}}&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/heifetz/vendor.5f3e51e68d56265eb628.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/event/react@17.0.2/umd/react.production.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/event/react-dom@17.0.2/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/event/react-dom@17.0.2/umd/react-dom-server.browser.production.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/heifetz/runtime.app.8760bebdf90d45897a0d.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/heifetz/4929.app.93232f540dbf651a5a09.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/heifetz/main.app.eb2b01bfdddfa00395a2.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/heifetz/chunks/shared-1dffcf43329e08de9bcf385e1895bae6667163e6.15aea201598053659d31.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"\" src=\"https://static.zhihu.com/heifetz/chunks/main-signin-routes.27ef8a5c0983bd0928f3.js\"&gt;&lt;/script&gt;&lt;script defer=\"\" src=\"https://static.zhihu.com/event/wza/4613/aria.js?appid=a3637ace5dc3a347f6863b0bac487599\" id=\"ariascripts\" wapForceOldFixed=\"false\" loadData=\"false\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;script src=\"https://hm.baidu.com/hm.js?98beee57fd2ef70ccdd5ca52b9740c49\" async=\"\"&gt;&lt;/script&gt;&lt;/html&gt;\n\n\n通过使用 .get() 方法，我们已经完成了爬虫工作的第一步：获取网页的全部信息了。接下来，让我们学习一下关于 requests 库的其他操作。\n\n\n\n\ngraph TD\nid(Requests 库中\\n常见的请求方法) --&gt; id1(requests.get 发送 GET 请求)\nid --&gt; id2(response.ok 检查请求是否成功)\nid --&gt; id3(response.status_code 获取状态码)\nid --&gt; id4(response.headers 获取响应头)\nid --&gt; id5(response.text 获取服务器返回的文本内容)\nid --&gt; id6(requests.post 发送 POST 请求)\n\n\n\n\n\n\n\n2. 传递参数\n仔细回想上一节的内容，一个 HTTP 请求通常包含请求行、请求头和请求体，其中，请求头包含了请求的信息和附加内容，请求发起者的身份信息等等都包含在请求头之中。在我们使用 .get() 方法时，requests 库会自动帮我们生成请求头，但是这样一来，服务器很容易就能够知道请求发起者的身份是一个爬虫程序，而有些网站并不希望自己的服务对象是一个不能看广告的程序，就会拒绝我们的请求，就像 豆瓣电影https://movie.douban.com/top250 做的那样。因此，如果我们想要隐藏我们自己，就要指定信息进行修改。\n要对我们传递给服务器的信息进行修改，就要额外设置参数，比如：\n我们额外设置一个参数：headers，就像下面这样：\n\nimport requests\n\n\nheaders = {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36\"\n}\nresponse = requests.get(\"https://movie.douban.com/top250\", headers = headers)\nprint(response)\n\n&lt;Response [200]&gt;\n\n\n在上面的示例中，我们通过设置 headers 参数，将我们的身份模拟成了一个运行在 Windows 10 上的 Chrome 浏览器，观察服务器给我们的返回结果就可以发现，状态码从表示请求失败的 418 变为了代表请求成功的 200，我们的伪装成功骗过了网站的服务器。但是请先别急着骄傲，我们还没有大获全胜，如果你要爬取更多的信息，可能会触发网站的反爬虫机制，请让我们脚踏实地，一步步来。\n\n如果你想知道更多的 user-agent，可以试试看下面的方法： 1. 打开你的浏览器，按 F12 或 Ctrl + Shift + I(或 Cmd + Option + I 在 Mac 上)打开开发者工具，切换到 “Network” 或 “网络” 标签。 2. 刷新页面或执行所需的操作，浏览器就会生成一个HTTP请求。 3. 在开发者工具中，我们就将看到所有HTTP请求的列表。选择其中一个请求，然后在右侧的 “Headers” 或 “标头” 部分查找 “User-Agent” 头部，就可以看到浏览器的User-Agent信息。\n\n\n在 requests 库中，你可以使用参数来自定义和配置HTTP请求。这些参数通常是键值对，用于指定请求的一些特定要求或信息。以下是 requests 库中常见的一些参数及其用法：\n1. params： 用于向URL添加查询字符串参数，常用于GET请求。\n\nimport requests\n\nparams = {\"key1\": \"value1\", \"key2\": \"value2\"}\nresponse = requests.get(\"https://www.example.com/api\", params=params)\n\n在上述示例中，params 参数将被添加到URL中，形成类似于 https://www.example.com/api?key1=value1&key2=value2 的请求。\n2. headers：用于设置 HTTP 请求的头部信息，包括用户代理、授权信息等。\n\nimport requests\n\nheaders = {\"User-Agent\": \"MyApp/1.0\", \"Authorization\": \"Bearer token\"}\nresponse = requests.get(\"https://www.example.com\", headers=headers)\n\n使用 headers 参数，您可以模拟不同的用户代理或提供身份验证信息。\n3. data：用于发送表单数据或请求主体数据，通常与 POST 请求一起使用。\n\nimport requests\n\ndata = {\"username\": \"user\", \"password\": \"pass\"}\nresponse = requests.post(\"https://www.example.com/login\", data=data)\n\ndata 参数允许您将数据以表单形式发送给服务器。\n4. json：用于发送 JSON 数据，通常与 POST 请求一起使用。\n\nimport requests\n\njson_data = {\"key\": \"value\"}\nresponse = requests.post(\"https://www.example.com/api\", json=json_data)\n\njson 参数允许您以 JSON 格式发送数据给服务器。\n5. auth：用于进行基本身份验证，需要提供用户名和密码。\n\nimport requests\n\nauth = (\"username\", \"password\")\nresponse = requests.get(\"https://www.example.com/secure\", auth=auth)\n\nauth 参数用于访问需要身份验证的资源。\n6. cookies：用于发送请求时附带的 Cookies 信息。\n\nimport requests\n\ncookies = {\"session_id\": \"1234567890\"}\nresponse = requests.get(\"https://www.example.com/profile\", cookies=cookies)\n\ncookies 参数可用于模拟登录状态或其他需要使用 Cookies 的情况。\n7. files：用于上传文件，通常与 POST 请求一起使用。\n\nimport requests\n\nfiles = {\"file\": open(\"data.txt\", \"rb\")}\nresponse = requests.post(\"https://www.example.com/upload\", files=files)\n\nfiles 参数允许您上传文件。\n8. timeout：用于设置请求的超时时间，防止长时间等待响应。\n\nimport requests\n\nresponse = requests.get(\"https://www.example.com\", timeout=5)\n\ntimeout 参数指定了等待服务器响应的最大秒数。\n这些参数允许我们非常自由的自定义我们的请求内容，满足我们不同的需求，多多在编辑器里尝试一下，你会进步的很快。\n\n\n\n\ngraph TD\nid(Requests 库中\\n常见的可自定义参数) --&gt; id1(params 添加查询字符串参数)\nid --&gt; id2(headers 设置 HTTP 请求头)\nid --&gt; id3(data 发送表单数据或请求主体数据\\n通常与 POST 请求一起使用)\nid --&gt; id4(json 以 JSON 格式发送数据\\n通常与 POST 请求一起使用)\nid --&gt; id5(auth 进行基本身份验证)\nid --&gt; id6(cookies 发送请求时附带Cookies信息)\nid --&gt; id7(files 上传文件\\n通常与 POST 请求一起使用)\nid --&gt; id8(timeout 设置请求超时时间)\n\n\n\n\n\n\n\n3. 发送 POST 请求\n使用 requests 库，除了可以向服务器发送 GET 请求，还可以发送 POST 请求。发送 POST 请求的方法与传递参数的方法类似，都需要我们设置一个额外的参数。只不过此时，我们要设置的参数就是：data，并且，使用的方法变成了 .post 方法。\n先来看看下面的例子：\n\nimport requests\n\n\n# 定义要提交的数据，可以是表单数据或 JSON 数据\ndata = {\n    \"key1\": \"value1\",\n    \"key2\": \"value2\"\n}\n\n# 使用 requests.post() 发送 POST 请求\nresponse = requests.post(\"https://www.example.com/api\", data=data)\n\n# 处理响应\nif response.status_code == 200:\n    print(\"POST 请求成功\")\n    print(response.text)\nelse:\n    print(\"POST 请求失败\")\n\nPOST 请求失败\n\n\n我们首先定义了要提交的数据，可以是一个字典，表示表单数据。然后，我们使用 requests.post() 方法发送 POST 请求到指定的 URL，同时将数据传递给 data 参数。最后，我们检查响应的状态码，如果状态码为 200，则表示请求成功，并打印响应内容。在上面的示例中，由于我们准备的网址 https://www.example.com/api 是一个不存在的网址，因此我们发送的请求会失败，请不用担心。\n这样一来，我们就完成了 requests 库的基础学习，在后面的学习中，我们可以自如地使用 requests 库来抓取网页的内容了。当然，requests 库还有许多其他的功能，比如处理 HTTP 请求异常，这部分大家可以根据自己的精力选择性学习。\n\n\n4. 处理异常\n在使用 requests 库进行网络请求时，可以通过捕获和处理异常来增强代码的健壮性，以应对网络请求过程中可能出现的各种异常情况。以下是一些常见的网络请求异常以及如何处理它们的详细介绍：\n\n(1) 请求错误异常(RequestException)\n请求错误异常是一种捕获网络请求过程中各种错误的通用异常。使用 requests 库中的 requests.exceptions.RequestException 方法，它可以捕获请求超时、连接错误、DNS 解析错误等各种可能的问题。\n\nimport requests\n\n\ntry:\n    response = requests.get(\"https://www.example.com\")\n    response.raise_for_status()  # 检查是否有错误的响应状态码\nexcept requests.exceptions.RequestException as e:\n    print(f\"请求发生错误：{e}\")\n\n\n\n(2) 请求超时异常(Timeout)\n请求超时异常是指在规定的时间内没有接收到服务器的响应。可以使用 timeout 参数来设置请求的最大等待时间。如果超过指定的时间仍未收到响应，将引发 requests.exceptions.Timeout 异常。\n\nimport requests\n\n\ntry:\n    response = requests.get(\"https://www.example.com\", timeout=5)  # 设置超时时间为5秒\n    response.raise_for_status()  # 检查是否有错误的响应状态码\nexcept requests.exceptions.Timeout:\n    print(\"请求超时，请检查网络连接或增加超时时间。\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"请求发生错误：{e}\")\n\n\n\n(3) 连接错误异常(ConnectionError)\n连接错误异常是指在建立与服务器的连接时出现问题，可能是因为无法连接到服务器或目标服务器不可达，使用 requests.exceptions.ConnectionError 来检查是否出现连接错误异常。\n\nimport requests\n\n\ntry:\n    response = requests.get(\"https://www.example.com\")\n    response.raise_for_status()  # 检查是否有错误的响应状态码\nexcept requests.exceptions.ConnectionError:\n    print(\"无法连接到服务器，请检查网络连接或服务器是否可达。\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"请求发生错误：{e}\")\n\n\n\n(4) HTTP错误异常(HTTPError)\nHTTP错误异常是指服务器返回了一个不成功的HTTP响应状态码（如4xx或5xx），表示请求未成功完成。可以使用 response.raise_for_status() 方法来检查响应状态码，如果状态码表明请求失败，将引发 requests.exceptions.HTTPError 异常。\n\nimport requests\n\n\ntry:\n    response = requests.get(\"https://www.example.com\")\n    response.raise_for_status()  # 检查是否有错误的响应状态码\nexcept requests.exceptions.HTTPError as e:\n    print(f\"HTTP错误：{e}\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"请求发生错误：{e}\")\n\n通过适当捕获和处理这些异常，我们可以确保您的网络请求代码在面对问题时能够进行适当的处理，以提高代码的稳定性和可靠性。"
  },
  {
    "objectID": "05_03_BeautifulSoup库.html#beautifulsoup-库",
    "href": "05_03_BeautifulSoup库.html#beautifulsoup-库",
    "title": "17  BeautifulSoup 库",
    "section": "BeautifulSoup 库",
    "text": "BeautifulSoup 库\n\n一、BeautifulSoup 库的安装与使用\nBeautifulSoup 库是一个 Python 库，用于从 HTML 和 XML 文档中提取数据，解析文档结构，并使其易于浏览和操作。BeautifulSoup 库的主要目标是使数据抽取和处理变得简单、可靠，并且支持 Python 标准库中的多种解析器。在本次学习中，我们将使用 BeautifulSoup 库来解析上一节中，使用 Requests 库获取到的数据。\n\nBeautifulSoup 库的官方文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/\n🤔BeautifulSoup 库作为世界上最流行的 Python 爬虫解析库之一，它有中文名字吗？直接翻译过来应该叫做“美丽汤”库，不过我们或许可以叫它“美汁汁”库！😆😆🥳🥳🙌🙌🎉🎊\n\n作为一个第三方库，BeautifulSoup 库和其他所有库一样，在使用前需要进行安装，输入下面的代码，然后重启你的内核：\n\n!pip install beautifulsoup4\n\nBeautifulSoup 库一共支持四种解析器，下面的表格详细展示了各个解析器的优缺点以及使用方法；\n\n\n\n\n\n\n\n\n\n解析器\n使用方法\n优势\n劣势\n\n\n\n\nPython 标准库\nBeautifulSoup(待处理对象, \"html.parser\")\n- Python的内置标准库- 执行速度适中- 文档容错能力强\n- Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差\n\n\nlxml HTML 解析器\nBeautifulSoup(markup, \"lxml\")\n- 速度快- 文档容错能力强\n- 需要安装C语言库\n\n\nlxml XML 解析器\nBeautifulSoup(markup, [\"lxml-xml\"])orBeautifulSoup(markup, \"xml\")\n- 速度快- 唯一支持XML的解析器\n- 需要安装C语言库\n\n\nhtml5lib\nBeautifulSoup(markup, \"html5lib\")\n- 最好的容错性- 以浏览器的方式解析文档- 生成HTML5格式的文档\n- 速度慢- 不依赖外部扩展\n\n\n\n看着中间两项解析器，你有没有一点儿熟悉？没错，这就是我们在学习 XPath 时了解过的 lxml 库！在后面的学习中，我们大多使用这个解析器。仔细看它的劣势：需要安装 C 语言库，即使我们曾经安装过，但是为了以防万一，还是保险一点儿好。尝试下面的安装代码：\n\n!pip install lxml\n\n现在你已经做好了前置工作，试试看下面的代码，看看能否正常工作：\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\nhtml = requests.get('https://www.baidu.com')\nhtml.encoding = 'utf-8'\nsoup = BeautifulSoup(html.text,'lxml')\nprint(soup)\n\n&lt;!DOCTYPE html&gt;\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta content=\"text/html;charset=utf-8\" http-equiv=\"content-type\"/&gt;&lt;meta content=\"IE=Edge\" http-equiv=\"X-UA-Compatible\"/&gt;&lt;meta content=\"always\" name=\"referrer\"/&gt;&lt;link href=\"https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css\" rel=\"stylesheet\" type=\"text/css\"/&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=\"#0000cc\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"head\"&gt; &lt;div class=\"head_wrapper\"&gt; &lt;div class=\"s_form\"&gt; &lt;div class=\"s_form_wrapper\"&gt; &lt;div id=\"lg\"&gt; &lt;img height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\"/&gt; &lt;/div&gt; &lt;form action=\"//www.baidu.com/s\" class=\"fm\" id=\"form\" name=\"f\"&gt; &lt;input name=\"bdorz_come\" type=\"hidden\" value=\"1\"/&gt; &lt;input name=\"ie\" type=\"hidden\" value=\"utf-8\"/&gt; &lt;input name=\"f\" type=\"hidden\" value=\"8\"/&gt; &lt;input name=\"rsv_bp\" type=\"hidden\" value=\"1\"/&gt; &lt;input name=\"rsv_idx\" type=\"hidden\" value=\"1\"/&gt; &lt;input name=\"tn\" type=\"hidden\" value=\"baidu\"/&gt;&lt;span class=\"bg s_ipt_wr\"&gt;&lt;input autocomplete=\"off\" autofocus=\"autofocus\" class=\"s_ipt\" id=\"kw\" maxlength=\"255\" name=\"wd\" value=\"\"/&gt;&lt;/span&gt;&lt;span class=\"bg s_btn_wr\"&gt;&lt;input autofocus=\"\" class=\"bg s_btn\" id=\"su\" type=\"submit\" value=\"百度一下\"/&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"u1\"&gt; &lt;a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\"&gt;新闻&lt;/a&gt; &lt;a class=\"mnav\" href=\"https://www.hao123.com\" name=\"tj_trhao123\"&gt;hao123&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://map.baidu.com\" name=\"tj_trmap\"&gt;地图&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://v.baidu.com\" name=\"tj_trvideo\"&gt;视频&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://tieba.baidu.com\" name=\"tj_trtieba\"&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a class=\"lb\" href=\"http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1\" name=\"tj_login\"&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write('&lt;a href=\"http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === \"\" ? \"?\" : \"&\")+ \"bdorz_come=1\")+ '\" name=\"tj_login\" class=\"lb\"&gt;登录&lt;/a&gt;');\n                &lt;/script&gt; &lt;a class=\"bri\" href=\"//www.baidu.com/more/\" name=\"tj_briicon\" style=\"display: block;\"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"ftCon\"&gt; &lt;div id=\"ftConw\"&gt; &lt;p id=\"lh\"&gt; &lt;a href=\"http://home.baidu.com\"&gt;关于百度&lt;/a&gt; &lt;a href=\"http://ir.baidu.com\"&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=\"cp\"&gt;©2017 Baidu &lt;a href=\"http://www.baidu.com/duty/\"&gt;使用百度前必读&lt;/a&gt;  &lt;a class=\"cp-feedback\" href=\"http://jianyi.baidu.com/\"&gt;意见反馈&lt;/a&gt; 京ICP证030173号  &lt;img src=\"//www.baidu.com/img/gs.gif\"/&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;\n\n\n\n使用上面的代码，你将获得由 BeautifulSoup 解析好的 HTML 文档。\n\n\n\n\n\n\nNote\n\n\n\n小提示：\n如果你觉得直接输出的 HTML 过于大块而且难看，可以使用 .prettify() 方法进行输出，就和这个方法的名字一样，会让你的输出变得漂亮起来！🦋🦋\n将上面的输出代码替换成：\nprint(soup.prettify())\n\n\n使用 BeautifulSoup 库解析 HTML 文档看上去是不是十分简单？就像表格里面列出来的那样，你只需要将文件传递给 BeautifulSoup，然后指定解析器，它就会自动开始工作了！\n\nBeautifulSoup(待处理对象, \"解析器\")\n\n\n\n二、BeautifulSoup 库的对象类型\nBeautifulSoup 库解析复杂 HTML 文档的方式是将 HTML 文档转换为一个复杂的树形结构，每个节点都是 Python 对象。在 BeautifulSoup 中，对象一共可以归纳为 4 种。\n\n1. Tag 标签\nTag 对象，就是 HTML 原生文档中的标签，每个 Tag 对象都代表文档中的一个具体标签。对于 Tag 对象，我们主要学习其最重要的两个属性：\n\n(1) name 标签名\nname 属性是 Tag 属性中最重要的属性之一，该属性用于表示标签的名称，允许永固访问和修改标签的名称。\n\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;div class=\"container\"&gt;\n    &lt;p&gt;这是一个段落。&lt;/p&gt;\n&lt;/div&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'lxml')\ndiv_tag = soup.find('div')\n\n# 访问标签的名称\nprint(\"标签名称:\", div_tag.name)\n\n标签名称: div\n\n\n在上面的示例中，我们定义了一个简短的 HTML 字符串，然后通过 BeautifulSoup 中的 lxml 解析器来解析它。随后，我们通过 .find() 方法找到了标签 &lt;div&gt;，最后，使用 name 属性将其的标签名成功输出出来了。\n\n\n\n\n\n\nNote\n\n\n\n.find() 方法\n.find() 方法是 BeautifulSoup 库中最常用的查找文档中第一个匹配指定条件的标签的方法。其语法为：\nfind(name, attrs, recursive, text)\n参数解释：\n\nname：要查找的标签的名称或标签名列表。可以是字符串，正则表达式，函数，或它们的组合。例如，'a' 表示查找 &lt;a&gt; 标签，['a', 'div'] 表示查找 &lt;a&gt; 或 &lt;div&gt; 标签。\nattrs：可选参数，用于指定要匹配的标签的属性字典。例如，{'class': 'example', 'id': 'content'} 表示查找具有特定类和 ID 属性的标签。\nrecursive：可选参数，控制是否在标签的所有子孙层次中查找。默认为 True，表示查找所有子孙标签，如果设置为 False，只会在直接子标签中查找。\ntext：可选参数，用于查找标签内的文本内容。可以是字符串，正则表达式，函数，或它们的组合。\n\n.find() 方法的返回值是第一个满足条件的标签对象，如果找不到匹配的标签，则返回 None。\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;p&gt;第一段.&lt;/p&gt;\n    &lt;div class=\"example\"&gt;这是一个 div.&lt;/div&gt;\n    &lt;a href=\"https://www.example.com\"&gt;点这里&lt;/a&gt;\n    &lt;a href=\"https://www.example_2.com\"&gt;咔哒咔哒&lt;/a&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'html.parser')\n\n# 查找第一个&lt;p&gt;标签\nparagraph = soup.find('p')\nprint(paragraph)\n# 查找具有'class'属性为'example'的第一个&lt;div&gt;标签\ndiv_with_class = soup.find('div', class_='example')\nprint(div_with_class)\n# 查找第一个包含指定文本的标签\nlink = soup.find(string='点这里')\nprint(link)\n# 查找具有属性'href'的第一个&lt;a&gt;标签\nanchor_with_href = soup.find('a', href=True)\nprint(anchor_with_href)\n另外，你还可以使用 .find_all 方法获取所有的符合条件的标签\n# 查找所有的&lt;a&gt;标签，返回列表\nall_links = soup.find_all('a')\nprint(all_links)\n\n\n通过访问标签名，我们可以找到我们所需要的数据结构，以支持我们对 HTML 文档进行数据提取、条件筛选等操作。\nBeautifulSoup 库还支持修改标签名，当我们需要重构 HTML 文档或者进行数据清洗时，就可以使用 replace_with() 方法来更改标签名。\n\n# 更改标签名为 'section'\ndiv_tag.name = 'section'\n\n# 打印修改后的标签\nprint(div_tag)\n\n&lt;section class=\"container\"&gt;\n&lt;p&gt;这是一个段落。&lt;/p&gt;\n&lt;/section&gt;\n\n\n将这段代码添加到上一段示例代码之后，运行它，你会发现，我们定义的 HTML 字符串中的 &lt;div&gt; 标签被替换为了 &lt;section&gt; 标签。这样一来，我们就通过访问和变更 name 属性，对文档的结构进行了调整。\n在变更标签的 name 属性时，需要非常谨慎的操作，以确保不破坏文档的结构和语义。\n\n\n(2) Attributes 属性\n在 HTML 文档中，Attributes 是与标签关联的额外信息，通常以“键-值”对的形式出现，其中“键”表示属性的名称，“值”表示属性的值。\n\n看到“键-值”对，你有没有想起来什么？🤔没错！就是字典！属性在 BeautifulSoup 中通常以字典的形式表示，Tag 的属性的操作方法与字典相同。这意味着，Tag 的属性可以被添加、修改和删除！\n\n要访问某个 Tag 的属性，我们可以使用 .attrs 方法。如：\n\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;a href=\"https://www.example.com\" class=\"link\"&gt;Click here&lt;/a&gt;\n&lt;img src=\"image.jpg\" alt=\"An example image\"&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'lxml')\n\n# 获取 &lt;a&gt; 标签的属性字典\na_tag = soup.find('a')\na_attrs = a_tag.attrs\n\n# 输出 &lt;a&gt; 标签的属性\nprint(a_attrs)\n\n{'href': 'https://www.example.com', 'class': ['link']}\n\n\n在上面的示例中，我们在解析完 HTML 字符串以后，首先使用 .find() 方法定位，找到了 &lt;a&gt; 标签，随后，使用 .attrs 方法获取了 &lt;a&gt; 标签的属性列表。\n如果你想要指定某个属性进行获取，可以直接在指定的标签后使用 [] 来获取该属性，语法为：\n\ntag['属性']\n\n继续使用上面的例子来获取指定的属性：\n\n# 获取&lt;a&gt;标签的属性字典\na_tag = soup.find('a')\na_attrs = a_tag.attrs\n\n# 访问属性\nprint(\"链接地址:\", a_attrs['href'])\nprint(\"类名:\", a_attrs['class'])\n\n# 获取&lt;img&gt;标签的属性字典\nimg_tag = soup.find('img')\nimg_attrs = img_tag.attrs\n\n# 访问属性\nprint(\"图片源:\", img_attrs['src'])\nprint(\"替代文本:\", img_attrs['alt'])\n\n链接地址: https://www.example.com\n类名: ['link']\n图片源: image.jpg\n替代文本: An example image\n\n\n在上面的例子中，我们使用 a_attrs 和 img_attrs 分别获取了标签 &lt;a&gt; 和 &lt;img&gt; 的属性字典，然后，我们使用字典的方式访问这些标签的属性，例如，使用 a_attrs['href'] 来获取链接地址。字典形式的属性让我们能够轻松地检索和操作标签的属性信息，便于数据的提取和文档处理。\n另外，你还可以使用 .get() 方法来获取指定的属性：\n\ntag.get('属性')\n\n但是我们并不推荐这种方式，使用字典的方式来操作标签的属性，既直观又容易记忆，你只需要记住，tag 的属性操作方法与字典一样就可以了。\n\n\n\n2. NavigableString 可以遍历的字符串\nNavigableString 顾名思义，就是可以遍历的字符串。在 HTML 文档中，字符串通常包含在 Tag 内，因此，NavigableString 用于表示标签内的文本内容。当 BeautifulSoup 解析 HTML 或 XML 文档时，它会将标签内的文本作为 NavigableString 对象来表示，从而可以访问和操作这些文本内容。\nNavigableString 字符串与 Python 中的字符串的属性相同，你可以对 NavigableString 对象的文本内容进行我们在 Python 基础中学过的那些字符串操作，包括字符串的方法、切片、查找、替换等等。你甚至可以直接使用 unicode() 方法将 NavigableString 转换成 Python 中的 Unicode 字符串。\n使用 .string 方法获取 NavigableString 的文本内容，就像下面这样：\n\nfrom bs4 import BeautifulSoup, NavigableString\n\nhtml_doc = \"\"\"\n&lt;p&gt;这是一段话吱吱吱&lt;/p&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'lxml')\n\n# 获取&lt;p&gt;标签内的文本内容，返回一个NavigableString对象\np_tag = soup.find('p')\ntext_inside_p = p_tag.string\n\n# 打印文本内容\nprint(\"文本内容:\", text_inside_p)\nprint(\"对象类型:\", type(text_inside_p))\n\n文本内容: 这是一段话吱吱吱\n对象类型: &lt;class 'bs4.element.NavigableString'&gt;\n\n\n在上面的例子中，我们获取了 &lt;p&gt; 标签内的文本内容，并且将其输出了出来，同时还检查了其类型，为：&lt;class 'bs4.element.NavigableString'&gt;。\n需要注意的是，Tag 中的字符串不能直接编辑，但可以被替换为其他字符串。要实现这一操作，我们可以使用 replace_with() 方法。\n\n# 替换文本内容\np_tag.replace_with(\"这是一段话喵喵喵\")\ntext_inside_p = p_tag.string\n\n# 打印文本内容\nprint(\"文本内容:\", text_inside_p)\n\n文本内容: 这是一段话吱吱吱\n\n\n\n\n3. Comment 注释及特殊字符串\n在 BeautifulSoup 中，注释是一个特殊的类型，使用 Comment 表示，代表 HTML 文档中的注释内容。Comment 对象通常被包裹在 &lt;!-- 和 --&gt; 标记之间，只可以读取，不可以修改。\nComment 对象的特殊点在于，它和 NavigableString 一样，也可以通过 .string 属性访问，访问的结果将返回注释的文本内容。但是在进行爬虫操作时，我们常常不需要爬取注释内容，因此，在使用爬虫时，要格外注意 HTML 文档中的注释内容。下面的例子有些难以理解，不要着急，仔细阅读它。\n\n\n\n\n\n\nNote\n\n\n\n要判断一个对象是不是 Comment 类型，我们可以使用 isinstance(待判断对象，判断格式) 方法。这个函数结构两个参数，一个是待判断的对象，另外一个是我们想要判断的格式。举例来说，就像下面这样：\nisinstance(my_comment, Comment)\n这个例子使用 isinstance() 方法，来检查 my_comment 对象是不是 Comment 类型。\n\n\n\nfrom bs4 import BeautifulSoup, Comment\n\nhtml_doc = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;p&gt;这是一个段落。&lt;/p&gt;\n    &lt;!-- 这是一个注释。 --&gt;\n    &lt;div&gt;\n        &lt;p&gt;这是另外一个锻炼。&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'html.parser')\n\n# 查找所有注释并打印其内容\ncomments = soup.find_all(string=lambda text: isinstance(text, Comment))\nfor comment in comments:\n    print(\"注释内容:\", comment.string)\n    print(\"对象类型:\", type(comment.string))\n\n注释内容:  这是一个注释。 \n对象类型: &lt;class 'bs4.element.Comment'&gt;\n\n\n在上面的例子中，我们首先使用 find_all 方法，想要用它来找到所有符合我们要求的对象；然后，我们在括号内传入了一个表达式 string=lambda text: isinstance(text, Comment)，其中，string 参数用于指定我们要查找的内容，匿名函数 lambda text: isinstance(text, Comment) 用来对我们要查找的内容做出条件判断，对每个文本内容进行检查，看它是否是一个 Comment 对象；最后，我们使用了一个循环，将所有查询到的 Comment 对象都输出出来了。\n\n\n4. BeautifulSoup\n最后一个对象，看起来是不是很奇怪？🤔😆你没有眼花！最后一个对象就是 BeautifulSoup 对象。它是 BeautifSoup 库中的主要对象，表示一个文档的全部内容。它通常用于解析和操作 HTML 或 XML 文档。BeautifulSoup 对象提供了许多方法和属性，使我们能够轻松地遍历文档、查找标签、提取数据和修改文档的内容。\n\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;举一个例子🌰&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;这是一个段落&lt;/p&gt;\n    &lt;a href=\"https://www.example.com\"&gt;点击！点击！🖱️&lt;/a&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n# 创建BeautifulSoup对象并指定解析器\nsoup = BeautifulSoup(html_doc, 'lxml')\n\n# 查看BeautifuiSoup对象的属性\nprint(soup.name)\nprint(soup.attrs)\nprint(type(soup))\n\n[document]\n{}\n&lt;class 'bs4.BeautifulSoup'&gt;\n\n\n你会发现 BeautifulSoup 对象的属性列表为空，这是因为 BeautifulSoup 对象并不是一个真正的 Tag，它没有常规的 name 和 attribute 属性。上面的示例中所查看到的 name 属性是 BeautifulSoup 对象的一个特殊属性。\n\n\n\n三、遍历文档树\n\n1. 文档树基础\nBeautifulSoup 中的文档树是一个抽象的树状结构，用于表示 HTML 文档的层次结构和关系。文档树包含标签、文本内容、注释、特殊字符等各种元素，以及它们之间的嵌套关系。\n对于文档树，我们要了解的部分主要有：\n\n\n\n\ngraph LR\nid(文档树) --&gt; id1(组成元素)\nid --&gt; id2(元素之间的关系)\nid1 --&gt; id3(根元素)\nid1 --&gt; id4(标签)\nid1 --&gt; id5(文本内容)\nid1 --&gt; id6(属性)\nid1 --&gt; id7(注释)\nid2 --&gt; id10(父子关系)\nid2 --&gt; id11(兄弟关系)\nid2 --&gt; id12(前后节点)\n\n\n\n\n\n文档树的组成元素，我们已经在上面进行了一定的了解，接下来，让我们一起来看看元素之间关系，了解文档树的构成 。\n\n\n2. 元素间的关系\n\n\n\n\n\n\nNote\n\n\n\n我们已经在上面了解过，操作文档树最简单的方式就是使用 Tag 的名字，通过直接使用标签的名字，就可以获取标签的内容，只需要在 BeautifulSoup 对象后跟上 Tag 的名字就可以了。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;简短的HTML示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;欢迎来到我的网站&lt;/h1&gt;\n    &lt;p&gt;这是一个简短的HTML示例。&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;项目1&lt;/li&gt;\n        &lt;li&gt;项目2&lt;/li&gt;\n        &lt;li&gt;项目3&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n这个方法是可以多次使用的，例如：\nprint(soup.body.h1.p)\n但需要注意的是，点取属性的方式只能获得指定标签名的第一个 Tag，如果想要获得所有的指定标签名的 Tag，可以使用 find_all() 方法。\nprint(soup.find_all('li'))\n\n\n\n(1) 父子关系\n在文档树中，父子关系节点是最常见的节点关系。BeautifulSoup 提供了许多方法来对父子关系节点进行操作。\n\n获取子节点\n想要获取某一个 Tag 的子节点，可以使用 .contents 属性。.contents 属性可以将 Tag 的子节点以列表的方式输出。\n\n\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;父子关系示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"parent\"&gt;\n        &lt;h1&gt;这是一个标题&lt;/h1&gt;\n        &lt;p&gt;这是一个段落。&lt;/p&gt;\n        &lt;ul&gt;\n            &lt;li&gt;列表项1&lt;/li&gt;\n            &lt;li&gt;列表项2&lt;/li&gt;\n            &lt;li&gt;列表项3&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'lxml')\n\n# 使用 contents 方式获取子节点\nhead_tag = soup.head\nhead_tag_contents = head_tag.contents\n\n# 输出获取结果\nprint(head_tag_contents)\n\n['\\n', &lt;title&gt;父子关系示例&lt;/title&gt;, '\\n']\n\n\n需要注意的是，由于字符串没有子节点，因此字符串不可以使用 .contents 属性。幸运的是，我们还有另外一种方法：.children。这个方法返回的是子节点的迭代器，需要用循环来输出其中的内容。\n\ntitle_tag =soup.title\nfor child in title_tag.children:\n    print(child)\n\n父子关系示例\n\n\n.contents 和 .children 属性仅包含 tag 的直接子节点，如果想要将一个 Tag 的全部子节点都输出出来，可以使用 .descendants 属性。.descendants 可以获取到指定标签下的所有子孙标签，但是该方法也是返回的子孙节点的迭代器，因此也要使用循环来i遍历所有的子孙标签。\n\n# 找到起始标签\ndiv_tag = soup.find('div')\n\n# 使用 .descendants 遍历所有子孙标签\nfor tag in div_tag.descendants:\n    if tag.name is not None:  # 检查标签是否有名字，避免处理字符串\n        print(tag.name)\n\nh1\np\nul\nli\nli\nli\n\n\n\n获取父节点\n\n与子节点的获取相对应，BeautifulSoup 也提供了获取父节点的方法。我们可以通过 .parent 属性来获取某个元素的父节点。\n\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;父子关系示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"parent\"&gt;\n        &lt;h1&gt;这是一个标题&lt;/h1&gt;\n        &lt;p&gt;这是一个段落。&lt;/p&gt;\n        &lt;ul&gt;\n            &lt;li&gt;列表项1&lt;/li&gt;\n            &lt;li&gt;列表项2&lt;/li&gt;\n            &lt;li&gt;列表项3&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'lxml')\n\n# 使用 parent 方式获取父节点\ntitle_tag = soup.title\nprint(title_tag.parent)\n\n&lt;head&gt;\n&lt;title&gt;父子关系示例&lt;/title&gt;\n&lt;/head&gt;\n\n\n与子节点不同的是，字符串也有父节点，就是它本身：\n\nprint(title_tag.string.parent)\n\n&lt;title&gt;父子关系示例&lt;/title&gt;\n\n\n文档的顶层节点的父节点是 BeautifulSoup 对象：\n\nhtml_tag = soup.html\nprint(type(html_tag.parent))\n\n&lt;class 'bs4.BeautifulSoup'&gt;\n\n\nBeautifulSoup 对象的父节点是 None：\n\nprint(soup.parent)\n\nNone\n\n\n另外的，使用 .parents 属性可以递归得到元素的所有父辈节点，但与属性类似，想要使用循环才能遍历完某标签的所有父辈节点。\n\nli = soup.li\n\nfor parent in li.parents:\n    if parent is None:\n        print(parent)\n    else:\n        print(parent.name)\n\nAttributeError: 'NoneType' object has no attribute 'parents'\n\n\n\n\n(2) 兄弟关系\n拥有同一个父节点，且处于同一缩进级别的节点就是兄弟节点。使用 .next_sibling 来查询下一个兄弟节点，.previous_sibling 来查询上一个兄弟节点。\n\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;兄弟标签示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;兄弟标签示例&lt;/h1&gt;\n    &lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;a&gt;这是第二个段落。&lt;/a&gt;\n    &lt;p&gt;这是第三个段落。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, 'lxml')\n\n# 使用.next_sibling获取下一个兄弟节点\nsibling_soup = soup.p.next_sibling\nprint(\"第一个&lt;p&gt;标签的下一个兄弟节点是：\", sibling_soup)\n\n# 使用.previous_sibling获取上一个兄弟节点\nsibling_soup_2 = soup.a.previous_sibling\nprint(\"标签&lt;a&gt;的上一个兄弟节点是：\", sibling_soup_2)\n\n第一个&lt;p&gt;标签的下一个兄弟节点是： &lt;a&gt;这是第二个段落。&lt;/a&gt;\n标签&lt;a&gt;的上一个兄弟节点是： &lt;p&gt;这是第一个段落。&lt;/p&gt;\n\n\n上面的代码很清晰地展现出了各个节点之间的关系，但是如果你尝试修改了一下上面的代码，想要查询第二个 &lt;p&gt; 与标签 &lt;a&gt; 之间的关系，可能会失望。\n\n# 使用.next_sibling获取下一个兄弟节点\nsibling_soup = soup.a.next_sibling\nprint(\"&lt;a&gt;标签的下一个兄弟节点是：\", sibling_soup)\n\n# 使用.previous_sibling获取上一个兄弟节点\nsibling_soup_2 = soup.p.previous_sibling\nprint(\"第二个标签&lt;p&gt;的上一个兄弟节点是：\", sibling_soup_2)\n\n&lt;a&gt;标签的下一个兄弟节点是： \n\n第二个标签&lt;p&gt;的上一个兄弟节点是： \n\n\n\n仔细观察运行结果，我们发现，代码既没有报错，也没有预想中的输出。这是因为，空格和换行符都是标签的兄弟节点。因此，实际 HTML 文档中的 Tag 的 .next_sibling 和 .previous_sibling 属性通常都是字符串或空白。\n\n\n(3) 前后节点\n现在我们来看看最后一种元素间的关系：前后节点。\n在运行 HTML 解析器时，你有没有想过它是如何工作的？看看下面的代码：\n\n&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;\n&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;\n\n对于上面这一小块 HTML 文档，解析器的工作流程是：\n\n\n\n\ngraph LR\nid(打开 &lthtml&gt 标签) --&gt; id1(打开一个 &lthead&gt 标签) --&gt; id2(打开一个 &lttitle&gt 标签) --&gt;  id3(添加一段字符串) --&gt; id4(关闭 &lttitle&gt 标签) --&gt; id5(打开 &ltp&gt 标签) --&gt;id6(...)\n\n\n\n\n\n根据解析器的工作流程，我们就可以定义出前后节点关系：在指定节点后解析的节点叫做该节点的前进节点，在指定节点前解析的节点叫做回退节点。我们可以使用 .next_element 属性指向解析过程中下一个被解析的对象(字符串或 tag)，即指向前进节点；使用 .previous_element 属性指向当前被解析的对象的前一个解析对象，即指向回退节点。\n有时候前后节点可能与兄弟节点是一样的，但通常是不一样的。"
  },
  {
    "objectID": "05_04_Scrapy框架.html#scrapy-框架",
    "href": "05_04_Scrapy框架.html#scrapy-框架",
    "title": "18  Scrapy 框架",
    "section": "Scrapy 框架",
    "text": "Scrapy 框架\n在前面的学习中，我们使用 requests 库抓取到了我们想要的网站的全部源代码，但通常情况下，我们并不需要整个网站的代码，而只需要我们所关注的部分的数据即可。因此，我们需要有一个新的工具，来帮助我们对网页中的内容进行分析，并提取我们所需要的内容。\nscrapy 是一个强大的 Python 框架，具有高度模块化的设计，包括各种组件，通过这些组件的协同工作，用户可以实现高效的网络爬取。\n\n\n\n\n\n\nNote\n\n\n\n爬虫框架\n所谓爬虫框架就是一种用于开发和执行网络爬虫的软件工具或库。爬虫框架提供了一组功能和工具，用于自动化地访问网站、下载网页内容、解析HTML数据，并从中提取有用的信息。这些框架通常以模块化的方式设计，使开发人员能够更容易地构建、配置和管理爬虫。\n\n\nscrapy 是世界上最流行的爬虫框架之一，它是一个开源的项目，被广泛地运用于爬取各种类型的网站。scrapy 具有十分强大的功能，在本次学习中，我们将从以下几个方面对 scrapy 进行基本的学习。\n\nscrapy的架构、组成部分\n创建和运行一个scrapy爬虫\n使用XPath和CSS选择题提取数据\n编写Spider规则以定义爬取流程\n\n现在，让我们从基础入手，来认识一下世界上最棒的爬虫框架 —— scrapy。不过千万要记得，scrapy 作为一个第三方库，在使用它之前，需要安装它。\n\npip install scrapy\n\n\n一、scrapy 的架构与组成部分\n前面我们说过，scrapy具有高度模块化的设计，它包括各种组件，如下载器、中间件、管道、调度器等等，这是 scrapy 的重要优势之一。模块化的设计意味着我们可以根据需要调用我们所需要的组件、使用我们所需要的功能，根据我们的需求灵活地配置和定制爬虫，并且减少资源的占用。\nscrapy 共有六个核心组件，让我们一起来看看。\n\n1. Spiders(蜘蛛)\n顾名思义，Spiders(蜘蛛) 就是一种 Crawler(爬虫)，在网络世界中，Spiders 会在网页中进行“爬行”和“捕捉(索取）”的工作。Spiders 是 Scrapy 的核心组件，负责定义和爬取的规则与流程。每个 Spider 定义了如何从网站上爬取数据，以及如何解析和处理这些数据。每个Spider定义了从一个或多个起始URL开始的爬取任务，并指定了如何跟踪链接、解析HTML数据以及如何提取有用的信息。就像一只真正的 Spider(蜘蛛)一样，它会从一个起始点(起始网页或种子 URL)开始，沿着蜘蛛网上的线(我们定义好的规则)，追寻和捕捉猎物(跟踪链接和URL，递归地遍历和抓取其他相关网页的内容)。\n下面让我们一起来看看 Spiders 是如何工作的\n就像一只小蜘蛛织网一样，Spiders 的主要任务就是定义爬取规则。为了创建一个 Spider，我们首先需要编写一个 Python 类，这个类通常继承自 Scrapy 的 scrapy.Spider 类。这个类必须包含一些必要的属性和方法，如 Spider 的名称、起始 URL 列表，以及数据解析逻辑。就像下面这样。\n\nimport scrapy\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        # 在这里编写数据解析逻辑\n        pass\n\n关于编写数据解析逻辑的方法，我们将在后面学习，现在我们只需要掌握定义一个 Spider 的方法就可以了。\n\n\n\n\n\n\nNote\n\n\n\npass 关键字\n你可能会好奇上面代码中的 pass 关键字的作用。在 Python 中，pass 是一个占位符关键字，不执行任何操作，只是一个空语句，用于指示此处需要有代码，但在当前情况下不需要执行任何操作。在上面的示例中，我们在 parse 方法的内部填上了 pass 关键字，用以占位，如果以后我们要编写数据解析逻辑，那么使用新代码替换掉 pass 就可以了。\n\n\n观察上面的代码，我们在定义这个类时一共做了三件事：\n\n定义 Spider 的名称：使用 name 属性，将其定义为 myspider\n定义起始 URL(Start URLs)：每个Spider都有一个或多个起始URL，爬虫将从这些URL开始抓取数据。这些URL可以是单个字符串或URL列表。我们使用 start_urls 属性来定义起始 URL。\n定义了一个类方法：定义了 parse 方法，向它传入了两个参数：self 和 response。\n\nself：self 参数是一个指向类的实例的引用。你可以这么理解它：当你使用 self 时，实际上就是在访问这个类的属性和方法。在上面的代码中，self 在 parse 方法内部使用，就代表着我们可以在 parse 中访问 Spider 的属性和方法，如 name 和 start_urls。self 参数就是一个连接到 Spider 对象的“自我引用”。\nresponse：我们在 requests 库的学习中与 response 有过一定接触，这个参数在这里是由 Scrapy 框架提供的 HTTP 响应对象，包含了从目标网站下载的页面内容，我们可以使用这个参数中的内容进行提取数据、跟踪链接和执行其他与响应相关的操作。\n\n\nSpiders 作为 Scrapy 最核心的组件，也是我们本次学习所需要掌握的最关键的部分，大家需要牢记创建 Spider 的方法。\n\n\n2. Downloader(下载器)\nScrapy 中的 Downloader 是爬虫框架的一个关键组件，该组件负责发送 HTTP 请求以下载网页内容。下载器处理与网络请求和响应相关的底层细节包括处理代理、User-Agent、重定向、Cookie 等。\n\nHTTP 请求发送和响应处理： 下载器负责发送 HTTP 请求，并处理来自服务器的响应。它管理连接池，可以异步发送多个请求以提高效率。\n处理重定向和代理： 下载器处理 HTTP 重定向，以及如果需要的话，可以使用代理服务器来下载页面。这有助于应对某些网站的反爬措施。\n下载网页内容： Downloader 接收到 HTTP 响应后，将网页内容下载到内存中，并将其包装在一个 Response 对象中，然后将 Response 对象传递给 Spider，以便进一步的处理。我们在创建第一个 Spider 时，在 parse 方法里传入的 response 参数就是由 Downloader 下载的。\n\n\n\n3. Item Pipeline(数据管道)\nScrapy 的 Item Pipeline 组件负责处理从 Spider 中提取的数据项(Item)，它允许用户再数据被存储或导出之前对数据进行进一步的处理、验证和清洗。我们还可以编写自定义数据管道来处理数据，根据项目的需求实施特定的数据处理逻辑。\n\n数据清洗：我们可以在 Pipeline 中执行数据清理操作，例如去除不需要的空格、特殊字符或 HTML 标签。\n数据验证：使用 Pipeline 可以验证从 Spider 中提取的数据是否符合特定的格式或要求，如果数据不合规，可以选择丢弃或修复它。\n数据存储：Pipeline 允许将数据保存到不同的存储介质中，例如本地文件、数据库、Elasticsearch 等。\n数据导出：Pipeline 可以将数据导出到不同的输出格式，如 JSON、CSV、XML 等，以便后续分析或共享。\n数据处理：Pipeline 还可以执行其他数据处理任务，例如计算字段、转换数据类型等。\n\n在 Scrapy 中，每个 Item Pipeline 是一个独立的处理组件，可以按照优先级的顺序依次应用于提取的数据项。Pipeline 可以配置为启用或禁用，我们可以根据需要启用或禁用不同的 Pipeline 组件。\n\n\n4. Scheduler(调度器)\nScheduler 是 Scrapy 框架中的核心组件之一，负责管理爬虫任务的调度和控制。Scheduler的主要任务是维护待爬取的URL队列，确保每个URL都被适时地爬取，并避免重复爬取。\n\nURL 队列管理： Scheduler 负责管理待爬取的 URL 队列。当一个 Spider 启动时，它会从 Scheduler 获取起始 URL，并根据规则和链接跟踪逻辑不断向队列中添加新的 URL。这确保了 Spide 能够按照预定的方式遍历和爬取网站。\n去重处理： 防止重复爬取是爬虫的一个重要任务。Scheduler 会检查新加入队列的 URL 是否已经存在，以避免重复的请求。这可以通过使用去重过滤器(Duplicate Filter)来实现，以确保同一个 URL 不会被爬虫多次请求。\n调度策略： Scheduler 还负责确定下一个要爬取的 URL。它可以使用不同的调度策略，如广度优先、深度优先等，来控制爬虫的行为。调度策略可以根据网站的结构和需求进行配置。\n并发控制： 爬虫通常需要控制并发请求的数量，以避免对目标网站造成过大的负载。Scheduler 允许您配置并发请求数的上限，以便适应目标网站的性能和反爬虫机制。\n错误处理： 当发生网络请求错误或其他异常时，Scheduler 可以处理错误情况，并根据策略重试或忽略失败的请求。这有助于提高爬虫的稳定性。\n分布式爬取： 在分布式爬取环境中，多个爬虫节点可以共享同一个 Scheduler，以协调任务。Scheduler 可以确保不同节点之间不会爬取相同的 URL，从而提高效率。\n自定义扩展： Scrapy 允许开发人员自定义 Scheduler 组件，以满足特定项目的需求。您可以编写自己的调度逻辑，甚至使用外部队列服务(如Redis)来管理 URL 队列。\n\nScheduler 是 Scrapy 中非常重要的组件，它有效地管理了爬虫的调度和 URL 队列，使得爬虫能够高效、有序地访问网站并提取数据。在 Scrapy 中，Scheduler 与 Downloader、Spider 等组件协同工作，构成了一个强大的网络爬虫框架。\n\n\n5. Downloader Middleware(下载器中间件)\nDownloader Middleware 是用于在 Scrapy 的 Downloader 处理请求和响应的过程中进行拦截和处理的机制。它通常用于执行以下任务：\n\n请求预处理和响应后处理：下载器中间件是在请求发送之前和响应处理之后执行的一组处理程序。它们可以进行 User-Agent 设置、代理设置、请求头修改、请求过滤、请求重定向处理等任务。\n自定义中间件：我们可以编写自定义的下载器中间件，以满足特定的需求，如处理代理、用户代理切换等。\n\n\n\n6. Spider Middleware(蜘蛛中间件)\nSpider Middleware 是用于在Scrapy的 Spider 处理响应数据之前和之后进行拦截和处理的机制。它通常用于执行以下任务：\n\n请求预处理和响应后处理：蜘蛛中间件是在 Spider 发出请求之前和响应被 Spider 处理之后执行的一组处理程序。它们可以用于全局性的请求预处理和响应后处理，进行数据处理、请求生成、异常处理、数据过滤等任务。\n自定义中间件：我们可以编写自定义的蜘蛛中间件，以实现全局性的功能，如网页去重、异常处理等。\n\n\n\n\n二、创建第一个 Scrapy 爬虫\n现在，我们已经对 Scrapy 的构成有了基本的了解。是时候开始上手试一试了，创建一个新的爬虫项目，开始伟大的信息猎人生涯吧。\n\n1. 步骤一：创建 Scrapy 项目\n前面我们已经掌握了如何建立一个新的 Spider，或许你已经心痒难耐要孵化一只你的小虫子了，但是请不要着急，我们现在要使用的是世界上最流行的爬虫框架 Scrapy —— 最流行的东西往往有许多奇奇怪怪的规则，当然，这都是为了我们项目的高效展开。\n在创建一只 Spider 以前，我们需要首先建立一个 Scrapy 项目。为什么要这么做？因为 Scrapy 作为一个高级 Python 爬虫框架，Scrapy 项目具有一个特定的文件夹结构，其中包含了用于不同方面的代码和配置文件，这个结构包括 Spiders、Item Pipelines、中间件、配置文件等。这个组织结构有助于将爬虫的不同部分分离开来，使其更易于管理和维护。\n现在让我们来试试看！在 JupyterLab 中输入下面的代码，其中 DoubanScrapy 是我们的 Scrapy 项目的名称，你可以自定义一个你喜欢的。\n\n!scrapy startproject DoubanScrapy\n\nNew Scrapy project 'DoubanScrapy', using template directory 'D:\\Programs\\Code Editor and Database\\Anaconda\\envs\\myenv\\Lib\\site-packages\\scrapy\\templates\\project', created in:\n    D:\\Files\\Desktop\\爬虫\\DoubanScrapy\n\nYou can start your first spider with:\n    cd DoubanScrapy\n    scrapy genspider example example.com\n\n\n现在瞧一瞧你的目录文件夹，这里应当出现了一个新的文件夹，就是我们刚才创建的 Scrapy 项目保存的位置，请记住它，现在，让我们进入到我们的项目之中。\n\n\n\n\n\n\nWarning\n\n\n\n请注意，在 JupyterLab 中执行的命令会在 JupyterLab 的工作目录中创建或操作文件。如果你想要在 JupyterLab 中创建、运行和管理 Scrapy 项目，确保你已经正确配置了 JupyterLab 的工作目录以便操作项目文件。\n\n\n\n!cd DoubanScrapy\n\n现在我们已经处于我们的项目文件夹下啦，接下来，让我们一起来编辑和开发我们的 Scrapy 项目吧。\n\n\n\n2. 步骤二：创建 Spider\n前面我们已经学过，如何创建一个 Spider，但是在正式的工作流程中，我们需要使用更通常的办法。就是首先创建一个 Spider，再对它进行编辑。\n进入到你的 JupyterLab 界面，试试看下面的代码，创建一个新的 Spider，命名为 douban。\n\n!scrapy genspider douban movie.douban.com\n\nCreated spider 'douban' using template 'basic' \n\n\n在上面的代码中：\n\ndouban 是我们所创建的新 Spider 的名称。\nmovie.douban.com 是我们所要爬取的网站的起始URL。\n\n上面的命令将在 DoubanMyScrapy/spiders 目录下生成一个名为 “douban.py” 的 Spider 文件，并将起始 URL 设置为豆瓣电影的页面。\n\n\n3. 步骤三：修改 Spider\n接下来，让我们一起来修改我们的新 Spider。看看你的工作目录，找到 “douban.py” 文件，打开它，将其中的内容修改为：\n\nimport scrapy\n\n\nclass DoubanSpider(scrapy.Spider):\n    name = \"douban\"\n    allowed_domains = [\"movie.douban.com\"]\n    start_urls = [\"http://movie.douban.com/top250\"]\n\n    def parse(self, response):\n        pass\n\n也就是将 start_urls 修改为 http://movie.douban.com/top250。这样一来，我们就完成了对起始 URL 的修改，请务必保证没有修改错误，因为 start_urls 是 Spider 在启动时进行爬取的 URL 列表，后续的 URL 都将从初始 URL 获取到的数据中提取。\n现在你是不是已经着急想要编写爬虫的数据解析逻辑了？请先不要着急，我们接下来还要学习选择器部分，掌握了数据提取的方法，才能更好的编写数据解析逻辑。此处 Spider 数据解析逻辑的编写请让我们先按下不表，后面再来尝试。\n\n\n三、数据提取和选择器\n通过前面的学习，我们很容易就可以获取一个网页的全部数据，但是往往我们不需要那么庞杂的数据。因此，我们需要借助一些工具来将我们所需要的部分从完整的网页数据中提取出来，这种工具就叫做选择器，这个过程就叫做数据提取。\nScrapy 提供了两种主要的选择器来提取 HTML 页面中的数据。\n\n1. XPth 选择器\nScrapy 中的 XPth 选择器是用于爬虫中解析 HTML 或 XML 文档的一种强大工具。在前面学习 HTML 文档时我们知道，HTML 文档由许多标签和元素组成，XPth 选择器就允许根据元素的路径和属性来定位和提取数据，有助于从网页中抽取信息。\n让我们一起来看看如何使用 XPth 选择器。\n\n(1) 导入 XPth 选择器\n在 Scrapy 中，我们需要使用 Selector 类来创建 XPth 选择器对象，因此，我们首选需要导入 Selector 类。\n\nfrom scrapy.selector import Selector\n\n\n\n(2) 创建 Selector 对象\n还记得我们在学习创建一个 Spider 时使用 Pass 关键字所占下的空位吗？现在我们就要编写代码来替换掉 Pass 关键字了。\n要创建一个 XPth 选择器对象，就要首先将服务器响应给我们的内容(即 response)传递给 Selector 类的构造函数。在通常情况下，我们都会在 Spider 的 parse 方法中使用 XPth 选择器，因此，我们可以这样写：\n\nimport scrapy\nfrom scrapy.selector import Selector\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        selector = Selector(response)\n        # 现在可以使用selector来进行XPath选择\n\n\n\n(3) 选择数据\nXPath 选择器通过使用 XPath 表达式来选择元素，我们可以使用 XPath 表达式来进行元素选择、层级选择等操作。请回想一下 HTML 文档章节中我们所学习过的标签，在选择数据时，我们需要使用这些标签来做定位。\n\n\n\n\n\n\nNote\n\n\n\n为了便于大家理解，这里不得不提上一句，XPath(XML Path Language)是一种用于在 XML 文档中定位和选择元素的语言，它同样适用于 HTML 文档的解析。XPath 表达式是 XPath 语言中的一种语法，用于指定如何选择文档中的元素。\n\n\n\n元素选择\nXPath 表达式中最简单的形式是元素选择，用于选择文档中的元素，其语法为：使用双斜杠 // 加上需要选择的元素的标签，如：\n\n//p：选择所有 &lt;p&gt; 元素\n//a：选择所有 &lt;a&gt; 元素\n\n层级选择\nXPth 表达式可以通过层级结构定位元素，从根节点(父节点)开始逐级选择，各个层级之间使用斜杠 / 来分隔，如：\n\n/html/body：选择文档根节点下的所有 &lt;body&gt; 元素\n//div/p：选择所有 &lt;div&gt; 元素下的 &lt;p&gt; 元素\n\n通配符\n通配符 * 可以用来选择所有子元素或所有元素。例如：\n\n选择&lt;body&gt;元素下的所有子元素：/html/body/*\n选择文档中的所有元素：//*\n\n属性选择\nXPath 表达式可以根据元素的属性来选择元素，其语法为：选中某一元素后，在其后紧跟 [@ ]，@ 后填入具体的属性内容。例如：\n\n选择所有带有 href 属性的&lt;a&gt;元素：//a[@href]\n选择所有 class 属性为 header 的 &lt;div&gt; 元素：//div[@class=\"header\"]\n\n文本选择\nXPath 表达式可以选择元素的文本内容。例如：\n\n选择所有 &lt;p&gt; 元素的文本内容：//p/text()\n选择第一个 &lt;h1&gt; 元素的文本内容：//h1[1]/text()\n\n谓词(Predicates)\n谓词用于筛选元素。可以在XPath表达式中使用方括号 [] 来定义谓词。例如：\n\n选择第一个 &lt;a&gt; 元素的文本内容：//a[1]/text()\n选择第一个 &lt;div&gt; 元素下的第三个 &lt;p&gt; 元素：//div[1]/p[3]\n\n逻辑运算符\nXPath 支持逻辑运算符，如 and、or、not，用于组合条件。例如：\n\n选择所有 &lt;a&gt; 元素，其文本内容包含 “click” 或 “visit”：//a[contains(text(), \"click\") or contains(text(), \"visit\")]\n\n函数\nXPath 还包括一系列内置函数，用于在表达式中执行操作，如字符串处理、数学计算等。例如：\n\n选择所有文本内容不为空的 &lt;p&gt; 元素：//p[string-length(text()) &gt; 0]\n\n\n看完了常见的 XPath 表达式，让我们来看看在实际中应该如何书写，要使用 XPath 表达式，只需要调用 .xpath 方法就可以了。\n\nimport scrapy\nfrom scrapy.selector import Selector\n\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        selector = Selector(response)\n        # 现在可以使用selector来进行XPath选择\n        # 提取所有链接的文本内容\n        links = selector.xpath('//a/text()').extract()\n\n        # 提取第一个&lt;h1&gt;元素的文本内容\n        title = selector.xpath('//h1/text()').extract_first()\n\n        # 提取所有class属性为\"content\"的&lt;div&gt;元素的文本内容\n        contents = selector.xpath('//div[@class=\"content\"]/text()').extract()\n\n另外，我们还可以在一个 XPath 选择器对象上多次进行选择操作。比如下面的例子，我们首先选择所有的链接，然后再选择其文本内容。\n\nimport scrapy\nfrom scrapy.selector import Selector\n\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        selector = Selector(response)\n        # 现在可以使用selector来进行XPath选择\n        # 选择所有链接\n        links = selector.xpath('//a')\n\n        # 在选定的链接上选择文本内容\n        text_contents = links.xpath('./text()').extract()\n\nXPath 选择器是 Scrapy 中非常有用的工具，它允许爬虫精确选择和提取数据。熟练掌握 XPath 语法和选择器操作对于成功构建爬虫非常重要。不仅可以提取数据，还可以用于页面导航、链接提取等多个爬虫任务。\n现在，让我们一起来看看 Scrapy 中的另外一个选择器 —— CSS选择器。\n\n\n\n2. CSS 选择器\n回想 HTML 章节的内容，我们知道，网页的三大组成部分分别是：HTML、Javascript 和 CSS。CSS 选择器就是 CSS 中的一部分，它使用类似于CSS的选择器语法来定位和操作元素。CSS 选择器的作用与使用方法与 XPath 选择器类似，让我们一起来试试看！\n\n(1) 导入 CSS 选择器并创建 Selector 对象\n与 XPath 选择器的操作一致，在 Scrapy 中，要使用 CSS 选择器，就要首先创建 Selector 类，如下所示：\n\nimport scrapy\nfrom scrapy.selector import Selector\n\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        selector = Selector(response)\n        # 现在可以使用selector来进行CSS选择\n\n\n\n(2) 选择数据\n在 Scrapy 中，我们使用 CSS 选择器语法来定位和提取 HTML 或 XML 文旦中的元素。CSS 选择器语法相对简洁，易于理解。同样的，我们也需要牢记 HTML 文档的标签与元素的含义，CSS 选择器也需要借助 HTML 标签来进行数据选择。\n\n基本元素选择\nCSS 选择器选择基本元素的语法十分简单，想要选择哪一种元素，就可以直接使用该元素的名称进行选择，例如：\n\n选择元素：使用元素名称来选择元素，例如：\n\na 选择所有链接\n\n类选择器：使用类名来选择元素，例如：\n\n.classname 选择所有具有特定类的元素\n\nID 选择器：使用 ID 来选择元素，例如：\n\n#elementid 选择具有特定ID的元素\n\n\n层级选择\nCSS 选择器与 XPath 选择器一样，同样可以进行层级选择，但是语法不一致：\n\n子元素：使用空格来表示子元素，例如：\n\ndiv a 选择所有 &lt;div&gt; 元素内的链接\n\n相邻兄弟元素：使用 + 符号选择相邻兄弟元素，例如：\n\nh1 + p 选择 &lt;h1&gt; 元素后紧随的 &lt;p&gt; 元素\n\n通用兄弟元素：使用 ~ 符号选择所有通用兄弟元素，例如：\n\nh1 ~ p 选择 &lt;h1&gt; 元素后的所有 &lt;p&gt; 元素\n\n\n属性选择\n\n属性选择：使用方括号来选择具有特定属性的元素，例如：\n\na[href] 选择所有带有 href 属性的链接\n\n属性值选择：使用 [] 方括号和 = 来选择具有特定属性值的元素，例如：\n\ninput[type=\"text\"] 选择所有 type 属性值为”text”的输入框\n\n\n伪类选择器：\nCSS选择器还支持伪类选择器，用于选择具有特定状态或位置的元素。例如：\n\n:hover 用于选择鼠标悬停的元素\n:first-child 用于选择第一个子元素等\n\n组合选择器：\n我们可以将多个选择器组合在一起，以便更精确地定位元素。例如：\n\ndiv.content a 可以选择所有具有类名 “content” 的 &lt;div&gt; 元素内的链接\n\n提取文本和属性：\n要提取元素的文本内容，可以使用 ::text。要提取元素的属性，可以使用 ::attr(attribute_name)。例如：\n\n提取链接文本：a::text\n提取链接的href属性：a::attr(href)\n\n通配符选择器：\n使用 * 通配符来选择任何元素，例如：\n\n*::text 可以选择文档中的所有文本内容\n\n\n下面给出了一些基本示例，便于大家理解如何使用 CSS 选择器。\n\nimport scrapy\nfrom scrapy.selector import Selector\n\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        selector = Selector(response)\n        # 现在可以使用selector来进行CSS选择\n        # 提取所有链接的文本内容\n        links = selector.css('a::text').extract()\n\n        # 提取第一个`&lt;h1&gt;`元素的文本内容\n        title = selector.css('h1::text').extract_first()\n\n        # 提取所有带有`class`属性为 \"content\"的`&lt;div&gt;`元素的文本内容\n        contents = selector.css('div.content::text').extract()\n\n到现在，你已经完全掌握了 Scrapy 框架的基础用法，知道了 Scrapy 的架构，学会了如何创建 Spider，了解了如何使用选择器提取数据。让我们来进行本章节学习的最后一步，将编写 Spider 规则、定义爬取流程的工作重新梳理一遍。\n\n\n\n\n四、编写 Spider 规则以定义爬取流程\n编写 Spider 规则是定义 Scrapy 爬虫行为的关键部分，它决定了爬虫如何从网页中提取数据和遍历网站的过程。以下是详细描述如何编写 Spider 规则以定义爬取流程的步骤：\n\n1. 定义 Spider 类\n首先，我们需要创建一个继承自 scrapy.Spider 类的 Spider 类。在该类中，我们需要定义一些必要的属性，包括 Spider 的名称、起始 URL 列表等。下面，我们一起来创建一个 Spider 示例。\n\nimport scrapy\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n\n\n2. 编写 parse 方法\nparse 方法是 Spider 的入口点，它接收从起始 URL 下载的响应对象(response)。在 parse 方法中，我们可以编写数据提取和爬取流程。我们可以使用 XPath 选择器或 CSS 选择器来定位和提取页面中的数据。\n\n\n3. 数据提取和存储：\n在 parse 方法中，我们可以使用选择器从响应中提取数据，然后将数据存储在 Scrapy 的 Item 对象中。Item 对象是字典形式的容器，用于组织和传递数据。\n\n\n\n\n\n\nNote\n\n\n\n在 Scrapy 中，Item 对象是用来存储爬取到的数据的容器。每个 Item 对象都表示一个爬取项，它可以包含从网页中抽取出来的各种数据，如文本、数字、链接、图片URL等。Item 对象是将爬取到的数据传递到 Item Pipeline 的方式之一，以便进行进一步处理、清洗和存储。\n以下是关于 Scrapy 中 Item 对象的详细介绍：\n\n创建 Item 对象：\n\n在 Scrapy 中，我们需要定义 Item 对象的结构，这项工作通常是在项目的 items.py 文件中进行。一个 Item 对象是一个简单的 Python 类，它通常包含一组字段(field)来存储不同类型的数据。\nimport scrapy\n\nclass MyItem(scrapy.Item):\n    title = scrapy.Field()\n    link = scrapy.Field()\n    description = scrapy.Field()\n    # 可以添加更多字段\n在上述示例中，我们创建了一个名为 MyItem 的 Item 类，并定义了三个字段：title、link 和 description。这些字段将用于存储爬取到的数据。\n\n传递 Item 对象：\n\n一旦 Item 对象包含了所需的数据，我们就可以将其传递给 Spider 中的回调函数，或者直接返回它。 Item 对象将会在 Spider 中传递，然后在 Item Pipeline 中处理。\ndef parse(self, response):\n    item = MyItem()\n    item['title'] = 'Example Title'\n    item['link'] = 'https://example.com'\n    item['description'] = 'This is an example description.'\n    return item\n总之，Item对象是Scrapy中用来存储和传递爬取数据的关键元素。通过创建自定义的Item类并实例化Item对象，我们可以有效地组织和管理从网页中抽取出来的数据，并通过Item Pipeline进行进一步的处理和存储。这使得Scrapy能够高效地处理不同类型的数据，从而实现强大的爬虫功能。\n\n\n\n\n4. 使用 yield 传递 Item 对象：\n要将提取的数据传递给 Item Pipeline 进行处理，我们就需要使用 Python 的 yield 语句将 Item 对象返回。Scrapy 将自动将返回的 Item 对象传递给配置的 Item Pipeline。\n\nimport scrapy\n\nclass MySpider(scrapy.Spider):\n    name = 'myspider'\n    start_urls = ['https://example.com']\n\n    def parse(self, response):\n        # 使用XPath选择器提取页面中的标题文本\n        title = response.xpath('//h1/text()').get()\n        \n        # 使用CSS选择器提取页面中的链接\n        links = response.css('a::attr(href)').getall()\n        \n        # 创建一个Item对象并存储提取的数据\n        item = {\n            'title': title,\n            'links': links\n        }\n        \n        # 使用yield将Item对象传递给Item Pipeline进行处理\n        yield item"
  },
  {
    "objectID": "06_01_for循环.html#为什么需要使用for循环",
    "href": "06_01_for循环.html#为什么需要使用for循环",
    "title": "19  for循环自动获取股票数据",
    "section": "为什么需要使用for循环？",
    "text": "为什么需要使用for循环？\nfor循环简化了操作、处理大量数据，自动化了重复任务，并提供灵活的遍历顺序。它是一种强大的编程工具，帮助我们优化效率、减少冗余代码。无论初学者还是经验丰富的开发人员，for循环都是不可或缺的技术，提升代码质量、处理数据轻而易举。"
  },
  {
    "objectID": "06_01_for循环.html#案例背景",
    "href": "06_01_for循环.html#案例背景",
    "title": "19  for循环自动获取股票数据",
    "section": "案例背景",
    "text": "案例背景\n使用for循环调用股票API Tushare获取日线行情。但是有限制调用页数。尝试使用for循环遍历列表，逐个发送API请求获取每只股票的日线行情数据。"
  },
  {
    "objectID": "06_01_for循环.html#操作步骤",
    "href": "06_01_for循环.html#操作步骤",
    "title": "19  for循环自动获取股票数据",
    "section": "操作步骤",
    "text": "操作步骤\n\n通过def定义函数\nfor循环遍历整个日线行情\nconcat合并上下表"
  },
  {
    "objectID": "06_02_python链接数据库.html#为什么要用sqlalchemy连接数据库",
    "href": "06_02_python链接数据库.html#为什么要用sqlalchemy连接数据库",
    "title": "20  Python连接Postgresql数据库",
    "section": "为什么要用SQLAlchemy连接数据库？",
    "text": "为什么要用SQLAlchemy连接数据库？\n在企业中，很多数据都存储在数据库当中，通过SQLAlchemy，可以轻松连接多种数据库，包括MySQL、PostgreSQL、SQLite等，并使用统一的API进行数据库操作。SQLAlchemy提供了高级的对象关系映射（ORM）功能，使数据库操作更加面向对象，简化了数据模型的开发和管理。它提供了查询构建器、事务管理、数据迁移等功能，提高了开发效率。"
  },
  {
    "objectID": "06_02_python链接数据库.html#所需环境和拓展包",
    "href": "06_02_python链接数据库.html#所需环境和拓展包",
    "title": "20  Python连接Postgresql数据库",
    "section": "所需环境和拓展包",
    "text": "所需环境和拓展包\n\njupyternotebook – 撰写python代码\nPostgreSQL & Pgadmin4 – 数据库及其GUI工具（数据库客户端）\nSQLAlchemy – python拓展包，用来连接数据库"
  },
  {
    "objectID": "06_02_python链接数据库.html#操作步骤",
    "href": "06_02_python链接数据库.html#操作步骤",
    "title": "20  Python连接Postgresql数据库",
    "section": "操作步骤",
    "text": "操作步骤\n\nDocker安装jupyternotebook & Postgresql数据库\n本地数据库备份&迁移\n安装和使用SqlAlechemy"
  },
  {
    "objectID": "07_01_环境搭建.html#anaconda环境安装强烈推荐",
    "href": "07_01_环境搭建.html#anaconda环境安装强烈推荐",
    "title": "21  Python环境搭建",
    "section": "Anaconda环境安装（强烈推荐）",
    "text": "Anaconda环境安装（强烈推荐）\n强烈推荐小白使用Anaconda平台学习Python。\nAnaconda提供了简化环境配置、跨平台支持、库和工具管理以及丰富的科学计算库等优势，使得小白学习Python更加便捷和高效。它是一个功能强大且易于使用的平台，可以帮助您快速入门Python编程并进行数据处理和分析。\n官方免费提供在线编辑器-jupyterlab 无需手动安装环境，即可直接上手编写代码。\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAnaconda的安装路径和用户名最好使用英文"
  },
  {
    "objectID": "07_01_环境搭建.html#plotly",
    "href": "07_01_环境搭建.html#plotly",
    "title": "21  Python环境搭建",
    "section": "Plotly",
    "text": "Plotly\nPlotly是一种用于创建交互式可视化的开源Python图形库，它提供了丰富的图表类型和功能，可以生成高质量、可交互的图形，用于数据分析和呈现。 Plotly支持的图表类型有很多，包括我们常用的散点图、线图、条形图、面积图、箱线图等等。在使用Plotly的过程中，我们可以通过选择合适的图表类型进行数据可视化。另外，Plotly提供了强大的交互式功能，用户可以通过鼠标交互、缩放、平移等操作来和图标进行交互。同时，我们还可以通过添加悬停提示信息、点击事件和自定义工具栏等交互元素，增强用户体验。 由于Plotly可以和Python中的各种数据分析和科学计算库(如NumPy、Pandas等)无缝集成，因此，在使用Python进行数据可视化工作的进程中，Plotly可以很好地帮助到我们。\n在后面的课程中，我们会详细介绍Plotly的相关内容，现在，让我们一起来看看Plotly可以实现的效果吧。\n\n使用conda安装Plotly\n如果你的电脑上安装了Anaconda，那么我们可以使用conda来安装Plotly。打开终端或者Jupyter文件，输入以下代码\nconda install -c plotly plotly\n这将从Anaconda的默认渠道安装Plotly。\n\n\n使用pip安装Plotly\n如果您的电脑上没有安装Anaconda，您也可以使用pip来安装Plotly。打开终端以后，输入以下代码\npip install plotly\n\n\n验证安装\n安装完成以后，可以使用以下命令来验证是否成功安装了Plotly\npip show plotly\n如果成功安装，这行代码将为我们显示Plotly的版本号。 在安装完成以后，您就可以在Python中使用Plotly来创建交互式可视化图表了。另外，在使用Plotly时，通常还需要安装Pandas或numpy，我们将在后面的章节中带领您安装。\nplotly.express官方介绍可以先本地尝试下官方给的案例～\n\n\n1. Lines on Maps\n\n\n\n\n\n\nWarning\n\n\n\nplotly在本地运行无法显示图片的话，可以尝试直接使用fig.show()，去掉renderer=\"notebook\"\n\n\n\nimport plotly.express as px\ndf = px.data.gapminder().query(\"year == 2007\")\nfig = px.line_geo(df, locations=\"iso_alpha\",\n                  color=\"continent\", # \"continent\" is one of the columns of gapminder\n                  projection=\"orthographic\")\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\n2. Funnel Chart\n\nfrom plotly import graph_objects as go\n\nfig = go.Figure(go.Funnel(\n    y = [\"Website visit\", \"Downloads\", \"Potential customers\", \"Requested price\", \"Finalized\"],\n    x = [39, 27.4, 20.6, 11, 2],\n    textposition = \"inside\",\n    textinfo = \"value+percent initial\",\n    opacity = 0.65, marker = {\"color\": [\"deepskyblue\", \"lightsalmon\", \"tan\", \"teal\", \"silver\"],\n    \"line\": {\"width\": [4, 2, 2, 3, 1, 1], \"color\": [\"wheat\", \"wheat\", \"blue\", \"wheat\", \"wheat\"]}},\n    connector = {\"line\": {\"color\": \"royalblue\", \"dash\": \"dot\", \"width\": 3}})\n    )\n\nfig.show(renderer=\"notebook\")\n\n\n                                                \n\n\n\n\n3. Scatter Plots\n\nimport plotly.express as px\n\ndf = px.data.iris()\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", color='petal_length')\nfig.show(renderer=\"notebook\")"
  },
  {
    "objectID": "07_02_条件语句和循环语句.html#条件语句",
    "href": "07_02_条件语句和循环语句.html#条件语句",
    "title": "22  Python条件语句",
    "section": "条件语句",
    "text": "条件语句\n在本节课程中，我们将学习条件语句的基本结构、逻辑判断以及如何构建复杂的条件表达式。同时，我们还会练习编写带有条件判断的程序，让你能够根据条件执行不同的代码块。\n\n条件语句的基本结构 条件语句允许我们根据不同的条件来执行不同的代码块。在Python中，条件语句使用if和else关键字构建。基本结构如下：\n\n\nif 条件:\n     #条件为True时执行的代码块\nelse:\n     #条件为False时执行的代码块\n\n\n逻辑判断 条件语句的逻辑判断基于比较运算符，用于比较两个值的相等性、大小关系等。常见的比较运算符包括：\n\n\n相等性判断：==（等于）、!=（不等于）\n大小关系判断：&gt;（大于）、&lt;（小于）、&gt;=（大于等于）、&lt;=（小于等于）\n\n举例：\n\nbalance = 1000\nif balance == 0:\n    print(\"账户余额为零\")\nelse:\n    print(\"账户余额不为零\")\n\n账户余额不为零\n\n\n\n复杂的条件表达式 我们可以使用比较运算符和逻辑运算符构建复杂的条件表达式，以实现更灵活的条件判断。常见的逻辑运算符包括：\n\n\nand（与）：当所有条件都为True时，结果为True\nor（或）：当至少一个条件为True时，结果为True\nnot（非）：取反操作，将True变为False，False变为True\n\n举例：\n\nincome = 50000\nif income &gt;= 50000 and income &lt;= 100000:\n    print(\"年收入在50,000到100,000之间\")\n\n年收入在50,000到100,000之间\n\n\n\n编写带有多个条件判断的程序 我们经常需要根据不同的条件执行不同的代码块。\nelif 是 Python 中的一个关键字，它是 if 语句的一部分，用于在多个条件语句中选择一个执行。elif 是 else if 的缩写，可以在 if 语句的末尾添加一个或多个 elif 语句，用于测试多个条件，如果前面的条件不成立，则测试下一个条件，直到找到一个成立的条件为止。\n\nelif 语句的语法如下：\n\nif 条件1:\n    # 如果条件1成立，则执行这里的代码\nelif 条件2:\n    # 如果条件1不成立，但条件2成立，则执行这里的代码\nelif 条件3:\n    # 如果条件1和条件2都不成立，但条件3成立，则执行这里的代码\nelse:\n    # 如果前面的所有条件都不成立，则执行这里的代码\n\n让我们通过举例来理解它的用法：\n\nnet_income = 5000\nif net_income &gt; 0 and net_income &lt;= 10000:\n    print(\"盈利一般\")\nelif net_income &gt; 10000 and net_income &lt;= 50000:\n    print(\"盈利良好\")\nelif net_income &gt; 50000:\n    print(\"盈利优秀\")\nelse:\n    print(\"亏损\")\n\n盈利一般\n\n\n\nrevenue = float(input(\"请输入公司的营业收入：\"))\n\nif revenue &gt; 1000000:\n    tax = revenue * 0.3\n    print(\"应缴纳的所得税为：\", tax)\nelse:\n    tax = revenue * 0.2\n    print(\"应缴纳的所得税为：\", tax)\n\n\n应缴纳的所得税为： 100000.0"
  },
  {
    "objectID": "07_02_条件语句和循环语句.html#循环语句",
    "href": "07_02_条件语句和循环语句.html#循环语句",
    "title": "22  Python条件语句",
    "section": "循环语句",
    "text": "循环语句\n\n基本结构 循环语句允许我们重复执行一段代码。Python中有两种常见的循环结构：while循环和for循环。\n\nPython 的 for 循环和 while 循环，它们的相同点在于都能循环做一件重复的事情，不同点在于 for 循环会在可迭代的序列被穷尽的时候停止，while则是在条件不成立的时候停止。\n因此 把 for 循环所做的事情概括成一句话就是: 于…其中的每一个元素，做…事情；\n把while 的作用概括成一句话就是: 只要…条件成立，就一直做…。\n\nwhile循环的基本结构如下：\n\n\nwhile 条件:\n    # 循环体代码块\n\n\n\n\nimage.png\n\n\n这里看一个简单的例子：\n\nwhile 1 &lt; 3:\n print('1 is smaller than 3')\n\n这里提醒一下，要及时按下停止运行代码。 因为在 while 后面的表达式是永远成立的，所以 print 会一直进行下去直至你的cpu 过热。这种条件永远为 True 的循环，我们称之为死循环 (Infnite Loop) 。\n但如果 while 循环不能像 for 循环那样，在集合被穷尽之后停下来，我们又怎么样才能控制 while 循环呢? 其中一种方式就是: 在循环过程中制造某种可以使循环停下来的条件，例如:\n\ncount = 0\nwhile True:\n print('Repeat this line !')\n count = count + 1\n if count == 5:\n   break\n\nRepeat this line !\nRepeat this line !\nRepeat this line !\nRepeat this line !\nRepeat this line !\n\n\n在上面这段代码中，有两个重要的地方，首先是我们给一个叫 count 的变量赋值为 0，其目的是计数。我们希望在循环次数为 5 的时候停下来。接下来的是 break同样作为关键词写在 if 下面的作用就是告诉程序在上面条件成立的时候停下来，仅此而已。这样就可以避免了死循环。\nfor循环的基本结构如下：\n\nfor 变量 in 可迭代对象:\n    # 循环体代码块\n\n\n\n\nimage.png\n\n\nfor 是关键词，而后面紧接着的是一个可以容纳“每一个元素”的变量名称，至于变量起什么名字自己定，但切记不要和关键词重名。\n在关键词 in 后面所对应的一定是具有“可迭代的”(iterable) 或者说是像列表那样的集合形态的对象，即可以连续地提供其中的每一个元素的对象。\n\nfor num in range(1,11): \n print(str(num) + ' + 1 =',num + 1)\n\n1 + 1 = 2\n2 + 1 = 3\n3 + 1 = 4\n4 + 1 = 5\n5 + 1 = 6\n6 + 1 = 7\n7 + 1 = 8\n8 + 1 = 9\n9 + 1 = 10\n10 + 1 = 11\n\n\n以上是一个简单的例子，内置函数range的意思是依次。我们只需要在 range 函数后面的括号中填上数字，就可以得到一个具有连续1到10的整数序列，利用for循环让他们相加。\n\n控制条件和执行过程 循环的执行依赖于控制条件。在每次循环迭代开始时，会检查控制条件的值。如果条件为True，则执行循环体代码块；否则，跳出循环。\n\n举例：\n\n使用while循环输出1到5的金融数据：\n\n\nprice = 100.0\nwhile price &lt;= 500.0:\n    print(\"股票价格:\", price)\n    price += 100.0\n\n股票价格: 100.0\n股票价格: 200.0\n股票价格: 300.0\n股票价格: 400.0\n股票价格: 500.0\n\n\n使用for循环遍历股票交易日的收盘价：\n\n  prices = [105.0, 102.5, 99.2, 101.8, 104.6]\n  for price in prices:\n      print(\"收盘价:\", price)\n\n\nbreak和continue语句 前面提到，我们可以使用break语句提前终止循环的执行，跳出循环体。而continue语句则用于跳过当前迭代，继续执行下一次循环。\n\n举例：\n\n使用break语句在满足条件时终止循环：\n\n\nprice = 100.0\nwhile True:\n    print(\"股票价格:\", price)\n    price += 100.0\n    if price &gt; 500.0:\n        break\n\n股票价格: 100.0\n股票价格: 200.0\n股票价格: 300.0\n股票价格: 400.0\n股票价格: 500.0\n\n\n使用continue语句跳过某些迭代：\n\nprices = [105.0, 102.5, 99.2, 101.8, 104.6]\nfor price in prices:\n    if price &lt; 100.0:\n        continue\n    print(\"收盘价:\", price)\n\n收盘价: 105.0\n收盘价: 102.5\n收盘价: 101.8\n收盘价: 104.6"
  },
  {
    "objectID": "07_02_条件语句和循环语句.html#编写具有条件判断和循环结构的程序",
    "href": "07_02_条件语句和循环语句.html#编写具有条件判断和循环结构的程序",
    "title": "22  Python条件语句",
    "section": "编写具有条件判断和循环结构的程序",
    "text": "编写具有条件判断和循环结构的程序\n在本节课程中，我们将进一步学习如何编写具有条件判断和循环结构的程序，并解决一些简单的问题。\n\n判断奇数和偶数 编写一个程序，判断一个数是奇数还是偶数，并打印出所有的奇数或偶数。\n\n举例：\n\n判断一个数是否为奇数：\n\n\nnum = int(input(\"请输入一个整数：\"))\n\nif num % 2 == 0:\n    print(num, \"是偶数\")\nelse:\n    print(num, \"是奇数\")\n\n10 是偶数\n\n\n打印出1到10之间的所有偶数：\n\nfor num in range(1, 11):\n    if num % 2 == 0:\n        print(num)\n\n2\n4\n6\n8\n10\n\n\n\n计算斐波那契数列 编写一个程序，计算斐波那契数列中的前n个数字。\n注释：斐波那契数列是什么？\n斐波那契数列是一个数列，其中每个数字都是前两个数字之和。数列的开始通常为0和1，后续的数字由前两个数字相加而得。\n\n数列的前几个数字如下： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …\n可以看到，数列中的第一个数字是0，第二个数字是1，而后续的每个数字都是前两个数字之和。\n斐波那契数列在自然界和数学中都有广泛的应用。例如，斐波那契数列可以用于描述植物的分枝规律、音乐中的节奏模式、金融中的利率计算等。\n举例：\n\n计算斐波那契数列前10个数字：\n\n\nn = 10\na, b = 0, 1\n\nfor _ in range(n):\n    print(a)\n    a, b = b, a + b\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\n\n判断质数 编写一个程序，判断一个数是否为质数（只能被1和它本身整除的数）。\n\n举例：\n\n判断一个数是否为质数：\n\n\nnum = int(input(\"请输入一个整数：\"))\n\nif num &lt; 2:\n    print(num, \"不是质数\")\nelse:\n    is_prime = True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\nif is_prime:\n    print(num, \"是质数\")\nelse:\n    print(num, \"不是质数\")\n\n30 不是质数"
  },
  {
    "objectID": "07_03_函数.html",
    "href": "07_03_函数.html",
    "title": "23  Python函数",
    "section": "",
    "text": "函数的定义和调用"
  },
  {
    "objectID": "07_03_函数.html#函数的作用",
    "href": "07_03_函数.html#函数的作用",
    "title": "23  Python函数",
    "section": "函数的作用",
    "text": "函数的作用\n函数是编程中的重要概念，它可以将一段代码封装为一个可重用的模块。 函数的作用和优势包括：\n\n代码重用：通过将一段经常使用的代码封装在函数中，我们可以在程序的不同地方多次调用该函数，避免了重复编写相同的代码，提高了代码的复用性。这样一来，如果需要修改功能或修复 bug，只需修改函数内部的实现，而不需要在多个地方逐个修改相同的代码。\n模块化：函数允许将程序划分为独立的模块，每个模块负责一个特定的功能。通过将复杂的任务分解为更小、更易管理的函数，可以使代码更易于理解和维护。模块化还有助于团队合作，不同的开发人员可以并行工作于不同的函数，从而提高开发效率。\n提高可读性：函数使代码更易读和理解。通过将一段代码封装在函数中，并给函数起一个有描述性的名称，可以提高代码的可读性。函数的参数和返回值也可以提供关于函数预期行为的重要信息，帮助其他开发人员理解和正确使用函数。\n抽象和封装：函数可以将复杂的实现细节隐藏在函数内部，只暴露必要的接口。这种抽象和封装的方式有助于降低代码的复杂性，提高代码的可维护性。其他部分的代码只需关注函数的输入和输出，而无需了解函数内部的具体实现。\n代码的组织和管理：函数可以将代码分成逻辑上独立的部分，使代码更加结构化和有组织。通过使用函数，可以将不同的功能模块分开，每个函数负责一个特定的任务。这样一来，当需要修改或添加新功能时，可以更容易地定位和修改相关的函数，而不必浏览整个代码文件。"
  },
  {
    "objectID": "07_03_函数.html#使用函数组织代码的优势",
    "href": "07_03_函数.html#使用函数组织代码的优势",
    "title": "23  Python函数",
    "section": "使用函数组织代码的优势",
    "text": "使用函数组织代码的优势\n函数是Python中最重要的部分之一，使用函数来组织代码可以使代码具有以下几个优势：\n\n可维护性：函数将代码划分为逻辑上独立的块，使得修改和调试代码更加容易。当需要对某个功能进行修改或修复时，只需关注相关的函数，而不必担心对其他部分代码产生意外影响。这种模块化的组织方式简化了代码的维护工作，提高了代码的可维护性。\n可重用性：通过将通用功能封装在函数中，可以在不同的地方多次调用该函数，实现代码的重用。不必重复编写相同的代码，减少了代码量，并且使得代码更加精简。当需要修改功能时，只需在函数内部进行修改，所有调用该函数的地方都会受到更新的影响。\n可读性：函数具有自我描述性的名称，可以提高代码的可读性。函数的参数和返回值提供了有关函数预期行为的重要信息，使得其他开发人员可以更轻松地理解和使用函数。通过适当划分和组织函数，可以使代码的逻辑更加清晰，易于理解。\n测试性：函数的独立性使得单元测试变得更加容易。通过针对函数编写单元测试，可以更好地验证函数的行为是否符合预期。这有助于及早发现和修复潜在的问题，提高代码的质量和可靠性。\n扩展性：使用函数进行代码组织可以使系统更易于扩展。通过添加新的函数或修改现有函数，可以实现新的功能或改进现有功能。由于函数之间的独立性，扩展一个功能不会对其他部分的代码造成太大的影响，减少了潜在的副作用和错误。\n\n总之，使用函数来组织代码可以提高代码的可维护性、可重用性、可读性和测试性，使得代码更易于扩展和管理。函数为代码提供了一种模块化的方式，使得开发人员能够更有效地开发、调试和维护代码。"
  },
  {
    "objectID": "07_03_函数.html#函数的定义",
    "href": "07_03_函数.html#函数的定义",
    "title": "23  Python函数",
    "section": "函数的定义",
    "text": "函数的定义\n函数是提前组织好的、可重复使用的、用来实现特定功能的代码段。input()、print()、str、int()等都是Python的内置函数。\n除了Python内置的函数，用户还可以根据自身的需求，自定义函数。函数的基础定义语法如下：\n\n# 函数的基础定义语法\ndef 函数名(传入参数):\n    函数体\n    return 返回值\n    \n# 调用函数\n函数名(参数)\n\n\n\n\n\n在定义函数时，有如下注意事事项：\n\n参数、返回值如不需要，可以省略\n函数名必须先定义后使用\n在定义函数语句的前后，规范上要求空2行"
  },
  {
    "objectID": "07_03_函数.html#函数的命名规则",
    "href": "07_03_函数.html#函数的命名规则",
    "title": "23  Python函数",
    "section": "函数的命名规则",
    "text": "函数的命名规则\n在Python中，函数的命名需要遵循一些规则和约定，以保持代码的可读性和一致性。以下是Python中函数命名的规则：\n\n函数名只能包含字母、数字和下划线（_）字符。\n函数名可以以字母或下划线开头，但不能以数字开头。\n函数名区分大小写，因此my_function和my_Function是不同的函数名。\n函数名应该具有描述性，能够清晰地表达函数的作用和功能。推荐使用小写字母和下划线的组合，以增加可读性。例如，calculate_average、print_message等。\n如果函数名由多个单词组成，可以使用下划线进行单词间的分隔，这样可以提高函数名的可读性。这种命名方式被称为下划线命名法（snake_case）。例如，calculate_average_score。\n避免使用Python的关键字和保留字作为函数名，以免引起冲突。例如，不要将函数命名为def、print等。\n函数名应该尽量简洁明了，避免过长的命名。选择能准确描述函数功能的简洁名称。"
  },
  {
    "objectID": "07_03_函数.html#函数的调用方式",
    "href": "07_03_函数.html#函数的调用方式",
    "title": "23  Python函数",
    "section": "函数的调用方式",
    "text": "函数的调用方式\n\n函数的传入参数\n函数的传入参数的功能是：在函数进行计算的时候，函数将接收外部提供的数据。\n\n函数的传入参数在函数被调用时指定。\n在函数定义中所提供的n个传入参数，称为形式参数(形参)，表示函数声明将要使用n个形式参数。\n在函数调用中所提供的传入参数，称为实际参数(实参)，表示函数执行时真正实用的参数值。\n\n在Python中，函数可以接受不同类型的参数作为输入。这些参数可以用于在函数内部进行计算、执行操作或提供必要的数据。以下是Python中函数传入参数的一些常见用法：\n\n位置参数（Positional Arguments）：这是最常见的参数传递方式，按照参数在函数定义中的顺序进行传递。调用函数时，传递的参数值按照对应位置依次赋给函数定义中的参数，即实参的位置要与形参一一对应。\n\n\n# 位置参数\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\n\ngreet(\"World\", \"Hello\")\ngreet(\"Python\", \"Hi\")\n\nHello, World!\nHi, Python!\n\n\n在上面的例子中，我们编辑了一个问候函数，仿照其格式，你也可以试试编辑一个自己的函数，用来对这个世界打招呼。\n\n关键字参数（Keyword Arguments）：使用关键字参数可以通过参数名来指定参数的值，而不必按照参数的顺序进行传递，即实参与形参的位置并不一一对应，但在传入参数时，需对使用参数名来进行标注。\n\n\n# 关键字参数\ndef greet2(name, message):\n    print(f\"{message}, {name}!\")\n\n\ngreet2(message=\"Hello\", name=\"World\")\ngreet2(name=\"Python\", message=\"Hi\")\n\nHello, World!\nHi, Python!\n\n\n灵活运用关键字参数可以让我们很容易地向函数传递数据，尝试编写一个函数，打乱向他传入参数的顺序，再使用关键字参数来调整。\n\n默认参数（Default Arguments）：函数定义时，可以为参数指定默认值，当调用函数时没有提供对应参数的值时，将使用默认值。在下面的示例中，将Hello设置为参数message的默认值，因此如果在调用参数时，没有传入message对应的值，message将会使用默认值Hello。\n\n\n# 默认参数\ndef greet3(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\n\ngreet3(\"World\")\ngreet3(\"Python\", \"Hi\")\n\nHello, World!\nHi, Python!\n\n\n\n可变数量参数（Variable-length Arguments）：有时候，我们需要处理可变数量的参数。Python提供了两种方式来处理这种情况：\n\n\n*args：表示函数接受任意数量的位置参数，这些参数将作为一个元组传递给函数。\n\n\n\n\n\n\n**kwargs：表示函数接受任意数量的关键字参数，这些参数将作为一个字典传递给函数。\n\n\n\n\n\n\n\n函数的返回值\n函数的返回值，就是程序中函数完成事情后，最后给调用者的结果。在Python中，函数可以通过返回值将计算结果或数据传递给调用方。函数的返回值可以是任意类型的数据，包括数字、字符串、列表、字典等。以下是Python中函数返回值的用法和示例代码：\n\n返回单个值：函数可以使用return语句返回单个值。一旦执行到return语句，函数将立即停止执行，并将指定的值返回给调用方。\n\n\ndef add_num(a, b):\n    return a + b\n\n\nresult = add_num(3, 4)\nprint(result)\n\n\n返回多个值：函数可以使用return语句返回多个值，这些值将被打包为一个元组。调用方可以使用多个变量来接收这些返回值。\n\n\n\n\n\n\n空返回值：如果函数没有明确的返回语句，或者使用return语句而没有指定返回值，函数将默认返回None。\n\n在Python中，有一个特殊的字面量：None，其类型是：&lt;class 'NoneType'&gt;。如果函数没有使用return语句返回数据，实际上就是返回了None这个字面量。\n\n\n\n\n\n\n\n提前返回：在函数执行过程中，可以使用return语句提前结束函数的执行，并返回指定的值。这可以在满足某个条件时提前退出函数。"
  },
  {
    "objectID": "07_03_函数.html#匿名函数lambda表达式",
    "href": "07_03_函数.html#匿名函数lambda表达式",
    "title": "23  Python函数",
    "section": "匿名函数（lambda表达式）",
    "text": "匿名函数（lambda表达式）\n在Python中，可以使用匿名函数（lambda表达式）来创建简单的、没有函数名的函数。匿名函数通常用于需要定义简短、一次性使用的函数。以下是匿名函数的用法和示例代码：\n\n# 匿名函数的语法\nlambda arguments: expression\n\n\nlambda关键字表示创建匿名函数。\narguments表示函数的参数列表。\nexpression表示函数的计算逻辑，即函数的返回值。\n\n匿名函数通常与内置函数（如map()、filter()等）一起使用，或者作为函数的参数传递给其他函数。\n下面是几个使用匿名函数的示例：\n\n匿名函数求平方：\n\n\nsquare = lambda x: x**2\nresult = square(5)\nprint(result)  # 输出：25\n\n25\n\n\n\n匿名函数求和：\n\n\naddition = lambda a, b: a + b\nresult = addition(3, 4)\nprint(result)  # 输出：7\n\n7\n\n\n\n使用内置函数map()和匿名函数对列表中的每个元素进行平方操作：\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = list(map(lambda x: x**2, numbers))\nprint(squared_numbers)  # 输出：[1, 4, 9, 16, 25]\n\n[1, 4, 9, 16, 25]\n\n\n\n使用内置函数filter()和匿名函数筛选出列表中的偶数：\n\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # 输出：[2, 4]\n\n[2, 4]\n\n\n匿名函数的优势在于其简洁性和灵活性，可以在需要临时定义函数的场景下快速创建函数，避免定义独立的函数名称。然而，由于其只能表示简单的表达式，因此不适合于复杂的逻辑和长代码块的情况。"
  },
  {
    "objectID": "07_03_函数.html#函数的嵌套和闭包",
    "href": "07_03_函数.html#函数的嵌套和闭包",
    "title": "23  Python函数",
    "section": "函数的嵌套和闭包",
    "text": "函数的嵌套和闭包\n\n函数的嵌套\n函数的嵌套调用是指在一个函数的定义中调用了另外的函数。在函数A中调用另外一个函数B时，会先把函数B中的任务都执行完毕后才会继续执行函数A的剩余内容。下面是函数嵌套的示例：\n\ndef func2():\n    print(\"我爱Python\")\n\n\ndef func1():\n    print(\"我是新手\")\n    func2()\n    print(\"我要好好学习\")\n\n\nfunc1()\n\n我是新手\n我爱Python\n我要好好学习\n\n\n在上面的示例中，函数func1在执行时，调用了函数func2，并且，只有在func2执行完成之后，func1才会继续执行剩余内容。\n\n在函数中使用的变量作用域\n\n变量的作用域指的是变量的作用范围，即变量在哪里可用，在哪里不可用。\n根据变量的作用范围，变量分为局部变量和全局变量。\n\n局部变量\n\n局部变量是指定义在函数体内部的变量，这种变量只在函数体内部生效。\n局部变量的作用：在函数体内部临时保存数据，在函数调用完成以后，局部变量就被销毁了。\n\n全局变量\n\n全局变量就是指在函数体内、外部都能生效的变量。\n\nglobal关键字\n\n使用global关键字，可以在函数内部声明变量为全局变量。\n\n\n函数的闭包\n在Python中，闭包（closure）是指在一个函数内部定义的函数，并且该内部函数可以访问外部函数的变量。闭包可以捕获并保持外部函数的状态，即使外部函数已经执行完毕，内部函数仍然可以使用外部函数的变量。这使得闭包在编程中非常有用，特别是在函数式编程和装饰器模式中。\n闭包的关键是内部函数可以访问外部函数的变量。在Python中，当内部函数引用外部函数的变量时，Python会将该变量包装成一个包含变量值的闭包对象。这个闭包对象可以在内部函数中使用，并且在内部函数被调用时仍然保持着它的值。\n\ndef outer_function(x):\n    def inner_function(y):\n        return x + y\n    return inner_function\n\nclosure = outer_function(10)\nresult = closure(5)\nprint(result)\n\n15\n\n\n在上面的例子中，outer_function是外部函数，它接受一个参数x。内部函数inner_function定义在外部函数内部，并引用了外部函数的参数 x。outer_function返回了内部函数inner_function，形成了一个闭包。\n在这个例子中，我们调用outer_function(10)并将返回的内部函数保存在 closure变量中。然后，我们调用closure(5)，这实际上是调用了内部函数inner_function。由于闭包的存在，内部函数仍然可以访问外部函数的变量x，所以结果将是10 + 5 = 15。\n通过闭包，我们可以创建具有记忆功能的函数，可以在多次调用之间保持状态。这使得闭包在实现装饰器、缓存功能等方面非常有用。"
  },
  {
    "objectID": "07_04_模块.html",
    "href": "07_04_模块.html",
    "title": "24  Python模块",
    "section": "",
    "text": "Python标准库的模块"
  },
  {
    "objectID": "07_04_模块.html#模块的概念",
    "href": "07_04_模块.html#模块的概念",
    "title": "24  Python模块",
    "section": "模块的概念",
    "text": "模块的概念\n在Python中，模块是一个包含函数、类和变量的Python文件。它提供了一种组织和重用代码的方式，使得我们可以将相关的代码组织在一个独立的单元中，并通过导入模块来使用其中的函数、类和变量。\n模块使得代码的组织更加模块化和可维护，可以将相关功能划分到不同的模块中，使得代码更易于理解和扩展。另外，通过使用模块，可以实现代码的复用，不必重复编写相同的代码。\n要使用一个模块，我们需要使用 import 语句将模块导入到当前的Python环境中。导入模块后，我们就可以通过模块名加点操作符来访问模块中定义的函数、类和变量。\n\n\n\n\n这就是模块的基本概念和用法。通过模块，我们可以更好地组织和复用代码，使得程序更加模块化和可维护。"
  },
  {
    "objectID": "07_04_模块.html#模块的使用",
    "href": "07_04_模块.html#模块的使用",
    "title": "24  Python模块",
    "section": "模块的使用",
    "text": "模块的使用\n学习如何使用Python标准库中的模块非常重要，因为标准库提供了大量功能丰富的模块，可以帮助我们完成各种任务。同时，我们自己定义的模块也常常能在工作中提供很大的帮助。\n以下是模块的基本使用方法：\n\n导入模块：要使用标准库模块，首先需要使用 import 语句将模块导入到当前的Python环境中。导入模块的一般语法是 import module_name。例如，要导入标准库中的 math 模块，可以使用 import math。\n\n\nimport math\n\nresult = math.sqrt(25)\nprint(result)  # 输出: 5.0\n\n5.0\n\n\n\n使用模块中的函数、类和变量：一旦导入了模块，就可以使用模块中定义的函数、类和变量。使用的语法是 module_name.function_name()、module_name.ClassName() 或 module_name.variable_name。例如，要使用 math 模块中的 sqrt 函数，可以使用 math.sqrt(25)。\n\n\nimport math\n\nresult = math.sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = math.pi * math.pow(radius, 2)\nprint(area)  # 输出: 78.53981633974483\n\n5.0\n78.53981633974483\n\n\n\n给模块起别名：有时模块名很长或与其他名称冲突，可以给模块起一个别名以便更方便地使用。使用别名的语法是 import module_name as alias。例如，要将 math 模块起别名为 m，可以使用 import math as m。\n\n\nimport math as m\n\nresult = m.sqrt(25)\nprint(result)  # 输出: 5.0\n\n5.0\n\n\n\n导入模块中的特定函数或变量：如果只需要使用模块中的某些特定函数或变量，可以使用 from module_name import item_name 的语法。这样可以直接使用 item_name，而无需使用模块名作为前缀。例如，要导入 math 模块中的 sqrt 函数，可以使用 from math import sqrt，然后直接使用 sqrt(25)。\n\n\nfrom math import sqrt, pi\n\nresult = sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = pi * radius ** 2\nprint(area)  # 输出: 78.53981633974483\n\n5.0\n78.53981633974483\n\n\n\n导入模块中的所有内容：如果希望导入模块中的所有函数、类和变量，可以使用 from module_name import * 的语法。这样可以直接使用模块中的所有内容，但可能会与其他已有的函数或变量发生冲突，因此需要谨慎使用。\n\n\nfrom math import *\n\nresult = sqrt(25)\nprint(result)  # 输出: 5.0\n\nradius = 5\narea = pi * radius ** 2\nprint(area)  # 输出: 78.53981633974483\n\n5.0\n78.53981633974483\n\n\n\n查看模块的帮助文档：Python标准库模块通常有详细的文档说明。可以使用 help(module_name) 函数来查看模块的帮助文档。例如，使用 help(math) 可以查看 math 模块的帮助文档。\n\n\nimport math\n\nhelp(math)"
  },
  {
    "objectID": "07_04_模块.html#常用的内置模块",
    "href": "07_04_模块.html#常用的内置模块",
    "title": "24  Python模块",
    "section": "常用的内置模块",
    "text": "常用的内置模块\n\nmath模块\n\nmath模块提供了执行数学运算的函数和常量。它包含了许多常见的数学操作，如三角函数、指数函数、对数函数等。\n\nimport math\n\nresult = math.sqrt(25)  # 平方根\nprint(result)  # 输出: 5.0\n\nangle = math.radians(45)  # 将角度转换为弧度\nsine = math.sin(angle)  # 正弦函数\nprint(sine)  # 输出: 0.7071067811865476\n\npi = math.pi  # 圆周率\nprint(pi)  # 输出: 3.141592653589793\n\n5.0\n0.7071067811865476\n3.141592653589793\n\n\n\nrandom模块\n\nrandom模块用于生成随机数。它提供了各种随机数生成函数，如生成随机整数、随机选择元素等。\n\nimport random\n\nnumber = random.randint(1, 10)  # 生成一个1到10之间的随机整数\nprint(number)  # 输出: 随机整数\n\nitems = [1, 2, 3, 4, 5]\nrandom_choice = random.choice(items)  # 从列表中随机选择一个元素\nprint(random_choice)  # 输出: 随机选择的元素\n\n3\n1"
  },
  {
    "objectID": "07_04_模块.html#文件和目录操作的模块",
    "href": "07_04_模块.html#文件和目录操作的模块",
    "title": "24  Python模块",
    "section": "文件和目录操作的模块",
    "text": "文件和目录操作的模块\n\nos模块\n\nos模块提供了许多与操作系统交互的函数。它可以用于执行文件和目录操作、获取系统信息等。\n\nimport os\n\ncurrent_dir = os.getcwd()  # 获取当前工作目录\nprint(current_dir)  # 输出: 当前工作目录的路径\n\nfile_list = os.listdir(current_dir)  # 获取当前目录下的文件列表\nprint(file_list)  # 输出: 当前目录下的文件列表\n\n\nshutil模块\n\nshutil模块用于高级的文件和目录操作。它提供了一些方便的函数，如复制文件、移动文件、删除文件等。\n\nimport shutil\n\nsource = 'path/to/source/file.txt'\ndestination = 'path/to/destination/file.txt'\n\nshutil.copy(source, destination)  # 复制文件"
  },
  {
    "objectID": "07_04_模块.html#时间和日期处理的模块",
    "href": "07_04_模块.html#时间和日期处理的模块",
    "title": "24  Python模块",
    "section": "时间和日期处理的模块",
    "text": "时间和日期处理的模块\n\ndatetime模块\n\ndatetime模块提供了处理日期和时间的功能。它包含了日期、时间、时间间隔等对象，以及各种日期和时间操作的函数。\n\nimport datetime\n\ncurrent_time = datetime.datetime.now()  # 获取当前时间\nprint(current_time)  # 输出: 当前时间\n\ncurrent_date = datetime.date.today()  # 获取当前日期\nprint(current_date)  # 输出: 当前日期\n\n2023-06-29 00:14:50.958106\n2023-06-29\n\n\n\ntime模块\n\ntime模块提供了与时间相关的函数。它可以用于获取当前时间、时间的格式化、休眠等操作。\n\nimport time\n\ncurrent_time = time.localtime()  # 获取当前时间的本地表示\nprint(current_time)  # 输出: 当前本地时间的结构化表示\n\nformatted_time = time.strftime('%Y-%m-%d %H:%M:%S', current_time)  # 格式化时间\nprint(formatted_time)  # 输出: 格式化后的时间字符串\n\ntime.struct_time(tm_year=2023, tm_mon=6, tm_mday=29, tm_hour=0, tm_min=15, tm_sec=30, tm_wday=3, tm_yday=180, tm_isdst=0)\n2023-06-29 00:15:30\n\n\n这些模块是Python标准库中的一小部分，它们提供了广泛的功能和工具，可帮助您处理数学运算、随机数生成、文件和目录操作、日期时间处理等各种任务。\n要熟练使用Python，就需要掌握这些模块的使用方法，并能够根据需要，自定义模块。"
  },
  {
    "objectID": "07_04_模块.html#第三方模块的概念及安装方法",
    "href": "07_04_模块.html#第三方模块的概念及安装方法",
    "title": "24  Python模块",
    "section": "第三方模块的概念及安装方法",
    "text": "第三方模块的概念及安装方法\n在Python中，第三方模块是由Python社区或其他开发者开发的，用于扩展Python功能和提供额外功能的模块。这些模块通常不包含在Python标准库中，但它们提供了各种用途的功能，例如网络请求、数据分析、图像处理等。\n安装第三方模块可以通过使用包管理工具pip来完成。pip是Python的默认包管理工具，可用于安装、升级和卸载第三方模块。\n以下是安装第三方模块的步骤：\n\n确保已安装pip：\n\n在终端或命令提示符中运行以下指令。检查pip是否已安装：\n\npip --version\n\n如果输出了pip的版本信息，则说明pip已安装。如果未找到pip或提示未定义的命令，则需要先安装pip。\n\n使用pip安装模块：要安装第三方模块，可以在终端或命令提示符中运行以下命令：\n\n\npip install module_name\n\n例如，要安装常用的第三方模块requests，可以运行：\n\npip install requests\n\n其中，module_name是要安装的第三方模块的名称。pip将自动下载并安装该模块及其相关依赖项。\n\n确认安装成功：安装完成后，可以在Python脚本中导入并使用该模块。如果没有报错，则表示安装成功。示例如下：\n\n\nimport requests\n\nresponse = requests.get('https://www.example.com')\nprint(response.status_code)\n\n上述代码导入了requests模块，并使用该模块发送HTTP请求。\n需要注意的是，有些第三方模块可能需要特定版本的Python或其他依赖项。在安装之前，建议查阅该模块的官方文档或README文件，以了解安装要求和使用说明。\n另外，还有其他包管理工具可以用于安装第三方模块，例如conda、pipenv等，具体根据您的需求和使用环境选择合适的工具。\n总的来说，第三方模块为Python提供了丰富的扩展功能，我们可以根据特定的项目需求安装第三方模块。"
  },
  {
    "objectID": "07_04_模块.html#常用的数据分析和科学计算库",
    "href": "07_04_模块.html#常用的数据分析和科学计算库",
    "title": "24  Python模块",
    "section": "常用的数据分析和科学计算库",
    "text": "常用的数据分析和科学计算库\nNumPy和Pandas是Python数据分析和科学计算中的重要库。NumPy提供了高性能的数值计算和数组操作功能，适用于处理大规模数值数据；而Pandas则专注于数据分析和操作，提供了灵活且高效的数据结构和数据处理工具，使得数据的清洗、转换和分析更加方便。这两个库通常一起使用，使得数据科学工作更加便捷和高效。\n\nNumPy（Numerical Python）\n\n\nNumPy是Python中用于数值计算和科学计算的核心库。\nNumPy提供了一个强大的多维数组对象（ndarray），可以进行高效的数值运算和数组操作。ndarray是一个具有相同类型和大小的元素组成的多维容器，它提供了高速的数值运算和广播功能。\nNumPy的主要特点包括：\n\n多维数组操作：NumPy提供了广泛的数组操作函数，例如索引、切片、形状操作、重塑、拼接等。\n数学函数：NumPy包含了各种数学函数，如三角函数、指数函数、对数函数、统计函数等。\n线性代数运算：NumPy提供了线性代数运算功能，如矩阵乘法、逆矩阵、特征值等。\n随机数生成：NumPy具有随机数生成的功能，可以生成各种概率分布的随机数。\n\n\nNumPy是Python科学计算的基础库，许多其他科学计算和数据分析库都建立在NumPy之上。\n下面是NumPy的简单应用示例：\n\nimport numpy as np\n\n# 创建NumPy数组\narr = np.array([1, 2, 3, 4, 5])\n\n# 数组运算\nprint(arr + 1)  # 加法运算\nprint(arr * 2)  # 乘法运算\nprint(np.mean(arr))  # 平均值\n\n# 多维数组\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2d.shape)  # 输出: (2, 3)\n\n# 线性代数运算\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nprint(np.dot(a, b))  # 矩阵相乘\n\n[2 3 4 5 6]\n[ 2  4  6  8 10]\n3.0\n(2, 3)\n[[19 22]\n [43 50]]\n\n\n\nPandas\n\n\nPandas是一个功能强大的数据分析和操作库，构建在NumPy之上。\nPandas提供了两个重要的数据结构：Series和DataFrame。\n\nSeries是一维的标签化数组，类似于带标签的一维数组，可以容纳任意类型的数据。\nDataFrame是二维的表格型数据结构，类似于SQL中的表或Excel中的电子表格，具有行和列的标签，每列可以是不同的数据类型。\n\nPandas的主要功能包括：\n\n数据读取和写入：Pandas可以从各种数据源（如CSV文件、Excel文件、SQL数据库等）读取数据，并可以将数据写入不同的格式。\n数据清洗和预处理：Pandas提供了丰富的功能来处理缺失值、重复数据、异常值等数据清洗任务。\n数据操作和计算：Pandas支持灵活的数据操作和计算，如索引、切片、筛选、聚合、分组等。\n时间序列处理：Pandas提供了强大的时间序列处理功能，支持日期和时间的索引、重采样、滚动窗口计算等。\n数据可视化：Pandas集成了Matplotlib库，可以方便地进行数据可视化。\n\n\nPandas提供了高效的数据处理和分析工具，使得数据科学家和分析师能够更轻松地处理和分析结构化数据。\n\nimport pandas as pd\n\n# 创建Pandas DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n        'Age': [25, 30, 35, 40],\n        'City': ['New York', 'London', 'Paris', 'Tokyo']}\n\ndf = pd.DataFrame(data)\n\n# 数据操作\nprint(df.head())  # 查看前几行数据\nprint(df['Age'].mean())  # 计算年龄的平均值\n\n# 数据筛选\nfiltered_df = df[df['Age'] &gt; 30]  # 筛选年龄大于30的数据\nprint(filtered_df)\n\n# 数据分组和聚合\ngroupby_city = df.groupby('City')\nmean_age_by_city = groupby_city['Age'].mean()\nprint(mean_age_by_city)\n\n# 时间序列处理\ndates = pd.date_range(start='2021-01-01', end='2021-12-31', freq='D')\nprint(dates)\n\n      Name  Age      City\n0    Alice   25  New York\n1      Bob   30    London\n2  Charlie   35     Paris\n3    David   40     Tokyo\n32.5\n      Name  Age   City\n2  Charlie   35  Paris\n3    David   40  Tokyo\nCity\nLondon      30.0\nNew York    25.0\nParis       35.0\nTokyo       40.0\nName: Age, dtype: float64\nDatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',\n               '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08',\n               '2021-01-09', '2021-01-10',\n               ...\n               '2021-12-22', '2021-12-23', '2021-12-24', '2021-12-25',\n               '2021-12-26', '2021-12-27', '2021-12-28', '2021-12-29',\n               '2021-12-30', '2021-12-31'],\n              dtype='datetime64[ns]', length=365, freq='D')\n\n\nPandas库将是我们后面学习的重点内容，大家可以预先了解。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#基本公式和函数",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#基本公式和函数",
    "title": "25  Excel和Python的类比学习",
    "section": "基本公式和函数",
    "text": "基本公式和函数\n\n数据转换：\n\nExcel：Excel提供了各种内置的公式和函数，可以对数据进行转换操作，如文本处理、日期转换、数值计算等。\nPandas：Pandas提供了一系列的数据转换函数和方法，如字符串处理、日期时间处理、数值计算、缺失值处理等，可以对DataFrame中的数据进行转换和处理。\n\n计算操作：\n\nExcel：Excel的公式和函数可以进行各种计算操作，如数值计算、统计计算、逻辑计算等。\nPandas：Pandas提供了丰富的数值计算、统计计算和逻辑计算函数和方法，如求和、均值、最大值、最小值、标准差、排序等，可以对DataFrame中的数据进行计算和分析。\n\n自定义函数：\n\nExcel：Excel允许用户创建自定义的函数，以满足特定的数据处理和计算需求。\nPandas：Pandas提供了灵活的编程接口，允许用户自定义函数，并可以应用于DataFrame中的数据，以实现特定的数据处理和计算逻辑。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#排序和筛选",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#排序和筛选",
    "title": "25  Excel和Python的类比学习",
    "section": "排序和筛选",
    "text": "排序和筛选\n\n排序：\n\nExcel：可以使用Excel的排序功能对表格中的数据进行升序或降序排序，可以基于单个或多个列进行排序。\nPandas：Pandas提供了sort_values()函数，可以对DataFrame对象的一列或多列进行排序，支持升序和降序排序。\n\n筛选：\n\nExcel：Excel提供了筛选功能，可以使用筛选器来过滤表格中的数据，只显示符合特定条件的行。\nPandas：Pandas提供了多种方式进行筛选，例如使用条件表达式、使用query()函数、使用loc[]和iloc[]索引器等，可以根据条件筛选DataFrame中的行。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#分类和汇总",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#分类和汇总",
    "title": "25  Excel和Python的类比学习",
    "section": "分类和汇总",
    "text": "分类和汇总\n\n分类（Grouping）：\n\nExcel：Excel提供了分类功能，可以根据一个或多个列对数据进行分组，并生成每个组的汇总信息，如计数、求和、平均值等。\nPandas：Pandas提供了groupby()函数，可以根据一个或多个列对DataFrame对象进行分组，并进行各种聚合操作，如计数、求和、平均值、最大值、最小值等。\n\n汇总（Aggregation）：\n\nExcel：Excel的分类功能可以生成各个组的汇总信息，如计数、求和、平均值、最大值、最小值等。\nPandas：Pandas的groupby()函数结合聚合函数（如sum()、mean()、max()、min()等）可以对分组后的数据进行各种汇总操作。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#数据透视表",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#数据透视表",
    "title": "25  Excel和Python的类比学习",
    "section": "数据透视表",
    "text": "数据透视表\n\n创建透视表：\n\nExcel：Excel提供了直观的用户界面，可以通过拖拽字段到不同的区域（行、列、值）创建透视表。\nPandas：Pandas提供了pivot_table()函数，可以基于DataFrame对象创建透视表，需要指定行、列和值字段，并可以选择不同的聚合函数进行汇总。\n\n设置行、列和值字段：\n\nExcel：Excel提供了直观的用户界面，可以将字段拖拽到透视表的不同区域，如行、列和值。\nPandas：Pandas的pivot_table()函数中的参数可以指定要用作透视表的行、列和值字段。\n\n聚合操作：\n\nExcel：Excel的数据透视表可以对值字段进行不同的聚合操作，如求和、平均值、计数等。\nPandas：Pandas的pivot_table()函数通过指定聚合函数（如sum()、mean()、count()等）对值字段进行聚合操作。\n\n过滤和排序：\n\nExcel：Excel的数据透视表可以通过筛选和排序功能对数据进行过滤和排序。\nPandas：Pandas的透视表可以使用pivot_table()函数的参数进行数据过滤和排序。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#查找合并数据",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#查找合并数据",
    "title": "25  Excel和Python的类比学习",
    "section": "查找合并数据",
    "text": "查找合并数据\n\n合并数据：\n\nExcel：VLOOKUP函数用于在两个表格中查找匹配的值，并将相关数据合并到一个表格中。\nPandas：Pandas提供了merge()函数，可以根据一个或多个键（列）将两个DataFrame对象合并成一个新的DataFrame对象。\n\n指定合并键：\n\nExcel：VLOOKUP函数通过指定要匹配的键（列）来进行数据合并。\nPandas：merge()函数通过指定要用作合并键的列名来进行数据合并。\n\n合并类型：\n\nExcel：VLOOKUP函数支持不同的合并类型，如精确匹配、近似匹配等。\nPandas：merge()函数支持不同的合并类型，如内连接、左连接、右连接和外连接等。\n\n多对一合并：\n\nExcel：VLOOKUP函数可以在一个表格中的多个匹配项中选择一个合适的值进行合并。\nPandas：merge()函数可以在一个表格中的多个匹配项中选择一个合适的值进行合并，或者将多个匹配项合并为一个列表。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#match和index函数索引和查找功能",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#match和index函数索引和查找功能",
    "title": "25  Excel和Python的类比学习",
    "section": "MATCH和INDEX函数（索引和查找功能）",
    "text": "MATCH和INDEX函数（索引和查找功能）\n\n索引功能：\n\nExcel：INDEX函数用于在一个范围内根据行号和列号返回对应的数值。\nPandas：Pandas提供了多种索引方式，如使用loc[]和iloc[]索引器，可以根据行号和列号或条件进行数据的选择和定位。\n\n查找功能：\n\nExcel：MATCH函数用于在一个范围内查找指定的值，并返回其相对位置或位置索引。\nPandas：Pandas提供了多种方法进行数据的查找，如使用isin()函数、使用条件表达式、使用query()函数等，可以根据指定的条件查找数据。"
  },
  {
    "objectID": "07_05_Excel和Python的Pandas功能类比学习.html#具体内容扩展",
    "href": "07_05_Excel和Python的Pandas功能类比学习.html#具体内容扩展",
    "title": "25  Excel和Python的类比学习",
    "section": "*具体内容扩展",
    "text": "*具体内容扩展\n\n扩展1（具体的公式和函数）\n在Excel中，有许多内置的函数和公式可用于数据转换。以下是一些常用的函数和公式的示例：\n\n文本处理：\n\nCONCATENATE：将多个文本字符串合并为一个字符串。\nLEFT/RIGHT/MID：从字符串中提取左侧/右侧/中间的字符。\nUPPER/LOWER/PROPER：将文本转换为大写/小写/首字母大写。\nTRIM：去除字符串两端的空格。\nSUBSTITUTE：替换字符串中的特定字符。\n\n日期转换：\n\nDATE/YEAR/MONTH/DAY：根据给定的年、月、日创建日期。\nHOUR/MINUTE/SECOND：从日期时间中提取小时、分钟、秒数。\nDATEVALUE/TIMEVALUE：将文本日期/时间转换为日期/时间值。\nTEXT：将日期/时间格式化为特定的文本格式。\n\n数值计算：\n\nSUM/AVERAGE/MIN/MAX：对一组数值进行求和/平均值/最小值/最大值计算。\nCOUNT/COUNTA：计算给定范围内的数值/非空单元格的数量。\nROUND/ROUNDUP/ROUNDDOWN：对数值进行四舍五入/向上取整/向下取整。\nABS/POWER/SQRT：计算数值的绝对值/幂次方/平方根。\n\n\n这只是一小部分Excel中可用的函数和公式示例。Excel提供了丰富的函数库，可以满足各种数据转换和计算需求。\n在Pandas中，同样有许多函数和方法可用于数据转换。以下是一些常用的函数和方法的示例：\n\n字符串处理：\n\nstr.lower()/str.upper()/str.capitalize()：将字符串转换为小写/大写/首字母大写。\nstr.replace()：替换字符串中的特定子串。\nstr.split()/str.join()：将字符串拆分为子串列表/将子串列表连接为字符串。\nstr.extract()/str.extractall()：从字符串中提取满足特定模式的子串。\n\n日期时间处理：\n\npd.to_datetime()：将字符串转换为日期时间格式。\ndt.year/dt.month/dt.day：从日期时间中提取年/月/日。\ndt.hour/dt.minute/dt.second：从日期时间中提取小时/分钟/秒数。\npd.to_timedelta()：将字符串转换为时间间隔。\n\n数值计算：\n\nDataFrame.sum()/DataFrame.mean()/DataFrame.min()/DataFrame.max()：对DataFrame中的列进行求和/平均值/最小值/最大值计算。\nDataFrame.count()/DataFrame.count_nonzero()：计算DataFrame中的非缺失值/非零值的数量。\nDataFrame.round()：对DataFrame中的数值进行四舍五入。\nDataFrame.abs()/DataFrame.pow()/DataFrame.sqrt()：计算DataFrame中数值的绝对值/幂次方/平方根。\n\n\nPandas提供了更多的函数和方法，用于数据转换、处理和分析。这些函数和方法可以应用于DataFrame对象的列或整个数据集，使得数据转换更加灵活和方便。\n\n\n扩展2（Excel的VLOOLUP函数）\n在Excel中，VLOOKUP（垂直查找）是一种在一个表格或范围中进行垂直查找并返回相关值的函数。VLOOKUP函数常用于以下情况：\n\n查找匹配的值：VLOOKUP函数可以根据给定的搜索值，在指定的表格或范围中查找匹配的值。例如，在一个包含产品名称和对应价格的表格中，可以使用VLOOKUP函数根据产品名称查找对应的价格。\n提取相关值：VLOOKUP函数可以根据查找到的匹配值，提取相关的值。例如，在一个包含员工姓名和对应工资的表格中，可以使用VLOOKUP函数查找特定员工的工资。\n建立数据关联：VLOOKUP函数可以建立数据之间的关联关系。例如，在一个包含客户姓名和对应客户ID的表格中，可以使用VLOOKUP函数根据客户姓名查找对应的客户ID，从而在不同数据表之间建立关联。\n\nVLOOKUP函数的基本语法如下：\nVLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])\n\nlookup_value：要查找的值或参考单元格。\ntable_array：包含要查找的值的表格或范围。\ncol_index_num：要返回的值所在列的索引号，索引号从table_array的第一列开始计数。\nrange_lookup（可选）：指定是否进行近似匹配。默认为TRUE或省略，表示进行近似匹配；FALSE表示进行精确匹配。\n\n\n\n扩展3（Excel的MATCH和INDEX函数）\nMATCH和INDEX是Excel中常用的函数，经常与VLOOKUP函数一起使用，用于在表格或范围中进行查找和提取数据。\n\nMATCH函数： MATCH函数用于在单个列或行中查找给定值，并返回其在列或行中的相对位置（索引号）。 MATCH函数的基本语法如下：\n\nMATCH(lookup_value, lookup_array, [match_type])\n\nlookup_value：要查找的值或参考单元格。\nlookup_array：包含要查找的值的单个列或行。\nmatch_type（可选）：指定查找的类型。可选值为1（默认值）表示查找小于或等于lookup_value的最大值；-1表示查找大于或等于lookup_value的最小值；0表示精确匹配。\n\nMATCH函数返回查找值在查找数组中的相对位置（索引号）。可以根据需要将MATCH函数应用于单个单元格或一系列单元格。\n\nINDEX函数： INDEX函数用于根据给定的行号和列号，在给定的表格或范围中提取对应位置的值。 INDEX函数的基本语法如下：\n\nINDEX(array, row_num, [column_num])\n\narray：要从中提取数据的表格或范围。\nrow_num：要提取数据的行号。\ncolumn_num（可选）：要提取数据的列号。如果省略，则INDEX函数返回整个行的值。\n\nINDEX函数根据给定的行号和列号，在array中定位对应位置的值，并返回该值。可以根据需要将INDEX函数应用于单个单元格或一系列单元格。\nMATCH和INDEX函数通常结合使用，可以实现更灵活和复杂的数据查找和提取操作。MATCH函数用于查找指定值的位置，然后将该位置作为行号或列号传递给INDEX函数，以提取相应的值。这种组合可以在不要求数据排序的情况下，根据某个条件快速查找和提取数据。"
  },
  {
    "objectID": "07_06_错误汇总.html#含义对照表",
    "href": "07_06_错误汇总.html#含义对照表",
    "title": "26  Python常见的异常提示",
    "section": "含义对照表",
    "text": "含义对照表\n\n\n\n异常名称\n描述\n\n\n\n\nBaseException\n所有异常的基类\n\n\nSystemExit\n解释器请求退出\n\n\nKeyboardInterrupt\n用户中断执行(通常是输入^C)\n\n\nException\n常规错误的基类\n\n\nStopIteration\n迭代器没有更多的值\n\n\nGeneratorExit\n生成器(generator)发生异常来通知退出\n\n\nStandardError\n所有的内建标准异常的基类\n\n\nArithmeticError\n所有数值计算错误的基类\n\n\nFloatingPointError\n浮点计算错误\n\n\nOverflowError\n数值运算超出最大限制\n\n\nZeroDivisionError\n除(或取模)零 (所有数据类型)\n\n\nAssertionError\n断言语句失败\n\n\nAttributeError\n对象没有这个属性\n\n\nEOFError\n没有内建输入,到达EOF 标记\n\n\nEnvironmentError\n操作系统错误的基类\n\n\nIOError\n输入/输出操作失败\n\n\nOSError\n操作系统错误\n\n\nWindowsError\n系统调用失败\n\n\nImportError\n导入模块/对象失败\n\n\nLookupError\n无效数据查询的基类\n\n\nIndexError\n序列中没有此索引(index)\n\n\nKeyError\n映射中没有这个键\n\n\nMemoryError\n内存溢出错误(对于Python 解释器不是致命的)\n\n\nNameError\n未声明/初始化对象 (没有属性)\n\n\nUnboundLocalError\n访问未初始化的本地变量\n\n\nReferenceError\n弱引用(Weak reference)试图访问已经垃圾回收了的对象\n\n\nRuntimeError\n一般的运行时错误\n\n\nNotImplementedError\n尚未实现的方法\n\n\nSyntaxError\nPython 语法错误\n\n\nIndentationError\n缩进错误\n\n\nTabError\nTab 和空格混用\n\n\nSystemError\n一般的解释器系统错误\n\n\nTypeError\n对类型无效的操作\n\n\nValueError\n传入无效的参数\n\n\nUnicodeError\nUnicode 相关的错误\n\n\nUnicodeDecodeError\nUnicode 解码时的错误\n\n\nUnicodeEncodeError\nUnicode 编码时错误\n\n\nUnicodeTranslateError\nUnicode 转换时错误\n\n\nWarning\n警告的基类\n\n\nDeprecationWarning\n关于被弃用的特征的警告\n\n\nFutureWarning\n关于构造将来语义会有改变的警告\n\n\nOverflowWarning\n旧的关于自动提升为长整型(long)的警告\n\n\nPendingDeprecationWarning\n关于特性将会被废弃的警告\n\n\nRuntimeWarning\n可疑的运行时行为(runtime behavior)的警告\n\n\nSyntaxWarning\n可疑的语法的警告"
  }
]